# [Express.js Tutorial ](https://www.apnacollege.in/path-player?courseid=sigma-8&unit=688f6e5157ce496f9609b465Unit)

## Library v/s Framework
The difference boils down to **control** and **flow of execution**:

### ğŸ“š Library

- **You** are in charge.

- You write the main program, and when you need a certain function, you _call_ the libraryâ€™s methods.

- Think of it like a toolbox â€” you decide which tools to pick and when to use them.

- Example: Using `NumPy` in Python â€” you write the logic and call `numpy.array()` or `numpy.mean()` when needed.

**Key point:** _You call the library._

### ğŸ–¼ï¸ Framework

- **The framework** is in charge.

- You plug your code into its structure, and it calls your code at the right moments.

- It defines the architecture, flow, and rules â€” you just fill in the missing pieces.

- Example: `Django` â€” you follow its conventions, and Django decides when to call your views, models, and templates.

**Key point:** _The framework calls you._ (This is called **Inversion of Control**.)

### ğŸ’¡ Quick analogy:

- **Library**: Youâ€™re the chef, and you grab ingredients (library functions) when you want.

- **Framework**: Youâ€™re a chef working in a restaurant chain â€” the kitchen layout, cooking sequence, and plating rules are set by the restaurant (framework). You just cook within their system.

---

## What is Express.js?
**Express.js** is a **minimal, unopinionated web framework** for **[[5. Node.js Notes|Node.js]]**.

Hereâ€™s the breakdown:

- **Purpose:** Build web applications and APIs quickly.

- **Role:** It sits on top of Node.js â€™s built-in `http` module, making it much easier to handle routing, requests, responses, and middleware.

- **Minimal:** It doesnâ€™t force a specific project structure or tools â€” you decide how to organize things.

- **Unopinionated:** It gives you flexibility instead of strict rules (unlike Django or Rails).

### ğŸ”‘ Key Features:

1. **Routing** â€“ Easily define endpoints like `app.get('/users', ...)`.

2. **Middleware** â€“ Functions that run in the request/response cycle (logging, authentication, parsing JSON, etc.).

3. **HTTP Utilities** â€“ Helpers for headers, status codes, redirects, etc.

4. **Integration** â€“ Works with view engines (EJS, Pug) or can be API-only (JSON responses).

### ğŸ“œ Usage:
The 4 applications are:

1. **Listening** for request.

2. **parse** the request for Node.js

3. Match the request with available **routes**

4. **Response**

### âœ… Example :

```js
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send('Hello World');
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

### ğŸ’¡ In short:
Express.js is to Node.js what a steering wheel is to a car chassis â€” Node gives you the engine, Express gives you the control interface so you can actually drive.

---

## How to download Express.js?
To download **Express.js**, you install it as a package using **npm** (Node Package Manager).

Hereâ€™s the step-by-step:

**1ï¸âƒ£ Install Node.js & npm (if you havenâ€™t already)**

- Go to [https://nodejs.org](https://nodejs.org/)

- Download the **LTS** version and install it â€” this also installs `npm` automatically.

- Check installation:
	
```bash
node -v
npm -v
```

**2ï¸âƒ£ Create a project folder**

```bash
mkdir myapp
cd myapp
```

**3ï¸âƒ£ Initialize a `package.json` file** (to track your projectâ€™s dependencies)

```bash
npm init -y
```

**4ï¸âƒ£ Install Express.js**

```bash
npm install express
```

This downloads Express and adds it to your `package.json` dependencies.

**5ï¸âƒ£ Verify**  
Check `node_modules/express` or see it listed in `package.json`.

---

## 'Hello World' in Express.js

### Making first server

**2ï¸âƒ£ Create a index.js file & open it** - Default file to start the server:

```bash
touch index.js
```

In the file:

```js
const express = require("express");
const app = express();
console.log(app);
```

**Key things you just did**:

1. **Utilize the framework** (`const express = require("express");`)

2. **Created an Express app** (`const app = express();`)

>  **app** (conventional naming) is the main thing here. It's a large object that contains useful methods to manage the server.


**2ï¸âƒ£ Listening for request**:

```js
const port = 3000;

app.listen(port, () => {
    console.log(`Server is started listening at port: ${port}`);
});
```

**Key things you just did**:

1. **Created an port** (`const port = 3000;`)

2. **Started a server** with `app.listen()`.

> **port:** It's a logical endpoint where client and server can exchange data, just like computer ports for pen drives & chargers or, sea ports where thing using ships can get transferred.
*Some ports are allotted for specific tasks... We can use 3000 & 8080*


**2ï¸âƒ£ Start & use the server:**

1. **Run** the file using node.
	
```bash
node index.js
```

2. Then **visit**: 
	
	[http://localhost:3000](http://localhost:3000/)

### Handling Request

#### `.use()` Method
In **Express.js**, the `.use()` method is used to **mount middleware functions** or **sub-applications** at a specified path.

Hereâ€™s the breakdown:

##### Syntax

```js
app.use([path], callback)
```

- **`path`** _(optional)_ â€” The route where the middleware will be executed. Defaults to `'/'` if omitted.

- **`callback`** â€” The middleware function (or multiple middleware functions) to run.

##### Key Points

1. **Middleware execution order matters** â€” Express runs middleware in the order they are defined.

2. **Path matching is prefix-based** â€” If you mount at `/api`, it matches `/api`, `/api/users`, `/api/posts`, etc.

3. **No HTTP method restriction** â€” Unlike `app.get()` or `app.post()`, `.use()` applies to **all HTTP methods** by default.

4. **Can mount routers** â€” You can attach entire router instances with `.use()`.

##### Examples

###### **1. Global middleware**

```js
const express = require('express');
const app = express();

app.use((req, res, next) => {
    console.log(`${req.method} ${req.url}`);
    next(); // Pass to next middleware/route
});

app.get('/', (req, res) => {
    res.send('Home Page');
});

app.listen(3000);
```

- This logs every request before hitting any route.

###### **2. Path-specific middleware**

```js
app.use('/admin', (req, res, next) => {
    console.log('Admin area accessed');
    next();
});
```

- Runs **only** when the URL starts with `/admin`.

###### **3. Mounting routers**

```js
const userRouter = require('./routes/users');
app.use('/users', userRouter);
```

- Routes in `users.js` will be available under `/users/*`.

###### **4. Serving static files**

```js
app.use(express.static('public'));
```

- Serves static files like `/images/logo.png` from `public/` directory.

##### Pro tip:
Use `.use()` for:

- Applying **global middleware** (logging, parsing, authentication checks)

- Mounting **routers**

- Serving **static files**

==**Disclaimer:** Avoid using .use() for request handlers that only respond to a **specific HTTP method** â€” use .get(), .post(), etc. Instead.==

---

#### `Req` & `Res`
In **Express.js**, `req` and `res` are the two core objects you interact with in any route or middleware function:

##### 1. `req` (Request Object)

Represents the **HTTP request** that comes from the client (browser, API call, etc.).

**Key properties:**

- **`req.method`** â€” HTTP method (`GET`, `POST`, `PUT`, `DELETE`, etc.)

- **`req.url`** â€” URL path of the request

- **`req.path`** â€” Just the path part, without query string

- **`req.query`** â€” Object with query parameters  
    Example: `/search?q=hello` â†’ `req.query.q === 'hello'`

- **`req.params`** â€” Route parameters  
    Example: `/users/:id` â†’ `/users/42` â†’ `req.params.id === '42'`

- **`req.body`** â€” Data sent in POST/PUT requests (requires body-parsing middleware like `express.json()`)

- **`req.headers`** â€” All request headers

- **`req.ip`** â€” Clientâ€™s IP address

- **`req.cookies`** â€” Cookies sent by the client (requires `cookie-parser`)

###### âœ… **Example:**

```js
app.get('/users/:id', (req, res) => {
    console.log(req.method); // GET
    console.log(req.params.id); // URL param
    console.log(req.query.sort); // Query string param
    res.send('User details');
});
```

##### 2. `res` (Response Object)

Represents the **HTTP response** you send back to the client.

**Key methods:**

- **`res.send(body)`** â€” Sends a response (string, object, buffer, etc.)

- **`res.json(object)`** â€” Sends JSON data

- **`res.status(code)`** â€” Sets HTTP status code  
    Example: `res.status(404).send('Not Found')`

- **`res.redirect(url)`** â€” Redirects to another URL

- **`res.render(view, data)`** â€” Renders a template (if a view engine is set)

- **`res.set(field, value)`** â€” Set HTTP headers

- **`res.download(path)`** â€” Sends a file for download

- **`res.sendFile(path)`** â€” Sends a file for viewing

###### âœ… **Example:**

```js
app.get('/', (req, res) => {
    res.status(200).json({
        message: 'Hello World',
        method: req.method
    });
});
```

##### **How they work together**

When a client sends a request:

1. Express builds a **`req`** object from the incoming HTTP request data.

2. You use `req` to **read** data from the client.

3. You use `res` to **send** data back to the client.

---

#### `.send()` Method
In **Express.js**, the `.send()` method is part of the **`res`** (response) object and is used to **send a response back to the client**.

##### ğŸ“œ Basic Usage

```js
res.send(body)
```

- **`body`** can be a **string**, **Buffer**, **object**, or **array**.

- Automatically sets the **`Content-Type`** based on what you send.

- Ends the response (you donâ€™t need to call `.end()` after it).

##### âš›ï¸ Behavior

- **String** â†’ Sends as plain text
	
```js
res.send('Hello World'); // Content-Type: text/html; charset=utf-8
```

- **Object / Array** â†’ Automatically converted to JSON
	
```js
res.send({ message: 'Hello' }); // Content-Type: application/json
```

- **Buffer** â†’ Sends binary data (e.g., files)
    
```js
res.send(Buffer.from('Hello'));
```

- **`null` / `undefined`** â†’ Sends empty response

##### â— Setting Status Codes

```js
res.status(404).send('Not Found');
res.status(200).send({ success: true });
```

- `.status()` sets the HTTP status code before `.send()`.

##### âš ï¸ Difference from `.json()`

- `res.send()` will **guess the Content-Type** based on the data type.

- `res.json()` **always sends JSON** and formats it properly.
    
```js
res.send({ hello: 'world' }); // Works, but auto-type detection
res.json({ hello: 'world' }); // Explicitly JSON
```

##### âœ… Example

```js
app.get('/', (req, res) => {
    res.send('<h1>Welcome!</h1>'); // HTML
});

app.get('/data', (req, res) => {
    res.status(200).send({ user: 'Sankho', role: 'Student' }); // JSON
});
```

---

## Routing in Express.js

### What is Routing?
Routing is how an Express application defines **how it responds** to client requests (HTTP methods + paths).

A route is defined by:

1. **HTTP Method** â†’ GET, POST, PUT, DELETE, PATCH, etc.

2. **Path** â†’ `/`, `/users`, `/api/products/:id`, etc.

3. **Handler Function(s)** â†’ Logic that runs when the route matches.

### Basic Route Structure
The syntax is:

```js
app.METHOD(PATH, HANDLER);
```

- `app` â†’ Your Express application instance

- `METHOD` â†’ `.get()`, `.post()`, `.put()`, `.delete()`, `.patch()`

- `PATH` â†’ URL endpoint

- `HANDLER` â†’ `(req, res) => { ... }`

Example:

```js
app.post('/login', (req, res) => {
  res.send('Logged in!');
});
```

### Path Matching
Express matches paths in a **top-down order** (first match wins).

#### 1. Exact Match

```js
app.get('/contact', (req, res) => res.send('Contact Page'));
```

`/contact` will match exactly `/contact`.

#### 2. Pattern Match (Params)

```js
app.get('/user/:id', (req, res) => {
  res.send(`User ID: ${req.params.id}`);
});
```

- `:id` is a **route parameter**.

- Access via `req.params.id`.

#### 3. Optional Parameters

```js
app.get('/post/:id?', (req, res) => {
  res.send(req.params.id ? `Post ${req.params.id}` : 'All posts');
});
```

#### 4. Wildcard

```js
app.get('/files/*', (req, res) => res.send('Any path starting with /files/'));
```

### Handling Multiple Methods on the Same Path

```js
app.route('/book')
  .get((req, res) => res.send('Get a book'))
  .post((req, res) => res.send('Add a book'))
  .put((req, res) => res.send('Update the book'));
```

`app.route()` groups routes for the same path.

### Middleware in Routes
Middleware can run **before** the final route handler:

```js
const checkAuth = (req, res, next) => {
  if (req.query.token === '123') {
    next(); // pass to next handler
  } else {
    res.status(403).send('Forbidden');
  }
};

app.get('/secure', checkAuth, (req, res) => {
  res.send('You are authorized!');
});
```

- Middlewares can be global or route-specific.

- They can be stacked:
	
```js
app.get('/test', mw1, mw2, mw3, finalHandler);
```

### Router Objects (Modular Routing)
When your app grows, you use `express.Router()` to modularize routes.

`routes/userRoutes.js`:

```js
const express = require('express');
const router = express.Router();

router.get('/', (req, res) => res.send('All Users'));
router.get('/:id', (req, res) => res.send(`User ID: ${req.params.id}`));

module.exports = router;
```

`app.js`:

```js
const userRoutes = require('./routes/userRoutes');
app.use('/users', userRoutes);
```

- Request to `/users` â†’ handled by router.

### 7. Order Matters

```js
app.get('/users/new', (req, res) => res.send('New User'));
app.get('/users/:id', (req, res) => res.send(`User ID: ${req.params.id}`));
```

If `/users/:id` is above `/users/new`, then `/users/new` will be treated as an ID. Always put **more specific routes first**.

### Advanced Path Patterns
Express uses [path-to-regexp](https://www.npmjs.com/package/path-to-regexp) under the hood.

Examples:

```js
app.get('/ab?cd', ...);     // 'acd' or 'abcd'
app.get('/ab+cd', ...);     // 'abcd', 'abbcd', etc.
app.get('/ab*cd', ...);     // 'abcd', 'abRANDOMcd'
app.get(/.*fly$/, ...);     // Regex match: ends with 'fly'
```

### Chaining Middlewares and Routes
You can handle complex flows:

```js
app.get(
  '/data',
  (req, res, next) => { console.log('Step 1'); next(); },
  (req, res, next) => { console.log('Step 2'); next(); },
  (req, res) => { res.send('Done'); }
);
```

### Best Practices

- **Keep routes modular** using `express.Router`.

- **Validate inputs** inside routes or middleware.

- **Order routes carefully** to avoid unexpected matches.

- Use **RESTful conventions** (`GET /users`, `POST /users`, etc.).

- Avoid putting **business logic in routes**; delegate to controller functions.

---

### Path Parameter

#### ğŸ”¶ What is a Path Parameter?
A **path parameter** is a variable part of the URL path that Express can capture and use in your route handler.  
Itâ€™s **declared with a colon (`:`)** in the route definition.

Example:

```js
app.get('/users/:id', (req, res) => {
  res.send(`User ID is ${req.params.id}`);
});
```

- If client calls `/users/42` â†’ `req.params.id` is `"42"`.

#### ğŸ”¶ Multiple Path Parameters
You can define more than one:

```js
app.get('/users/:userId/books/:bookId', (req, res) => {
  const { userId, bookId } = req.params;
  res.send(`User ${userId} - Book ${bookId}`);
});
```

- `/users/7/books/100` â†’ `userId: "7"`, `bookId: "100"`

#### ğŸ”¶ Optional Path Parameters
Add `?` to make a parameter optional:

```js
app.get('/posts/:postId?', (req, res) => {
  res.send(req.params.postId 
    ? `Post ${req.params.postId}` 
    : 'All posts');
});
```

- `/posts` â†’ shows all posts

- `/posts/10` â†’ shows post `10`

#### ğŸ”¶ Combining with Static Segments
Static and dynamic parts can mix:

```js
app.get('/category/:name/item/:id', (req, res) => {
  res.send(`Category: ${req.params.name}, Item: ${req.params.id}`);
});
```

#### ğŸ”¶ Constraints with Regex
You can use regex in parameters to control what matches:

```js
app.get('/product/:id([0-9]+)', (req, res) => {
  res.send(`Product ID: ${req.params.id}`);
});
```

- Matches only numeric IDs.

- `/product/123` â†’ works

- `/product/abc` â†’ 404

#### ğŸ”¶ Wildcards vs Path Parameters

- `:param` â†’ captures one **segment** between `/`.

- `*` â†’ captures **everything** after.  
	
    Example:
	
```js
app.get('/files/:filename', ...); // `/files/test.txt`
app.get('/files/*', ...); // `/files/docs/images/pic.png`
```

#### ğŸ”¶ Accessing Path Params
All captured params are in `req.params` as an **object**:

```js
console.log(req.params);
// { id: '42', category: 'books' }
```

#### ğŸ”¶ Best Practices

- Use **meaningful names** for params (`:userId` > `:id`).

- Validate parameter data (type, range, existence).

- Avoid too many path params in one route (hard to read).

- Keep **more specific routes above generic parameter routes**.

---

### Query Strings

#### ğŸ”· What Is a Query String?
A **query string** is the part of a URL that comes **after the `?`** and provides extra data in `key=value` format.  
Theyâ€™re not part of the path; theyâ€™re extra parameters.

Example URL:

```
/search?term=javascript&sort=asc
```

- `term` â†’ `"javascript"`

- `sort` â†’ `"asc"`

#### ğŸ”· Structure of a Query String

```
?key1=value1&key2=value2&key3=value3
```

- Starts with `?`

- Multiple pairs separated by `&`

- Keys and values are usually URL-encoded

#### ğŸ”· Accessing Query Strings in Express
Express parses query strings automatically and puts them in `req.query`.

Example:

```js
app.get('/search', (req, res) => {
  console.log(req.query);
  res.send(`Search term: ${req.query.term}, Sort: ${req.query.sort}`);
});
```

If you call:

```
/search?term=javascript&sort=asc
```

You get:

```js
req.query // { term: 'javascript', sort: 'asc' }
```

#### ğŸ”· When to Use Query Strings

- **Filtering**: `/products?category=books`

- **Sorting**: `/products?sort=price&order=desc`

- **Pagination**: `/users?page=2&limit=20`

- **Search**: `/search?term=express`

#### ğŸ”· Difference Between Path Params and Query Strings

|Path Parameter|Query String|
|---|---|
|Part of the route path|After `?` in the URL|
|`/users/42`|`/users?id=42`|
|Access via `req.params`|Access via `req.query`|
|Good for **required** data|Good for **optional** or filter data|

#### ğŸ”· Handling Missing or Multiple Query Parameters

```js
app.get('/filter', (req, res) => {
  const { category = 'all', sort = 'asc' } = req.query;
  res.send(`Category: ${category}, Sort: ${sort}`);
});
```

- Default values handle missing query strings.

Multiple values for same key:

```
/items?color=red&color=blue
```

```js
req.query // { color: ['red', 'blue'] }
```

#### ğŸ”· Best Practices

- Use **query strings for filtering, sorting, and pagination**, not for essential IDs.

- Always **validate and sanitize** values (avoid injection attacks).

- Keep them short and meaningful; avoid sending sensitive data via query strings (theyâ€™re logged in URLs).

---

## Template using ejs

### What is Templates?
In **Express.js**, _templates_ refer to **template engines** â€” systems that let you build dynamic HTML pages by embedding JavaScript (or other logic) into a markup structure.

Instead of manually concatenating strings for HTML (which gets messy fast), you use a template engine to:

- Define an **HTML skeleton** (layout).

- Inject **dynamic data** (variables from your route/controller).

- Optionally use loops, conditionals, and partials for reusable code.

#### Why use templates in Express

- **Cleaner code** â€” HTML stays in `.ejs`, `.pug`, etc., not cluttered in JS strings.

- **Reusability** â€” layouts, partials, components.

- **Separation of concerns** â€” business logic in routes/controllers, presentation in templates.

- **Flexibility** â€” easy to swap template engines.

---

### What is ejs?
**EJS** stands for **Embedded JavaScript**.  
Itâ€™s a **template engine** for Node.js (often used with Express.js) that lets you write HTML with embedded JavaScript code to dynamically generate content before sending it to the browser.

#### Core idea

With EJS, you write an HTML file but sprinkle it with special tags to insert variables, run loops, or add conditionals.  
EJS processes the file on the server, replaces those tags with actual data, and sends the final HTML to the client.


#### âœ… Why people use EJS

- **Familiar syntax** â€” looks like normal HTML + JS.

- **Flexible** â€” can include partials and layouts.

- **Lightweight** â€” minimal overhead.

- **No build step** â€” runs directly in Node.

---

## [ejs Tutorial](https://ejs.co/#docs)

### 1. Installing ejs

```bash
npm install ejs
```

### 2. Acquiring ejs

- **ejs is automatically acquired by express**. But, if we have to acquire it manually 
	with any thing else then
	
```js
const ejs = require("ejs");
```

- We have to make ejs our preferred view engine.

```js
app.set("view engine", "ejs");
```

#### .set() method
In **Express.js**, the `.set()` method is used to **set application-level settings** or **set HTTP response headers**, depending on where itâ€™s called.

It has **two main contexts**:

##### 1. App-level configuration

When called on the `app` object, it sets or retrieves app-level settings.

```js
const express = require('express');
const app = express();

// Set a setting
app.set('view engine', 'ejs');
app.set('port', 3000);

// Get a setting
console.log(app.get('port')); // 3000
```

Common settings you might use:

- `'view engine'` â†’ set the template engine.

- `'views'` â†’ set the views directory.

- `'case sensitive routing'` â†’ enable case sensitivity for routes.

- `'strict routing'` â†’ distinguish `/route` and `/route/`.

##### 2. Response headers

When called on the `res` (response) object, it sets HTTP headers for the response.

```js
app.get('/', (req, res) => {
  res.set('Content-Type', 'text/plain');
  res.set({
    'X-Powered-By': 'Sankho Engine',
    'Cache-Control': 'no-store'
  });
  res.send('Hello World');
});
```

**Notes:**

- Alias: `res.header()` does the same as `res.set()`.

- You can set multiple headers at once by passing an object.

### 3. Creating .ejs file

- By default, express tries to find the views directory & inside that the file name. You can change it, however you should use views folder instead.

- **Rectify the path** - If you open the server from another location, like parent 
	directory then by default express tries to find the views directory in that parent one.
	
```js
const path = require("path");

app.set("views", path.join(__dirname, "views"));
```

#### Path package
The **`path` package** isnâ€™t actually part of Express â€” itâ€™s a **built-in Node.js core module** that Express developers often use to handle file and directory paths reliably across operating systems.

##### ğŸ”¶ Why you need `path` in Express.js

- File paths differ between operating systems (`/` vs `\`).

- Prevents path errors when serving static files, templates, or downloads.

- Helps avoid security issues by resolving paths properly.

##### ğŸ”¶ Common `path` methods youâ€™ll see in Express

```js
const path = require('path');

// Joins path segments into one normalized path
path.join(__dirname, 'public', 'images', 'logo.png');
// â†’ "/Users/sankho/project/public/images/logo.png" (Mac/Linux)
// â†’ "C:\Users\Sankho\project\public\images\logo.png" (Windows)

// Resolves absolute path from segments
path.resolve('public', 'images');
// â†’ "/absolute/path/to/public/images"

// Gets the directory name
path.dirname('/foo/bar/baz.txt'); // â†’ "/foo/bar"

// Gets the base file name
path.basename('/foo/bar/baz.txt'); // â†’ "baz.txt"

// Gets the file extension
path.extname('index.html'); // â†’ ".html"
```

##### ğŸ”¶ Pro tip
In **Express**, `path` is most often used when:

- Setting the `views` folder location

- Serving static files

- Building file download paths

- Avoiding â€œpath traversalâ€ bugs


- Create a views directory inside the project directory & inside that create the first 
	.ejs file.
	
```bash
mkdir views && touch home.ejs
```

### 4. Rule-book of .ejs file writing

##### 1. File Extension & Location

- Must be saved with `.ejs` extension.

- Typically stored in the `/views` folder.

- Can be organized into subfolders (`/views/pages`, `/views/partials`, etc.).

##### 2. Syntax Rules
EJS uses **special tags** for mixing JavaScript into HTML:

|Tag Type|Syntax|Purpose|
|---|---|---|
|Output (escaped)|`<%= value %>`|Prints variable value with HTML escaping (safe for user input).|
|Output (unescaped)|`<%- value %>`|Prints raw HTML without escaping (use carefully to avoid XSS).|
|Logic block|`<% code %>`|Runs JS code without printing.|
|Comment|`<%# comment %>`|Comment inside template, not rendered.|
|Include partial|`<%- include('file') %>`|Includes another EJS file.|

##### 3. JavaScript in Templates

You can use:

- Loops:
	
```ejs
<% items.forEach(item => { %>
    <li><%= item %></li>
<% }) %>
```

- Conditionals:
	
```ejs
<% if (user) { %>
    <h1>Welcome <%= user.name %></h1>
<% } else { %>
    <h1>Please log in</h1>
<% } %>
```

==**Disclaimer:** Keep **logic minimal** â€” EJS is for rendering, not business logic. Heavy logic should stay in your Node.js code, pass the processed data to EJS.==

##### 4. Including Other Templates
Use partials to avoid repeating HTML:

```ejs
<%- include('includes/header') %>
<main>
  <h1><%= title %></h1>
</main>
<%- include('includes/footer') %>
```

If your partial is in `/views/includes/header.ejs`, the path is relative to `/views`.

##### 5. Variable Passing
Only variables passed from the server via `res.render()` are available:

```js
res.render('index', { name: 'Sankho' });
```

In `index.ejs`:

```ejs
<h1>Hello <%= name %></h1>
```

##### 6. Escaping & Security

- Use `<%= %>` for any user-generated content to prevent **XSS attacks**.

- Only use `<%- %>` for **trusted HTML**.

##### 7. Formatting & Cleanliness

- Indent consistently (2 or 4 spaces).

- Separate logic tags from HTML visually:
    
```ejs
<% items.forEach(item => { %>
    <p><%= item %></p>
<% }) %>
```

- Avoid inline CSS/JS â€” link static files from `/public`.

##### 8. No Closing Slash for Logic Tags
EJS tags do not self-close â€” you must explicitly open and close them.

Correct:

```ejs
<% if (true) { %>
  Hello
<% } %>
```

Wrong:

```ejs
<% if (true) /%>  <!-- âŒ -->
```

---

### 5. Embedding CSS & JavaScript with .ejs file

- EJS is still HTML at the end of the day. You donâ€™t hardcode CSS and JS into it
	unless you must. Instead, store them in `/public` and link them.
	
```bash
mkdir public && touch style.css app.js
```

- **Configuring Express** - You have to tell express explicitly that inside public 
	directory it can find the static (.css & .js files) files.
	
```js
app.use(express.static("public"));
//This line tells express that in the public directory it can find the necessary files

app.use(express.static(path.join(__dirname,"/public")));
// It has the same problem as the views folder so, we have to explicitly correct the path.

app.use(express.static(path.join(__dirname, "/public/CSS")));
app.use(express.static(path.join(__dirname, "/public/JS")));
//In this way we can set the sub directory path.
```

- Add the file name in .ejs file
	
```ejs
<!DOCTYPE html>
<html>
<head>
    <title>My EJS Page</title>
    <!-- Link CSS -->
    <link rel="stylesheet" href="/CSS/style.css">
</head>
<body>
    <h1>Hello <%= name %>!</h1>
	
    <!-- Link JS -->
    <script src="/JS/app.js"></script>
</body>
</html>
```

### 6. Rendering the .ejs file

#### 1. Basic Rendering Flow

1. Client requests a route (`GET /`).

2. Express uses `res.render()` to:
    
    - Load the `.ejs` file from the `views` directory.
    
    - Insert any variables into placeholders.
    
    - Output a complete HTML page.

#### 2. Minimal Setup

**Folder structure:**

```
project/
â”œâ”€â”€ views/
â”‚   â”‚
â”‚   â”œâ”€â”€ home.ejs
â”‚   â”‚
â”‚   â””â”€â”€ includes/
â”‚       â”‚
â”‚       â”œâ”€â”€ header.ejs
â”‚       â”‚
â”‚       â””â”€â”€ footer.ejs
â”‚
â”œâ”€â”€ public/
â”‚   â”‚
â”‚   â”œâ”€â”€ CSS/
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ style.css
â”‚   â”‚
â”‚   â””â”€â”€ JS/
â”‚       â”‚
â”‚       â””â”€â”€ app.js
â”‚
â”œâ”€â”€ index.js
â”‚
â””â”€â”€ package.json
```

#### 3. .render() Method
##### 1. What `.render()` Does

`res.render(view, [locals], [callback])`

- **view** â†’ The name of the template file (without extension) in your `views` directory.

- **locals** â†’ An object containing variables you want available inside the template.

- **callback** _(optional)_ â†’ A function to run after rendering (rarely used for normal pages).

In short:  
It **compiles** your EJS file into HTML, inserts the variables, and **sends** the HTML to the client.

##### 2. Syntax

```js
res.render('templateName', { key1: value1, key2: value2 });
```

Example:

```js
res.render('index', { name: 'Sankho', age: 21 });
```

Inside `views/index.ejs`:

```ejs
<h1>Hello <%= name %>, you are <%= age %> years old!</h1>
```

##### 3. Rendering Rules

- **File location** â†’ `.render()` looks inside the folder set by:
	
```js
app.set('views', path.join(__dirname, 'views'));
```

- **File extension** â†’ If youâ€™ve set:
    
```js
app.set('view engine', 'ejs');
```
	
	you donâ€™t write `.ejs` in `.render()`:
	
```js
res.render('index'); // âœ…
res.render('index.ejs'); // âŒ unnecessary
```

- **Data passing** â†’ Only variables in the second argument are available in EJS.

- **Security** â†’ Always use `<%= %>` in EJS to escape user input and avoid XSS.

##### 4. Using `.render()` with a Callback

```js
res.render('index', { name: 'Sankho' }, (err, html) => {
    if (err) {
        console.error('Rendering error:', err);
    } else {
        console.log('Rendered HTML length:', html.length);
    }
});
```

This does **not** send the HTML to the browser â€” you handle the HTML manually here.  
Normally, you just call `.render()` without a callback.

##### 5. Common Mistakes

- Forgetting `app.set('view engine', 'ejs')` â†’ Express wonâ€™t know to use EJS.

- Using `res.send()` instead of `res.render()` when you want template processing.

- Passing data in the wrong format (`res.render('index', "string")` âŒ â€” must be an object).

#### 4. How Rendering Works

- The `{ name: 'Sankho', skills: [...] }` object is passed into `home.ejs`.

- Inside `home.ejs`:
    
    - `<%= name %>` â†’ replaces with `"Sankho"`.
    
    - `<% skills.forEach(...) %>` â†’ runs JavaScript logic to loop through the skills.

- The final HTML is sent to the browser.

#### 5. Key Points

- **`res.render('filename')`** looks for `filename.ejs` inside the `views` folder by default.

- You **do not** write `.ejs` in `res.render()` unless you changed the extension manually.

- You **must** pass data as an object:
	
```js
res.render('index', { key: value });
```

- Anything not passed will be `undefined` in the EJS file.

---

## GET & POST Request

### GET request
A **GET request** is the most common type of HTTP request in JavaScript.  
Hereâ€™s exactly what it means and how it works:

#### #ï¸âƒ£ Definition

A **GET request** asks the server to **send data back** without changing anything on the server.  
Itâ€™s like saying:

> â€œHey server, show me the data for this resource.â€

#### ğŸ”‘ Key Characteristics

1. **Read-only** â€“ Should not change the serverâ€™s data.

2. **Data in URL** â€“ Parameters are sent as part of the query string:
	
```
https://example.com/api/users?limit=10
```

3. **Cached by browsers** â€“ Faster on repeat requests, but can serve old data.

4. **Bookmarkable** â€“ You can save the exact request in your browserâ€™s history.

5. **Limited size** â€“ Usually around 2 KB in the URL.

#### â³ When to Use

- Fetching public data (news, weather, products).

- Searching or filtering results.

- Loading resources like images, CSS, JavaScript files.

#### ğŸ“ƒ Real-World Example

- **You type a URL in your browser** â†’ Browser makes a GET request.

- **You click a link** â†’ Another GET request is sent.

- **You use Google Search** â†’ Your search terms are in the URL as `?q=keyword`.

---

### Difference between GET & POST requests
In JavaScript (or rather, in HTTP), the difference between a **GET** request and a **POST** request comes down to:

#### 1. Purpose

- **GET** â€“ Used to **retrieve** data from a server. It should have no side effects on the serverâ€™s data.

- **POST** â€“ Used to **send** data to the server, typically to create or update something.

#### 2. Data Transmission

- **GET** â€“ Sends data in the **URL query string** (`?key=value`). Example:
	
```
GET /search?query=javascript
```
    
> 	Data is **visible in the URL** and part of the request line.

- **POST** â€“ Sends data in the **request body**, not in the URL.
    
```
POST /api/users
Body: { "name": "John" }
```
	
> 	Data is hidden from the URL.

#### 3. Size Limits

- **GET** â€“ Limited by URL length restrictions (around 2,000 characters in many browsers).

- **POST** â€“ Can send much larger amounts of data (file uploads, JSON, form data, etc.).

#### 4. Caching & Bookmarking

- **GET** â€“ Can be **cached** by browsers, stored in history, and bookmarked.

- **POST** â€“ Not cached or bookmarked (by default).

#### 5. Idempotency

- **GET** â€“ Should be **idempotent** (multiple identical requests have the same effect).

- **POST** â€“ Not necessarily idempotent (multiple identical POSTs could create duplicates).

#### ğŸ’¨ Quick rule:

- **GET** â†’ â€œGive me something.â€ (read-only)

- **POST** â†’ â€œIâ€™m sending you something.â€ (changes server state)

---

### POST request
In **Express.js**, a **POST request** is one of the HTTP request methods used to send data from the client to the server â€” usually for creating or updating resources.

Itâ€™s commonly used when:

- Submitting a form (login, registration, feedback, etc.)

- Uploading files

- Sending JSON data from a frontend app to a backend API

#### How to use POST request in Express.js?

##### 1. Acquire the data:
First we have to set up the route for listening POST request.

```js
app.post("/submit",(req,res)=>{
	// Here you can access the incoming data.
});
```

##### 2. Parsing Data

- By default, express don't set the data type of the incoming data. You have to manually 
	Specify it to be able to read the form data.
	
```js
app.use(express.urlencoded({ extended: true}));
```

- If you want to parse JSON type data also then,

```js
app.use(express.json());
```

##### 3. Using the Data

- Unlike GET, POST does not append data to the URL.

- The data is sent in the **HTTP request body**.

- Itâ€™s more secure for sensitive information (but still requires HTTPS for true security).

```js
app.post("/submit",(req,res)=>{
	let { username, emailId } = req.body; // Object destructuring.
});
```

---

## [Restful API implementation](https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/)

### Rest
In **Express.js**, â€œRESTâ€ isnâ€™t a feature of Express itself â€” itâ€™s a **design style** for building web APIs, and Express is simply a tool that makes implementing that style easier.  
Letâ€™s break this down in detail:

#### 1. What REST Means
**REST** stands for **Representational State Transfer**.  
Itâ€™s an **architectural style** for designing networked applications, especially APIs, with these principles:

- **Statelessness**: Each client request contains all the data the server needs to process it. No server-side session state is required.

- **Client-Server separation**: The client and server are independent â€” one can change without breaking the other as long as the API contract stays the same.

- **Uniform Interface**: Resources are accessed and manipulated in a standardized way (mainly through HTTP methods).

- **Resource-Based URLs**: Everything in the system is considered a â€œresource,â€ identified by a unique URL.

- **Representation**: Resources can be represented in various formats (JSON, XML, HTML, etc.) â€” JSON is the most common in modern REST APIs.

- **Cacheability**: Responses can be cached to improve performance.

#### 2. How It Relates to Express.js
Express.js is a **Node.js web framework** that makes it easy to build RESTful APIs by handling HTTP requests and routing.

You **map HTTP methods** to actions on your resources:

|HTTP Method|Purpose|Example URL|Action Description|
|---|---|---|---|
|**GET**|Read data|`/users`|Get all users|
|**GET**|Read one|`/users/:id`|Get a single user|
|**POST**|Create new|`/users`|Add a user|
|**PUT**|Replace/update|`/users/:id`|Replace a user|
|**PATCH**|Partially update|`/users/:id`|Update part of a user|
|**DELETE**|Remove|`/users/:id`|Delete a user|

#### 3. REST in Express.js â€“ Example
Hereâ€™s a simple **RESTful API** for a `users` resource:

```js
const express = require("express");
const path = require("path");
const { v4: uuidv4 } = require("uuid");
const methodOverride = require("method-override");

const port = 8080;
const app = express();

app.set("view engine", "ejs");
app.set("views", path.join(__dirname, "views"));
app.use(express.static(path.join(__dirname, "public/CSS")));
app.use(express.static(path.join(__dirname, "public/JS")));

app.use(express.urlencoded({ extended: true }));
app.use(express.json());
app.use(methodOverride("_method"));

function getPost(req) {
    let { id } = req.params;
    return { id: id, post: posts.find((p) => id === p.id) };
}

// I don't know DB yet. So, this array will do fine for now.
let posts = [
    {
        id: uuidv4(),
        username: "Sankhadeep_Pal",
        heading: "My First experience with VIM",
        content:
            "Hello everyone, I recently started learning VIM motion & I am 			feeling my self very fast now.",
        like: 0,
        comment: [],
    },
    {
        id: uuidv4(),
        username: "Rohit_Roy",
        heading: "My first day at college",
        content:
            "My first day in college is not so, good for me. I gat bullied 			:(",
        like: 0,
        comment: [],
    },
    {
        id: uuidv4(),
        username: "Subham_Ghosh",
        heading: "Today is my birthday",
        content:
            "Hello, My name is Subham, today is my 23rd birth day. And 				guess what I got my joining letter this morning :)",
        like: 0,
        comment: [],
    },
];

app.listen(port, () => {
    console.log(`A incoming request at port: ${port}`);
});

app.get("/", (req, res) => {
    res.send("Everything is working well so far!");
});

// Index Route
app.get("/posts", (req, res) => {
    res.render("index", { posts });
});

// Adding new post
app.get("/posts/new", (req, res) => {
    res.render("new");
});
app.post("/posts", (req, res) => {
    posts.push({ id: uuidv4(), ...req.body, like: 0, comment: [] });
	
    // Connecting the home page.
    res.redirect("/posts");
});

// Developing detail post view using UUID
app.get("/posts/:id", (req, res) => {
    let { id, post } = getPost(req);
	
    if (post) {
        res.render("view", { post });
    } else {
        res.status(404).send("Page not found!");
    }
});

// Now it's time to implement edit feature
// Learning patch verb
app.patch("/posts/:id", (req, res) => {
    let { heading, content } = req.body;
    let { id, post } = getPost(req);
	
    post.content = content;
    post.heading = heading;
	
    res.redirect("/posts");
});

// Now we have to edit this route with GUI for normal user
app.get("/posts/:id/edit", (req, res) => {
    let { id, post } = getPost(req);
    res.render("edit", { post });
});

// Explanation:
/*
(*) We created a patch request, there we create a same references particular info copy 'post' which is easy to manipulate. Then we add the modified data to there respective places.
(*) Now the problem was how a normal use can possibly change the data? So, we created another edit button that redirect us to a form there if user modified the data then, we can add it.
(*) The big issue is that html form don't allow use directly to make Patch, Put & Delete request... So, we used a package call method-override.
(*) syntax:
    1. npm install method-override
    2. const methodOverride = require('method-override')
    3. app.use(methodOverride('_method'));
    (*) in this we can handle any verb through url query strings in form's 
    	action we have to write:
        action="/<the_resources>?_method=PATCH"
*/

// Deleting post feature.
app.delete("/posts/:id/delete", (req, res) => {
    let { id, post } = getPost(req);
    let postIndex = posts.findIndex((p) => id === p.id);
    posts.splice(postIndex, 1);
    res.redirect("/posts");
});

// Home Task
//likes
app.post("/posts/:id", (req, res) => {
    let { id, post } = getPost(req);
	
    post.like++;
    posts.sort((a, b) => a.like - b.like);
    res.redirect("/posts");
});

// comment
app.patch("/posts/:id/comment", (req, res) => {
    let { username, comment } = req.body;
    let { id, post } = getPost(req);
	
    post.comment.push({ username: username, comment: comment });
    res.render("view", { post });
});
```

#### 4. Why REST is Important in Express.js

- **Clarity**: A REST API has predictable behavior for developers.

- **Scalability**: Stateless nature makes it easy to scale horizontally.

- **Interoperability**: Any client (web, mobile, IoT) can use it as long as it speaks HTTP.

- **Maintainability**: Clear separation of resources and actions makes it easier to extend.

#### 5. REST vs. REST in Express.js

- REST is **conceptual** â€” rules and best practices.

- Express.js **implements** REST endpoints by mapping HTTP methods to routes and handlers.

---

### CRUD Operation in Express
**CRUD** stands for **Create Read Update Delete**. It's a database related term.
You can perform CRUD operation with Restful API to enhance predictability.

<table>
  <tr>
    <th align="center">Index</th>
    <th align="center">Operation</th>
    <th align="center">HTTP Verbs</th>
    <th align="center">Usage</th>
  </tr>
  <tr>
    <td align="center">1</td>
    <td align="center">Create</td>
    <td align="center">POST</td>
    <td align="center">Create new data in the server.</td>
  </tr>
  <tr>
    <td align="center">2</td>
    <td align="center">Read</td>
    <td align="center">GET</td>
    <td align="center">Request for some data to read from the server.</td>
  </tr>
  <tr>
    <td rowspan="2" align="center" style="vertical-align: middle;">3</td>
    <td rowspan="2" align="center" style="vertical-align: middle;">Update</td>
    <td align="center">PUT</td>
    <td align="center">Fully replacing new data with existing data.</td>
  </tr>
  <tr>
    <td align="center">PATCH</td>
    <td align="center">Partially replacing new info in existing data.</td>
  </tr>
  <tr>
    <td align="center">4</td>
    <td align="center">Delete</td>
    <td align="center">DELETE</td>
    <td align="center">Delete some data from server.</td>
  </tr>
</table>

---

### Resource
In RESTful API design, a **resource** is any identifiable piece of data or functionality that the API exposes and manages.

Think of a resource as **"the thing"** your API is about â€” for example:

- In a bookstore API: `Book`, `Author`, `Order`

- In a social media API: `User`, `Post`, `Comment`

- In a file storage API: `File`, `Folder`, `Permission`

Key points about resources in REST:

1. **Uniquely Identifiable** â€“ Each resource is identified by a **URI (Uniform Resource Identifier)**.
    
    - Example: `/books/123` refers to the book with ID `123`.

2. **Representations** â€“ The resource itself isnâ€™t the raw data stored in the server; instead,
	the API sends a **representation** of it (often JSON or XML).
    
    - Example: A `Book` resource might be represented as JSON:
        
```json
{ "id": 123, "title": "REST in Practice", "author": "Smith" }
```

3. **State & Actions** â€“ Resources have state (data) and can be manipulated through **HTTP methods**:
    
    - `GET /books/123` â†’ Retrieve
    
    - `POST /books` â†’ Create
    
    - `PUT /books/123` â†’ Replace/Update
    
    - `PATCH /books/123` â†’ Partial update
    
    - `DELETE /books/123` â†’ Remove

4. **Nouns, Not Verbs** â€“ In REST, you name resources as nouns (`/users`, `/orders`), not action-based verbs (`/getUsers`, `/createOrder`). The HTTP method determines the action.

If I put it simply:

> In REST, **a resource is the "what"**, the HTTP method is the "how".  
> URL points to _what_, method tells _what to do with it_.

If you want, I can also show you **a diagram of how resources, URLs, and HTTP methods fit together** so itâ€™s crystal clear. Would you like me to do that?

## [UUID Package](https://www.npmjs.com/package/uuid)
The `uuid` package in npm is the most widely used library for generating Universally Unique Identifiers (UUIDs) in Node.js and browser environments. Itâ€™s maintained actively and follows the official RFC 4122 UUID specification.

Hereâ€™s the breakdown:

### ğŸ”¶ What it does

- Generates unique identifiers that are extremely unlikely to collide, even across distributed systems.

- Commonly used for database keys, session IDs, transaction tracking, etc.

### ğŸ”¶ Versions of UUIDs it supports
The package supports multiple RFC-defined versions:

- **v1** â†’ Time-based (includes timestamp + MAC address)

- **v3** â†’ Name-based, MD5 hash

- **v4** â†’ Random (most common)

- **v5** â†’ Name-based, SHA-1 hash

- **v6** and others â†’ Newer time-ordered variants (not always needed)

**Example:**

```javascript
import { v4 as uuidv4 } from 'uuid';

const id = uuidv4();
console.log(id); // Example: 'f64f2940-c7aa-4e6d-bb58-45c4b8b69a9c'
```

### ğŸ”¶ Installation

```bash
npm install uuid
```

### ğŸ”¶ Usage examples

```javascript
import { v1 as uuidv1, v3 as uuidv3, v4 as uuidv4, v5 as uuidv5 } from 'uuid';

// v1: Time-based
console.log(uuidv1());

// v4: Random
console.log(uuidv4());

// v3/v5: Name-based
const MY_NAMESPACE = uuidv4();
console.log(uuidv3('hello.example.com', MY_NAMESPACE));
console.log(uuidv5('hello.example.com', MY_NAMESPACE));
```

### ğŸ”¶ Why not just use random numbers?

- UUID v4 gives you **122 random bits** â€” probability of collision is astronomically low.

- Works well across multiple servers without coordination.

- Standardized and easily recognizable format.

### ğŸ”¶ Extra notes

- By default, `uuid` returns a **string** in canonical form: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`.

- If you need **binary (Buffer) format**, the library supports that too.

- Since v 8. X, itâ€™s ESM-first â€” you can still use CommonJS, but syntax differs slightly.

---

## [Method-override Package](https://www.npmjs.com/package/method-override)
The `method-override` package in npm is a small middleware for **Express** (or other Connect-style frameworks) that lets you use **HTTP verbs like PUT, PATCH, and DELETE** in environments that only support GET and POST â€” for example, HTML forms.

### ğŸ”· Why it exists

- HTML `<form>` elements can only submit GET or POST requests.

- RESTful APIs often require other methods: PUT (update), DELETE (remove), PATCH (partial update).

- `method-override` works around this by letting you â€œoverrideâ€ the HTTP method based on:
    
    - A query parameter
    
    - A hidden form field
    
    - A custom HTTP header

### ğŸ”· Installation

```bash
npm install method-override
```

### ğŸ”· Basic usage

```javascript
const express = require("express");
const methodOverrideÂ =Â require('method-override')
const app = express();

// Look for a "_method" field in POST requests and use its value as the HTTP method
app.use(methodOverride('_method'));

app.post('/resource', (req, res) => {
  res.send('POST request');
});

app.put('/resource', (req, res) => {
  res.send('PUT request');
});
```

### ğŸ”· Example with HTML form

```html
<form action="/resource?_method=PUT" method="POST">
  <input type="submit" value="Update">
</form>
```

or:

```html
<form action="/resource" method="POST">
  <input type="hidden" name="_method" value="DELETE">
  <input type="submit" value="Delete">
</form>
```

The server receives a **POST**, but `method-override` changes it to a **PUT** or **DELETE** before it reaches your route handlers.

### ğŸ”· Other override options

- Using a **custom header**:
    
```javascript
app.use(methodOverride('X-HTTP-Method-Override'));
```
	
    Then send a POST request with:
	
```
X-HTTP-Method-Override: DELETE
```

- Using a **custom function**:
    
```javascript
app.use(methodOverride((req, res) => {
    if (req.body && typeof req.body === 'object' && '_method' in req.body) {
        const method = req.body._method;
        delete req.body._method;
        return method;
    }
}));
```

### ğŸ”· When you should use it

- Youâ€™re building REST routes but serving HTML forms (common in server-rendered apps like with EJS or Pug).

- You need compatibility for old clients that canâ€™t send PUT/DELETE directly.

---

## Middlewares in Express

### What is Middleware?
In Express.js, **middleware** refers to functions that sit between the incoming HTTP request and the final response. When a request hits your server, Express doesnâ€™t immediately decide how to respond. Instead, it passes the request through a chain of middleware functions. Each function can:

- Inspect or modify the request (`req`).

- Inspect or modify the response (`res`).

- Decide to send a response back immediately.

- Or pass control to the **next middleware** using the `next()` function.

Think of middleware like **checkpoints** or **filters** in a pipeline: every request must pass through them before reaching its destination.

### Why Middleware Matters
Express.js is intentionally minimal. Middleware gives it **flexibility and power** by allowing you to add functionality layer by layer. With middleware, you can:

- Log requests for debugging.

- Parse request bodies (JSON, form data, etc.).

- Authenticate users.

- Serve static files.

- Handle errors gracefully.

- Restrict access to certain routes.  
    Without middleware, you would need to manually repeat these tasks for every route, making your app messy and hard to maintain.

### How Middleware Works
The request life-cycle in Express follows this pattern:

1. **Client sends a request** â†’ `/users`

2. Express runs through each middleware in the order they are defined.

3. For each middleware:
    
    - If it sends a response, the cycle ends.
    
    - If it calls `next()`, the request moves to the next middleware.
    
4. If no middleware handles the request, Express will return a `404 Not Found`.

Example:

```js
app.use((req, res, next) => {
  console.log("Middleware 1");
  next(); // pass control
});

app.use((req, res, next) => {
  console.log("Middleware 2");
  res.send("Response from Middleware 2"); // ends cycle
});
```

When a request arrives, the console shows:

```
Middleware 1
Middleware 2
```

Then the client gets the response. Notice: once `res.send()` is called, the cycle ends â€” `next()` wonâ€™t run anymore.

### Types of Middleware

#### a) Application-Level Middleware

- Applied directly to the Express `app` object.

- Runs for every request (unless filtered by path).

- Example:
	
```js
app.use((req, res, next) => {
	console.log(`${req.method} ${req.url}`);
    next();
});
```

This logs the method and URL for every request.

#### b) Router-Level Middleware

- Works like application middleware but is tied to a **router instance**.

- Helps modularize code by applying middleware only to certain route groups.

- Example:
	
```js
const router = express.Router();

router.use((req, res, next) => {
    console.log("Router-specific middleware");
    next();
});

router.get('/profile', (req, res) => {
    res.send('User Profile');
});

app.use('/user', router);
```

Here, the middleware will only trigger for routes starting with `/user`.

#### c) Built-in Middleware
Express provides some middleware out of the box:

- `express.json()` â†’ Parses incoming JSON payloads.

- `express.urlencoded({ extended: true })` â†’ Parses URL-encoded form data.

- `express.static("folderName")` â†’ Serves static files like images, CSS, and JS.

Example:

```js
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static("public"));
```

#### d) Third-Party Middleware
Installed via npm. Popular ones include:

- **`morgan`** â†’ Logs request details (method, path, status, response time).

- **`cors`** â†’ Enables cross-origin requests (important for APIs).

- **`helmet`** â†’ Secures apps by setting HTTP headers.

- **`cookie-parser`** â†’ Parses cookies attached to client requests.

Example:

```js
const morgan = require("morgan");
app.use(morgan("dev"));
```

#### e) Error-Handling Middleware

Special middleware with **four parameters**: `(err, req, res, next)`.

- Only called when `next(err)` is triggered or when an error is thrown inside another middleware.

- Example:
	
```js
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).send("Something went wrong!");
});
```

### Execution Order
Middleware functions are executed **in the order they are defined**. This makes order very important:

- Place `body-parsers` (e.g., `express.json()`) before routes, so route handlers can use `req.body`.

- Place **authentication middleware** before protected routes.

- Place **error-handling middleware at the very end**.

Example of order:

```js
app.use(express.json());  // parses JSON

app.use(authMiddleware);  // checks authentication

app.get('/dashboard', (req, res) => {
  res.send("Welcome to Dashboard");
});

app.use(errorHandler);    // catches errors
```

### Real-World Use Cases

1. **Authentication**
	
```js
function authMiddleware(req, res, next) {
    if (req.headers.authorization === "secret-token") {
        next();
    } else {
        res.status(401).send("Unauthorized");
    }
}
app.use(authMiddleware);
```

2. **Logging**
	
```js
app.use((req, res, next) => {
    console.log(`${req.method} request for ${req.url}`);
    next();
});
```

3. **Static File Hosting**
	
```js
app.use(express.static("public")); 
// Serves public/index.html at "/"
```

4. **Error Handling**
	
```js
app.use((err, req, res, next) => {
    res.status(500).json({ message: err.message });
});
```

### Example
```js
// Middlewares
const express = require("express");

const app = express();
const port = 8080;

app.listen(port, () => {
    console.log(`Listening at port: ${port}`);
});

// First middleware
/* app.use((req, res) => {
    let { query } = req.query;
    console.log(query);
    console.log("Hello, I am a middleware");
    res.send("Middleware finished!");
});

app.get("/", (req, res) => {
    res.send("I am root");
});
app.get("/random", (req, res) => {
    res.send("This a random path.");
}); */

/*
(*) Middlewares should be written at the top of the method functions.
(*) Middlewares can access req, res.
*/

// Next()
app.use("/next", (req, res, next) => {
    console.log("this is 1st middleware");
    next();
    console.log("This is after next()");
});
app.use("/next", (req, res, next) => {
    console.log("this is 2st middleware");
    return next();
});

app.get("/next", (req, res) => {
    res.send("I am /next");
});

/*
(*) If some middleware doesn't send any response then it has to use next to avoid error (loading screen)
(*) middleware function works in stack data structure and next() is the call for next middleware function.
(*) As a good developer we should not write code after next(), so, some devs prefer returning it.
*/

// Utility middleware
app.use("/util", (req, res, next) => {
    req.runtime = new Date(Date.now()).toString();
    console.log(req.method, req.hostname, req.path, req.runtime);
    return next();
});

app.get("/util", (req, res) => {
    res.send("It's a logger.");
});

// Activity
const tokenCheck = (req, res, next) => {
    let { token } = req.query;
    if (token === "gainAccess") {
        return next();
    } else {
        throw new Error("Access Denied!");
    }
};

app.get("/api", tokenCheck, (req, res) => {
    res.send("Data");
}); 
```

### Key Takeaways

- Middleware is **the backbone** of Express.js applications.

- They allow modular and reusable code.

- Always remember:
    
    1. Call `next()` unless you want to end the cycle.
    
    2. Order matters â€” the wrong order can break your app.
    
    3. Use error-handling middleware at the end.

---

