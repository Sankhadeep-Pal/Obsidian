# [C++ Tutorial](https://www.apnacollege.in/path-player?courseid=sigma-8-cpp-dsa&unit=68fa3b4287f7d968610ee9d6Unit)

## <mark style="background: #BBFABBA6;">Day 1 - Class notes</mark>
```c++
// Preprocessor directive
#include <iostream>
#define PIE 3.14
#include <iomanip> // used to maximize the precision of storing decimal values.
// Work: Include some header file or creating some macros.

// Header file: Some other developer written crucial files where our code components are defined.
// macros: Some constant that we might need in our programme multiple times.
using namespace std;
// iostream actually contains the definition but, std maintain the registry with which we can use various components.
// Work: prevent conflict between other definition of same keyword.

// Define & Declare
// Define: actual meaning, definition of keywords with codes which lies inside iostream.
// Declare: The flag or, registry to told the compiler that we will use some specific definition form iostream which lies inside namespace std.

// main() is a spacial function that denotes the enter point of our code.
// There will be only one main() in every file.
int main() {
    // int represents that after the execution of main() it should get a integer 	value.
	
    // C++ execute lines sequentially according to their place in the file.
	
    // Output in C++
    std::cout << "Hello World!\n";
    // As we define namespace at the top of the file so will can skip std.
    // cout is a object that defined in iostream which helps to print things on 	terminal.
    // << is a operator to print stuff using cout.
    // \n is a escape sequence character which is a spacial part of string that 	denotes next line.
    cout << "My name is Sankhadeep Pal. " << "I am a first year college 			student!" << endl;
    // We can join multiple string using <<.
    // endl warks just like \n, but we have to join is using <<.
    // We will prefer \n because performance wise it's faster.
	
    cout << "------------\n"; // this line for separating two lessons from each 	other.
	
    // Activity 1: print -
    // ****
    // ***
    // **
    // *
    cout << "****\n***\n**\n*\n";
	
    cout << "------------\n";
	
    // Variables in C++
    // Variables: container in memory that can stores different types of value.
    // Literals: constants whose values are fixed.
    // Identifiers: to give a name to any kind of container is call identify; 		and the container is called identifier. i.e - variables, functions, objects, 	classes.
    // TIP: give identifiers some meaningful name.
    int age = 19;
    cout << "age" << endl;
    // Inside "" everything will be printed as it is (expect escape sequence 		characters).
    cout << "age = " << age << endl;
    // This age denotes the variable.
    int marks;
    cout << "marks = " << marks << endl;
    // If we create some variable without assigning any value the it will by 		default store some random garbage value.
    marks = 100;
    cout << "marks = " << marks << endl;
    // Now it will store the assigned value.
    /*
        (*) Naming Conventions
        1. The name should start with an underscore(_) or a letter.
        2. The name can only contain uppercase & lowercase letters, digits from 			O to 9 and underscore.
        3. It must not be a keyword (reserved words)(There are 90+ keywords!). 				Keywords have a special meaning for the compiler.
    */
	
    cout << "------------\n";
	
    // Datatypes in C++
    // There are two types of datatypes:
    // 1. Primitive:
    //    1. int(integer) - 4 bytes; range: [-2^31, 2^31-1]
    //    2. char(character) - 1 bytes; range: All single character (defined in 	'')
    //    3. bool(boolean) - 1 bytes; range: {0, 1}
    //    4. float(decimal) - 4 bytes; range: dynamic range (precision: 7 number)
    //    5. double(decimal) - 8 bytes; range: dynamic range (precision: 15 		number)
    // 2. Non-primitive:
    //    1. string
    //    2. array etc.
    cout << "Size of int: " << sizeof(int) << endl;
    // sizeof function gives the size in bytes.
	
    float pie1 = 3.14159265359;
    double pie2 = 3.14159265359;
    cout << "pie1: " << pie1 << endl;
    cout << "pie2: " << pie2 << endl;
    // precision of cout is 5 numbers, so we have to use iomanip header file to 	enlarge the precision.
	
    cout << setprecision(12) << "pie1: " << pie1 << endl;
    cout << setprecision(12) << "pie2: " << pie2 << endl;
    // Now we can see the precision of float and double.
	
    cout << "------------\n";
	
    // Comments in C++
    // // <- single line comments
    // /* <--+-- multi line comments
    //       |
    // */ <--+
	
    cout << "------------\n";
	
    // Inputs in C++
    int num1;
    cout << "Enter a number: ";
    cin >> num1;
    // cin helps us to take input from terminal,
    // >> assign the taken value to variable.
    cout << "You entered: " << num1 << endl;
	
    cout << "------------\n";
	
    // Activity 2: sum of two numbers.
    int a, b;
    cout << "Enter the first number: ";
    cin >> a;
    cout << "Enter the second number: ";
    cin >> b;
    cout << "Sum: " << a + b << endl;
	
    cout << "------------\n";
	
    // Activity 3: print avarage of three subjects.
    float math, phy, chem;
    cout << "Enter the number of mathematics: ";
    cin >> math;
    cout << "Enter the number of physics: ";
    cin >> phy;
    cout << "Enter the number of chemistry: ";
    cin >> chem;
    cout << "Avarage: " << (math + phy + chem) / 3 << "%\n";
    return 0;
    // this line denotes that the integer that main() is getting is 0.
}

```

---

## What is C++?
**C++** is a **general-purpose, high-level programming language** developed as an **extension of the C language**. It adds **Object-Oriented Programming (OOP)** features to C, while maintaining its **speed, efficiency, and low-level memory control**.

> In short: **C++ = C + Object-Oriented Programming**

It is both a **compiled** and **statically typed** language, meaning:

- Code must be **compiled** before running.

- Data types must be **declared explicitly**.

### ‚úíÔ∏è History and Origin

|Year|Event|
|---|---|
|**1979**|_Bjarne Stroustrup_ at Bell Labs (USA) begins developing ‚ÄúC with Classes‚Äù.|
|**1983**|The language is officially named **C++**.|
|**1985**|First commercial release of C++.|
|**1998**|**C++98** ‚Äî the first ISO standard version.|
|**2011‚Äì2020**|Major upgrades (C++11, C++14, C++17, C++20) with modern features like smart pointers, auto keyword, lambdas, etc.|

> ‚ÄúC++‚Äù name reflects the **increment operator (++) in C**, symbolizing an _improved version of C_.

### üõ†Ô∏è Characteristics of C++

- **Compiled Language:** Requires a compiler (like GCC, Clang, or Turbo C++) to translate code into machine language.

- **Object-Oriented:** Supports OOP principles ‚Äî classes, inheritance, polymorphism, abstraction, and encapsulation.

- **Mid-Level Language:** Combines **high-level** (user-friendly syntax) and **low-level** (hardware-level control) features.

- **Platform-Independent:** C++ programs can run on multiple operating systems with minimal changes.

- **Fast and Efficient:** Offers manual memory management and minimal runtime overhead.

- **Extensible:** Can easily integrate new data types and libraries.

- **Rich Standard Library:** Includes built-in functions for data structures, algorithms, input/output, math, and more.

### üõ†Ô∏è Features of C++

|Feature|Description|
|---|---|
|**OOP Support**|Encapsulates data and functions into classes.|
|**Compiler-Based**|Converts code to machine language before execution.|
|**Memory Management**|Uses `new`, `delete`, and pointers for control over memory.|
|**Portable**|Programs can run across platforms with little modification.|
|**Rich Function Library**|Offers STL (Standard Template Library) for data structures and algorithms.|
|**Flexibility**|Allows both structured and object-oriented programming styles.|
|**Reusability**|Promotes modularity and code reuse via classes and inheritance.|
|**Speed**|Faster than interpreted languages (like Python or JavaScript).|

### üëç Advantages of C++

- **High performance and efficiency** (close to hardware).

- **Supports both procedural and object-oriented programming.**

- **Portable** across platforms and devices.

- **Strong type checking** prevents common programming errors.

- **Extensive library support** through STL.

- **Widely used in industry** for system software, game engines, and embedded systems.

### üëé Disadvantages of C++

- **Complex syntax** compared to modern languages.

- **Manual memory management** can lead to errors (e.g., memory leaks).

- **No built-in garbage collection** (unlike Java or Python).

- **Lacks runtime safety** ‚Äî errors can crash the program.

- **Steep learning curve** for beginners.

### üåç Real-World Applications of C++
C++ is used where **speed, performance, and control** are critical.

| Field                       | Examples                                          |
| --------------------------- | ------------------------------------------------- |
| **Operating Systems**       | Windows, macOS parts, Linux components            |
| **Game Development**        | Unreal Engine, Unity‚Äôs backend                    |
| **Database Systems**        | MySQL, MongoDB core components                    |
| **Embedded Systems**        | IoT devices, smart appliances                     |
| **Browsers**                | Chrome, Firefox (rendering engines)               |
| **Finance/Trading Systems** | High-frequency trading software                   |
| **Compilers/Interpreters**  | Many language compilers are written in C++ itself |

### üÜö C vs. C++

|Feature|C|C++|
|---|---|---|
|Programming Paradigm|Procedural|Object-Oriented + Procedural|
|Data Security|No data hiding|Supports encapsulation|
|Functions|Standalone|Can be part of classes|
|Overloading|Not supported|Supported|
|Inheritance|Not supported|Supported|
|Polymorphism|Not supported|Supported|
|Namespace|Not available|Available|
|Exception Handling|Not supported|Supported|
|Input/Output|`printf()`, `scanf()`|`cin`, `cout`|

---

## Boilerplate Code in C++
**Boilerplate code** refers to the **basic, standard code structure** that‚Äôs required to make any C++ program run ‚Äî even if it doesn‚Äôt perform any special task.

> In simple terms:  
> **Boilerplate = The ‚Äústarting template‚Äù for a C++ program.**

It includes:

- Header inclusion

- Namespace declaration

- The main function

- Basic input/output setup

You‚Äôll write this skeleton every time before adding your actual logic.

### ‚úÖ Basic C++ Boilerplate Code

```cpp
#include <iostream>         // 1. Include standard input/output library
using namespace std;        // 2. Use standard namespace

int main()                  // 3. Entry point of the program
{
    // 4. Program logic goes here
    cout << "Hello, World!";    // Output statement
    return 0;                   // 5. Exit status
}
```

### üìò Explanation

|Line|Code|Description|
|---|---|---|
|1|`#include <iostream>`|A **preprocessor directive** that includes the **input-output stream library** ‚Äî needed for `cin` (input) and `cout` (output).|
|2|`using namespace std;`|Tells the compiler to use the **Standard Namespace**, so you don‚Äôt have to prefix everything with `std::` (e.g., `std::cout`).|
|3|`int main()`|The **main function**, where program execution begins. Every C++ program must have one.|
|4|`{ ... }`|The **body** of the main function, where your actual code (logic/statements) resides.|
|5|`cout << "Hello, World!";`|Displays output to the console. The `<<` operator sends data to the output stream.|
|6|`return 0;`|Returns a value to the OS ‚Äî `0` indicates successful program termination.|

### ‚ùì Why Boilerplate Code Exists
C++ is a **compiled language**, not an interpreted one.  
That means the compiler needs:

1. A clear **entry point** (`main()` function).

2. Knowledge of which **libraries** to use (via `#include`).

3. Defined **namespaces** and **scope** for identifiers.

Without boilerplate, your code has no structure for the compiler to understand.


### ‚ûï Things You Can Add to Boilerplate
Depending on your project, your boilerplate might also include:

- **Header comments/documentation**

- **Custom function declarations**

- **Macro definitions**

- **Include guards** (for header files)

- **Using statements for types (e.g., `using ll = long long;`)**

- **Input/output optimization lines (for competitive programming)**

### üìÑ Key Notes

- The **boilerplate never changes much**; you just add your logic inside.

- In **real projects**, you‚Äôll often see larger boilerplates split into multiple files (`main.cpp`, `utils.cpp`, `header.h`).

- Modern IDE (like Visual Studio, Code:: Blocks, VS Code) often **auto-generate** this boilerplate for you when creating a new file.

### ‚ùì Why It Matters
Understanding the boilerplate is crucial because:

- It helps you **debug startup errors** (like missing headers or return types).

- It forms the **base for every C++ program** you‚Äôll ever write.

- It teaches you the **flow of execution** from the compiler‚Äôs perspective.

### üîπ Summary

|Concept|Meaning|
|---|---|
|**Boilerplate Code**|The standard skeleton or startup template for C++ programs.|
|**Purpose**|Provides structure and tells the compiler where to start.|
|**Main Components**|Header inclusion, namespace, `main()` function, return statement.|
|**Flexibility**|Can be extended for different purposes ‚Äî learning, projects, or competitive coding.|

---

## How C++ Code Runs?
When you write C++ code, it‚Äôs just **text** ‚Äî the computer doesn‚Äôt understand it directly.  
The code has to go through **several translation stages** before the CPU can execute it.

The process follows **five major stages**:

> **Source Code ‚Üí Preprocessing ‚Üí Compilation ‚Üí Assembly ‚Üí Linking ‚Üí Execution**

### The Stages in Detail

#### Step 1: Writing the Source Code

- File: `program.cpp`

- You write your program using keywords, functions, and logic.

Example:

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Hello, World!";
    return 0;
}
```

This is called the **source code**.

#### Step 2: Preprocessing
When you compile, the **preprocessor** runs _before_ the actual compilation.

##### ‚ùì What it does:

- Handles **preprocessor directives** like `#include`, `#define`, `#ifdef`, etc.

- It **copies** header files (like `<iostream>`) into your code.

- Removes comments.

- Expands macros.

> ‚úÖ **Output:** A modified file called the **translation unit** (still human-readable but expanded).

Example:

```cpp
#include <iostream>     // ‚Üí replaced by full library content
using namespace std;
```

gets expanded to include all I/O definitions (like `cout`, `cin`, etc.).

#### Step 3: Compilation

The **compiler** now takes that preprocessed code and:

- Checks for **syntax errors** (e.g., missing semicolons, undeclared variables).

- Converts high-level C++ code into **assembly language** or directly into **object code** (machine instructions for the CPU).

> ‚úÖ **Output:** An **object file**, usually named `program.o` or `program.obj`.

This file is **machine code**, but it‚Äôs **not yet executable** ‚Äî it‚Äôs missing system-level information and external library links.

#### Step 4: Assembling
In this stage:

- The **assembler** converts the compiler‚Äôs **assembly code** into **binary object code** (0s and 1s).

- These are the actual machine instructions specific to your CPU architecture.

> ‚úÖ **Output:** A **machine-level object file** ready for linking.

#### Step 5: Linking
Now the **linker** takes over.

Your object file (`program.o`) may call functions defined in:

- The **C++ Standard Library** (like `cout` or `sqrt()`).

- Other object files or libraries you wrote.

The linker:

- **Combines** all object files into a single executable.

- **Resolves symbols** (i.e., matches function calls with their definitions).

- Removes unused code (optimization).

> ‚úÖ **Output:** The final **executable file**, usually named `program.exe` (Windows) or `a.out` (Linux/Mac).

#### Step 6: Loading and Execution
Finally, when you run your program:

1. The **loader** (part of the OS) loads the executable into memory.

2. The **CPU starts execution** from the `main()` function.

3. Your instructions are executed line by line.

4. Once `return 0;` is reached, control is given back to the OS.

> ‚úÖ **Output:** The result appears on screen (e.g., `Hello, World!`).

### üëÅÔ∏è Visual Representation

```
+----------------------+
|  Source Code (.cpp)  |
+----------------------+
            |
            v
+----------------------+
|   Preprocessor       |
|  (#include, #define) |
+----------------------+
            |
            v
+----------------------+
|    Compiler          |
| (Syntax Check +      |
|  Object Code Gen.)   |
+----------------------+
            |
            v
+----------------------+
|     Assembler        |
| (Converts to Binary) |
+----------------------+
            |
            v
+----------------------+
|      Linker          |
| (Combines Libraries) |
+----------------------+
            |
            v
+----------------------+
|   Executable File    |
|  (program.exe / a.out)|
+----------------------+
            |
            v
+----------------------+
|    Loader + CPU Run  |
| (Program Executes)   |
+----------------------+
```

### üî∏ Example with File Names

|Stage|Input|Output|
|---|---|---|
|Source|`program.cpp`|‚Äî|
|Preprocessing|`program.cpp`|`program.i`|
|Compilation|`program.i`|`program.s`|
|Assembling|`program.s`|`program.o`|
|Linking|`program.o` + libraries|`program.exe`|
|Execution|`program.exe`|Output on screen|

### üõ†Ô∏è Common Tools for Each Stage

|Stage|Tool/Command|Example|
|---|---|---|
|Preprocessing|`g++ -E`|`g++ -E program.cpp -o program.i`|
|Compilation|`g++ -S`|`g++ -S program.cpp -o program.s`|
|Assembling|`g++ -c`|`g++ -c program.cpp -o program.o`|
|Linking|`g++`|`g++ program.o -o program`|
|Execution|Run file|`./program`|

### üîë Key Points to Remember

- The **compiler does not run your program** ‚Äî it only translates it.

- The **linker** ensures all parts (including libraries) fit together.

- The **OS loader** actually runs the program.

- Errors can occur in different stages:
    
    - Syntax ‚Üí during **compilation**
    
    - Undefined reference ‚Üí during **linking**
    
    - Runtime crash ‚Üí during **execution**

### üîπ Summary

|Stage|Role|Output|
|---|---|---|
|**Preprocessing**|Expands macros, includes headers|Preprocessed code|
|**Compilation**|Translates code to assembly/object code|`.o` or `.obj`|
|**Assembling**|Converts to binary|Machine code|
|**Linking**|Merges code + libraries|Executable file|
|**Execution**|Runs program on CPU|Output result|

---

## Output in C++
**Output** in C++ means **displaying information or data from the program to the user**, usually on the **console screen**.

> In C++, output is handled using the **`cout` (console output)** object, which is part of the **iostream** library.

### ‚úÖ Output Statement Syntax

```cpp
cout << expression;
```

Here‚Äôs what‚Äôs happening:

|Element|Meaning|
|---|---|
|`cout`|Stands for **console output** (defined in `<iostream>`).|
|`<<`|The **insertion operator** ‚Äî it sends data _to_ the output stream.|
|`expression`|The **data or message** to be displayed.|

### üî∏ Example ‚Äì Basic Output

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Hello, World!";
    return 0;
}
```

**Output:**

```
Hello, World!
```

### Output Manipulation
#### üíª Printing Multiple Items
You can use multiple `<<` operators in one statement:

```cpp
cout << "Sum of 2 and 3 is: " << 2 + 3;
```

**Output:**

```
Sum of 2 and 3 is: 5
```

> The operator `<<` can be chained ‚Äî data is inserted into the output stream _from left to right_.

#### üíª Displaying Variables

```cpp
#include <iostream>
using namespace std;

int main() {
    int age = 20;
    cout << "My age is " << age;
    return 0;
}
```

**Output:**

```
My age is 20
```

#### ‚úÖ Using `endl` and `\n` (New Line)
To move to a new line in output, you can use either:

- `endl` ‚Üí outputs a newline and flushes the buffer.

- `\n` ‚Üí outputs a newline only (faster, no buffer flush).

**Example:**

```cpp
cout << "Line 1" << endl;
cout << "Line 2\n";
```

**Output:**

```
Line 1
Line 2
```

> **Tip:** For performance-critical code (like competitive programming), prefer `\n`.  
> For clean console output, use `endl`.

#### üíª Outputting Different Data Types
C++ `cout` automatically handles data type conversions.

```cpp
#include <iostream>
using namespace std;

int main() {
    int num = 10;
    float pi = 3.14;
    char grade = 'A';
    string name = "Sankho";
	
    cout << "Name: " << name << "\n";
    cout << "Grade: " << grade << "\n";
    cout << "Number: " << num << "\n";
    cout << "Pi value: " << pi << "\n";
    return 0;
}
```

**Output:**

```
Name: Sankho
Grade: A
Number: 10
Pi value: 3.14
```

#### üõ†Ô∏è Formatting Output
C++ provides ways to **format output** neatly using:

- `<iomanip>` library (for manipulators like `setw()`, `setprecision()`, etc.)

- `cout` manipulators for alignment and precision control.

**Example:**

```cpp
#include <iostream>
#include <iomanip>     // Required for manipulators
using namespace std;

int main() {
    float num = 123.4567;
	
    cout << "Default: " << num << endl;
    cout << "Fixed: " << fixed << num << endl;
    cout << "Precision(2): " << setprecision(2) << num << endl;
    cout << "Width(10): " << setw(10) << num << endl;
    return 0;
}
```

**Output:**

```
Default: 123.457
Fixed: 123.456703
Precision(2): 123.46
Width(10):    123.46
```

#### ‚õìÔ∏è‚Äçüí• Chaining and Expression Evaluation
You can mix expressions directly inside `cout`:

```cpp
int a = 5, b = 10;
cout << "Sum: " << a + b << ", Product: " << a * b;
```

**Output:**

```
Sum: 15, Product: 50
```

C++ evaluates the arithmetic expressions before printing.

### üíª Output with Escape Sequences
Escape sequences let you control text format within strings.

|Escape Sequence|Meaning|Example Output|
|---|---|---|
|`\n`|New line|Moves text to next line|
|`\t`|Tab space|Adds horizontal tab|
|`\\`|Backslash|Prints `\`|
|`\"`|Double quote|Prints `"`|
|`\'`|Single quote|Prints `'`|

**Example:**

```cpp
cout << "Name:\tSankho\nAge:\t20\n";
```

**Output:**

```
Name:   Sankho
Age:    20
```

### ‚Ü©Ô∏è Alternative: Using `printf()`
Even though `cout` is standard in C++, you can still use **`printf()`** (from C language, via `<cstdio>`).

```cpp
#include <cstdio>
int main() {
    printf("Result = %d", 25);
    return 0;
}
```

**Output:**

```
Result = 25
```

> `printf()` is faster for formatted output, but less flexible and not type-safe compared to `cout`.

### üîπ Summary

|Feature|`cout`|
|---|---|
|Header|`<iostream>`|
|Operator|`<<` (insertion operator)|
|Namespace|`std`|
|Common Manipulators|`endl`, `setprecision()`, `setw()`|
|Best Use|Type-safe, modern output for all data types|
|Alternative|`printf()` (C-style, faster but outdated)|

---

## Variables in C++
A **variable** is a **named memory location** used to **store data** that can be **changed during program execution**.

> In simple terms:  
> A variable is a **container** for storing a value in your computer‚Äôs memory.

### ‚úÖ Syntax of Variable Declaration

```cpp
data_type variable_name = value;
```

**Example:**

```cpp
int age = 20;
float pi = 3.14;
char grade = 'A';
```

### üß© Components of a Variable Declaration

|Component|Meaning|
|---|---|
|**Data type**|Defines the kind of data (e.g., `int`, `float`, `char`, etc.)|
|**Variable name**|Unique identifier (e.g., `age`, `score`)|
|**Assignment operator (`=`)**|Used to assign a value|
|**Value**|Actual data stored in the variable|

### üìú Rules for Naming Variables
C++ follows strict rules for variable naming:

|Rule|Example|
|---|---|
|Must start with a **letter** or **underscore**|`_count`, `marks`|
|Can contain **letters, digits, and underscores**|`roll_no1`, `sum_total`|
|**Case-sensitive**|`Age` ‚â† `age`|
|No **spaces** or **special symbols**|‚ùå `my age`, `num#1`|
|Cannot use **reserved keywords**|‚ùå `int float;`|
|Should have **meaningful names**|‚úÖ `totalMarks`, ‚ùå `x1`|

### üÜö Variable Declaration vs. Initialization

|Term|Meaning|Example|
|---|---|---|
|**Declaration**|Telling the compiler a variable exists (reserves memory)|`int num;`|
|**Initialization**|Assigning an initial value|`num = 10;`|
|**Combined**|Both declaration and initialization|`int num = 10;`|

### Types of Variables
C++ supports **different types of variables** based on scope and lifetime.

|Type|Description|Example|
|---|---|---|
|**Local Variable**|Declared inside a function/block; accessible only there.|Inside `main()` or loops.|
|**Global Variable**|Declared outside all functions; accessible everywhere.|Before `main()`.|
|**Static Variable**|Retains its value between function calls.|`static int count = 0;`|
|**Automatic Variable**|Created by default in local scope.|`int a = 5;`|
|**Register Variable**|Stored in CPU registers for fast access (suggested, not guaranteed).|`register int x = 10;`|
|**Extern Variable**|Declared but defined elsewhere (external linkage).|`extern int total;`|
|**Constant Variable**|Value cannot be changed once assigned.|`const float PI = 3.14;`|

#### üî∏ Example ‚Äì Different Types in Action

```cpp
#include <iostream>
using namespace std;

int globalVar = 100;        // Global variable

void test() {
    static int count = 0;   // Static variable
    count++;
    cout << "Count = " << count << endl;
}

int main() {
    int localVar = 10;      // Local variable
    register int speed = 50; // Register variable (suggested fast access)
    const float PI = 3.14;  // Constant variable

    cout << "Global: " << globalVar << endl;
    cout << "Local: " << localVar << endl;
    cout << "Register: " << speed << endl;
    cout << "Constant: " << PI << endl;

    test();
    test();
    return 0;
}
```

**Output:**

```
Global: 100
Local: 10
Register: 50
Constant: 3.14
Count = 1
Count = 2
```

### ‚úÖ Scope and Lifetime of Variables

|Type|Scope|Lifetime|
|---|---|---|
|**Local**|Within the function/block|Created when function starts, destroyed when it ends|
|**Global**|Entire program|Created at start, destroyed at program end|
|**Static**|Local to function, but retains value|Throughout program execution|
|**Register**|Within function/block|Same as local but stored in CPU register|

### üì• Variable Storage Classes
C++ defines variable _behavior_ through **storage classes**:

|Keyword|Storage|Scope|Lifetime|Default Value|
|---|---|---|---|---|
|`auto`|RAM|Local|Function execution|Garbage|
|`register`|CPU Register (if possible)|Local|Function execution|Garbage|
|`static`|RAM|Local/Global|Entire program|0|
|`extern`|RAM|Global|Entire program|0|

### üëç Best Practices for Variables

- Use **descriptive names** (e.g., `totalMarks`, not `tm`).

- Initialize variables immediately to avoid garbage values.

- Avoid **global variables** unless necessary.

- Use `const` for values that shouldn‚Äôt change (e.g., `PI`, `MAX_SIZE`).

- Use consistent **naming conventions** (`camelCase` or `snake_case`).

### üî∏ Example ‚Äì Variable Interaction

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 5, b = 10;
    int sum = a + b;
    cout << "Sum = " << sum << endl;

    a = a + 1; // Reassigning variable
    cout << "Updated a = " << a;
    return 0;
}
```

**Output:**

```
Sum = 15
Updated a = 6
```

---

## Data Types in C++
A **data type** defines:

- **What kind of data** a variable can store, and

- **How much memory** it will use in RAM.

> In short: A _data type_ tells the compiler **the size and type of data** associated with a variable.

### üè∑Ô∏è Classification of Data Types
C++ data types are broadly classified into:

|Category|Description|
|---|---|
|**1. Built-in / Primitive**|Basic types provided by C++ itself (e.g., `int`, `float`, `char`, `bool`, etc.)|
|**2. Derived**|Built from primitive types (e.g., `arrays`, `pointers`, `functions`, `references`)|
|**3. User-defined**|Created by the programmer (e.g., `struct`, `class`, `enum`, `union`, `typedef`)|

### 1. Built-in (Primitive) Data Types

|Data Type|Description|Size (Bytes)|Example|
|---|---|---|---|
|`int`|Integer (whole numbers)|4|`int age = 20;`|
|`float`|Single-precision decimal|4|`float pi = 3.14;`|
|`double`|Double-precision decimal|8|`double area = 45.567;`|
|`char`|Single character (ASCII)|1|`char grade = 'A';`|
|`bool`|Boolean (true/false)|1|`bool pass = true;`|
|`void`|No data type|0|Used in functions that return nothing|

> **Note:**  
> Actual sizes depend on compiler and system (e.g., 32-bit vs 64-bit).  
> You can confirm using `sizeof()` operator.

#### Modifiers in Data Types
Modifiers **change the size or range** of data types.

|Modifier|Applicable To|Description|
|---|---|---|
|`signed`|int, char|Default ‚Äî can hold both positive & negative values|
|`unsigned`|int, char|Only positive values (doubles the positive range)|
|`short`|int|Smaller range (2 bytes)|
|`long`|int, double|Larger range (8 bytes for `long long`)|

##### üî∏ Example ‚Äì Using Modifiers

```cpp
#include <iostream>
using namespace std;

int main() {
    unsigned int age = 25;      // Only positive numbers
    short int temp = -15;       // Smaller integer range
    long long distance = 9876543210;

    cout << "Age: " << age << endl;
    cout << "Temperature: " << temp << endl;
    cout << "Distance: " << distance << endl;
    return 0;
}
```

**Output:**

```
Age: 25
Temperature: -15
Distance: 9876543210
```

#### Floating-Point Data Types

|Type|Precision|Size|Example|
|---|---|---|---|
|`float`|6‚Äì7 digits|4 bytes|`float f = 3.14159;`|
|`double`|15‚Äì16 digits|8 bytes|`double d = 3.141592653589;`|
|`long double`|19+ digits|12 or 16 bytes|`long double ld = 3.141592653589793;`|

**Note:** Use `fixed` and `setprecision()` from `<iomanip>` to control decimal output.

### 2. Derived Data Types

| Type          | Description                        |
| ------------- | ---------------------------------- |
| **Array**     | Collection of same-type elements   |
| **Pointer**   | Stores address of another variable |
| **Reference** | Alternate name for variable        |
| **Function**  | Block of reusable code             |

### 3. User-defined Data Types

|Type|Description|Example|
|---|---|---|
|`struct`|Collection of variables under one name|`struct Student { int id; string name; };`|
|`class`|Blueprint for objects (OOP concept)|`class Car { public: string brand; };`|
|`union`|Store different data types in same memory|`union Data { int i; char c; };`|
|`enum`|User-defined constants|`enum Week { Mon, Tue, Wed };`|
|`typedef`|Create alias for existing type|`typedef unsigned int uint;`|

### üîπ Summary

| Category         | Type Examples                               | Description                        |
| ---------------- | ------------------------------------------- | ---------------------------------- |
| **Primitive**    | `int`, `float`, `char`, `bool`, `void`      | Basic built-in types               |
| **Derived**      | `array`, `pointer`, `function`, `reference` | Built from primitive types         |
| **User-defined** | `struct`, `class`, `enum`, `union`          | Created by the programmer          |
| **Modifiers**    | `short`, `long`, `signed`, `unsigned`       | Modify range and size of base type |

- Quick Reference ‚Äî Memory Size (Typical 64-bit System)
	
| Data Type        | Size         | Range              |
| ---------------- | ------------ | ------------------ |
| `char`           | 1 byte       | -128 to 127        |
| `unsigned char`  | 1 byte       | 0 to 255           |
| `short`          | 2 bytes      | -32,768 to 32,767  |
| `unsigned short` | 2 bytes      | 0 to 65,535        |
| `int`            | 4 bytes      | -2.1B to 2.1B      |
| `unsigned int`   | 4 bytes      | 0 to 4.2B          |
| `long`           | 4 or 8 bytes | large range        |
| `long long`      | 8 bytes      | very large range   |
| `float`          | 4 bytes      | ~6 decimal digits  |
| `double`         | 8 bytes      | ~15 decimal digits |
| `bool`           | 1 byte       | true / false       |

---

## Input in C++
**Input** means **taking data from the user** and storing it in variables during program execution.

In C++, this is done using the **`cin` (console input)** object, which is part of the **`iostream`** library.

> Simply put:  
> `cin` allows your program to **receive values typed by the user** via the keyboard.

### ‚úÖ Syntax

```cpp
cin >> variable_name;
```

**Explanation:**

|Element|Meaning|
|---|---|
|`cin`|Stands for **console input**|
|`>>`|**Extraction operator**, extracts data from the input buffer|
|`variable_name`|The variable that stores the input value|

---

### Example
#### üî∏ Single Input

```cpp
#include <iostream>
using namespace std;

int main() {
    int age;
    cout << "Enter your age: ";
    cin >> age;
    cout << "You are " << age << " years old.";
    return 0;
}
```

**Output (User Input in Bold):**

```
Enter your age: 20
You are 20 years old.
```

#### üî∏ Multiple Inputs

You can read multiple values using the same `cin` statement.

```cpp
int a, b;
cout << "Enter two numbers: ";
cin >> a >> b;
cout << "Sum = " << a + b;
```

**Input:**

```
5 7
```

**Output:**

```
Sum = 12
```

> `cin` automatically separates values by **spaces**, **tabs**, or **newlines**.

#### üî∏ Reading Different Data Types
C++ automatically matches the data type of variable and input.

```cpp
#include <iostream>
using namespace std;

int main() {
    int roll;
    float marks;
    char grade;

    cout << "Enter roll, marks, and grade: ";
    cin >> roll >> marks >> grade;

    cout << "\nRoll: " << roll;
    cout << "\nMarks: " << marks;
    cout << "\nGrade: " << grade;
    return 0;
}
```

**Input:**

```
101 89.5 A
```

**Output:**

```
Roll: 101
Marks: 89.5
Grade: A
```

#### üî∏ Ignore Unwanted Input

```cpp
cin.ignore(100, '\n'); 
```

Ignores up to 100 characters or until newline ‚Äî useful when switching between `cin` and `getline`.
### cin Issue
#### ‚ùó Problem
`cin` **stops reading at spaces**, so it cannot take full sentences.

Example:

```cpp
string name;
cout << "Enter full name: ";
cin >> name;
cout << "Your name is: " << name;
```

**Input:**

```
Sankho Roy
```

**Output:**

```
Your name is: Sankho
```

Only the first word is taken!

#### ‚úîÔ∏è Solution
To take **full-line input** (including spaces), use `getline()`.

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string name;
    cout << "Enter full name: ";
    getline(cin, name);
    cout << "Your name is: " << name;
    return 0;
}
```

**Input:**

```
Sankho Roy
```

**Output:**

```
Your name is: Sankho Roy
```

> `getline(cin, variable_name)` reads **entire line until newline (`\n`)**.

#### üî∂ Important
If you use both `cin` and `getline()` together, a **newline issue** can occur.

**Example Problem:**

```cpp
int age;
string name;

cout << "Enter age: ";
cin >> age;
cout << "Enter name: ";
getline(cin, name); // ‚ùå Skips input
```

**Fix:** Use `cin.ignore()` before `getline()` to clear leftover newline.

```cpp
int age;
string name;

cout << "Enter age: ";
cin >> age;
cin.ignore(); // clears '\n' left in buffer
cout << "Enter name: ";
getline(cin, name);
```

### Input Validation (Basic)
C++ does not automatically check for input errors ‚Äî you can test validity manually.

```cpp
#include <iostream>
using namespace std;

int main() {
    int number;
    cout << "Enter a number: ";
    cin >> number;

    if (cin.fail()) {
        cout << "Invalid input! Please enter an integer.";
    } else {
        cout << "You entered: " << number;
    }
    return 0;
}
```

If user enters text (e.g., `abc`), the program detects the error.

#### Stream State Checking Functions

|Function|Description|
|---|---|
|`cin.good()`|Returns true if stream is working fine|
|`cin.fail()`|True if wrong data type or failure|
|`cin.eof()`|True if end-of-file reached|
|`cin.clear()`|Resets error flags|
|`cin.ignore()`|Ignores unwanted input characters|

### üîπ Summary

|Concept|Description|Example|
|---|---|---|
|**Input object**|`cin`|`cin >> a;`|
|**Operator**|Extraction (`>>`)|`cin >> x >> y;`|
|**Header**|`<iostream>`|Needed for `cin`|
|**String input**|`getline()`|`getline(cin, name);`|
|**Multiple input**|Read multiple values|`cin >> a >> b;`|
|**Error handling**|`cin.fail()`, `cin.clear()`|For input validation|
|**Ignore leftover newline**|`cin.ignore()`|Before `getline()`|

---

## <mark style="background: #BBFABBA6;">Day 2 - Class notes</mark>
```C++
#include <iostream>

using namespace std;

int main() {
    // Constants in C++
    // variables whose value can't be changed after initialization.
    const float pie = 3.14;
    // pie = 3; // this will throw syntax error.
    // const x; // We have to initialize constant with some values. This will 		throw syntax error.
	
    /*
    (*) Difference between constants and macros:
    macros don't take any space in out memory, at runtime compiler replace all 		occurrences will their value.
    & constants takes spaces in memory just like normal variables, at runtime 		the value of constant is being fetched from memory by compiler.
    */
	
    cout << "-------------\n";
	
    // Typecasting in C++
    // Conversion of data from one type to another.
    // There are two types of typecasting in C++
	
    // 1. implicit Conversion (automatic/ type promotion)
    // Compiler automatically do it to prevent data loss.
    cout << "10/3: " << 10 / 3 << endl; // 3
    cout << "10/3.0: " << 10 / 3.0 << endl; // 3.33333
    // If in a operation is working between two different datatype, compiler 		always makes the answer in larger data type.
    // int/int = int & int/double = double.
    // (*) bool -> char -> int -> float -> double.
    cout << "'A' + 1: " << 'A' + 1 << endl; // 66
    cout << "'a' + 1: " << 'a' + 1 << endl; // 98
    // All the characters are stores in the memory as numbers (ascii values) so, 	char + int = int
    // We can print corrsponding ascii values also,
    cout << "'A': " << 'A' + 0 << endl; // 65
    cout << "'a': " << 'a' + 0 << endl; // 97
	
    // 2. explicit Conversion (forced by programmer)
    cout << "(char)('A' + 1): " << (char)('A' + 1) << endl; // B
    cout << "(int)pie: " << (int)pie << endl; // 3
    cout << "(int)3.999: " << (int)3.999 << endl; // 3
    // C++ compiler just cut the decimal part at the time of typecast.
	
    cout << "-------------\n";
	
    // We use a f at the end of the decimal to show that it's a float value not 	double.
    cout << "sizeof(3.14): " << sizeof(3.14) << endl;
    cout << "sizeof(3.14f): " << sizeof(3.14f) << endl;
	
    cout << "-------------\n";
	
    // Operators
    // Symbols that tells compiler to do certain operations.
	
    // Arithmetic operators
    // Binary:
    cout << "10+6: " << 10 + 6 << endl;
    cout << "10-6: " << 10 - 6 << endl;
    cout << "10*6: " << 10 * 6 << endl;
    cout << "10/6: " << 10 / 6 << endl;
    cout << "10%6: " << 10 % 6 << endl;
    // Unary:
    int a = 10, b = 0;
    cout << "a, b: " << a << ", " << b << endl;
    cout << "a++: " << a++ << endl; // postincrement
    cout << "a, b: " << a << ", " << b << endl;
    cout << "++a: " << ++a << endl; // preincrement
    cout << "a, b: " << a << ", " << b << endl;
    cout << "a--: " << a-- << endl; // postdecrement
    cout << "a, b: " << a << ", " << b << endl;
    cout << "--a: " << --a << endl; // predecrement
	
    cout << "a, b: " << a << ", " << b << endl;
    b = a++;
    cout << "b = a++" << endl;
    cout << "a, b: " << a << ", " << b << endl;
    b = ++a;
    cout << "b = ++a" << endl;
    cout << "a, b: " << a << ", " << b << endl;
    b = --a;
    cout << "b = --a" << endl;
    cout << "a, b: " << a << ", " << b << endl;
    b = a--;
    cout << "b = a--" << endl;
    cout << "a, b: " << a << ", " << b << endl;
	
    // (*) - as of a sign is also a unary operator.
	
    // Assignment operators (Compound assignment operator)
    // =, +=, -=, *=, /=, %=
    int num1 = 10;
    cout << "num1: " << num1 << endl;
    num1 += 1;
    cout << "num1+= 1; num1: " << num1 << endl;
    num1 -= 1;
    cout << "num1 -= 1; num1: " << num1 << endl;
    num1 *= 2;
    cout << "num1 *= 2; num1: " << num1 << endl;
    num1 /= 2;
    cout << "num1 /= 2; num1: " << num1 << endl;
    num1 %= 3;
    cout << "num1 %= 3; num1: " << num1 << endl;
	
    // Relational operators
    // It shows the relation between 2 values.
    cout << "(3 > 5): " << (3 > 5) << endl;
    cout << "(3 < 5): " << (3 < 5) << endl;
    cout << "(5 >= 5): " << (5 >= 5) << endl;
    cout << "(3 <= 5): " << (3 <= 5) << endl;
    cout << "(3 == 5): " << (3 == 5) << endl;
    cout << "(5 == 5): " << (5 == 5) << endl;
    cout << "(3 != 5): " << (3 != 5) << endl;
    cout << "(5 != 5): " << (5 != 5) << endl;
    cout << "(!true): " << (!true) << endl;
    cout << "(!false): " << (!false) << endl;
	
    // Logical operators
    // &&, ||, !
	
    /*
    (*) && (Binary)
    +-----+-----+----------+
    |  A  |  B  |  A && B  |
    +-----+-----+----------+
    |  T  |  T  |    T     |
    |  T  |  F  |    F     |
    |  F  |  T  |    F     |
    |  F  |  F  |    F     |
    +-----+-----+----------+
	
    (*) || (Binary)
    +-----+-----+----------+
    |  A  |  B  |  A || B  |
    +-----+-----+----------+
    |  T  |  T  |    T     |
    |  T  |  F  |    T     |
    |  F  |  T  |    T     |
    |  F  |  F  |    F     |
    +-----+-----+----------+
	
    (*) ! (Unary)
    +-----+------+
    |  A  |  !A  |
    +-----+-------
    |  T  |  F   |
    |  F  |  T   |
    +-----+------+
    */
    return 0;
}

```

---

## Constants in C++
A **constant** is a variable whose **value cannot be changed** after it‚Äôs defined.

> Once a constant is assigned, it remains **fixed throughout program execution**.

Constants are used to store values that should not change ‚Äî like `PI`, `MAX_SIZE`, or configuration limits.

### ‚ùì Why Use Constants?

|Reason|Explanation|
|---|---|
|**Safety**|Prevents accidental modification of important values|
|**Readability**|Makes code self-explanatory|
|**Maintainability**|If a constant changes, you update it in one place|
|**Performance**|Compiler can optimize constants for faster execution|

### üü∞ Ways to Define Constants
C++ provides **three main ways** to define constants:

| Method                             | Keyword   | Example                            |
| ---------------------------------- | --------- | ---------------------------------- |
| **1. Using const keyword**         | `const`   | `const int age = 18;`              |
| **2. Using # define preprocessor** | `#define` | `#define PI 3.14159`               |
| **3. Using enum**                  | `enum`    | `enum Color { RED, GREEN, BLUE };` |

#### 1. Using `const` Keyword
**Syntax:**

```cpp
const data_type constant_name = value;
```

**Example:**

```cpp
#include <iostream>
using namespace std;

int main() {
    const float PI = 3.14159;
    const int MAX_STUDENTS = 50;

    cout << "PI = " << PI << endl;
    cout << "Max students allowed = " << MAX_STUDENTS;

    // PI = 3.14; // ‚ùå Error: cannot modify a constant
    return 0;
}
```

**Output:**

```
PI = 3.14159
Max students allowed = 50
```

> **Important:**  
> If you try to change a `const` variable, the compiler throws an error.

---

#### 2. Using `#define` Preprocessor Directive
**Syntax:**

```cpp
#define CONSTANT_NAME value
```

**Example:**

```cpp
#include <iostream>
#define PI 3.14159
#define MAX 100

using namespace std;

int main() {
    cout << "PI = " << PI << endl;
    cout << "Max value = " << MAX;
    return 0;
}
```

**Output:**

```
PI = 3.14159
Max value = 100
```

> The **preprocessor** replaces every occurrence of `PI` and `MAX` with their values **before compilation**.

##### üÜö Difference Between `#define` and `const`

|Feature|`#define`|`const`|
|---|---|---|
|Type safety|‚ùå No (simple text replacement)|‚úÖ Yes (compiler enforces data type)|
|Memory allocation|No memory|Memory allocated (if needed)|
|Scope|Global (available everywhere)|Follows normal scope rules|
|Debugging|Harder (no type info)|Easier (type information retained)|
|Preferred in modern C++|‚ùå Outdated|‚úÖ Recommended|

> ‚úÖ **Best Practice:** Use `const` instead of `#define` for constants ‚Äî it‚Äôs safer and modern.

#### 3. Using `enum` for Constants
An **enumeration (`enum`)** is a user-defined type that represents a set of **integer constants**.

**Syntax:**

```cpp
enum EnumName { constant1, constant2, constant3 };
```

**Example:**

```cpp
#include <iostream>
using namespace std;

enum Week { MON, TUE, WED, THU, FRI, SAT, SUN };

int main() {
    Week today = FRI;
    cout << "Today‚Äôs day number: " << today;
    return 0;
}
```

**Output:**

```
Today‚Äôs day number: 4
```

> Default values start from `0` unless explicitly assigned.  
> (MON=0, TUE=1, ‚Ä¶, FRI=4)

You can also assign custom values:

```cpp
enum Level { LOW = 1, MEDIUM = 2, HIGH = 3 };
```

#### 4. Constant Expressions ‚Äî `constexpr` (Modern C++)
Introduced in **C++11**, the `constexpr` keyword defines constants **evaluated at compile time** (not runtime).

**Syntax:**

```cpp
constexpr data_type constant_name = value;
```

**Example:**

```cpp
#include <iostream>
using namespace std;

constexpr int LIMIT = 100;
constexpr float PI = 3.14159265;

int main() {
    cout << "Limit = " << LIMIT << endl;
    cout << "PI = " << PI;
    return 0;
}
```

**Output:**

```
Limit = 100
PI = 3.14159
```

> Use `constexpr` for **performance-critical** constants, as it allows the compiler to precompute values.

### Constant Pointers
When using pointers with `const`, placement of the keyword **matters a lot**:

|Type|Meaning|Example|
|---|---|---|
|**Pointer to Constant**|Value cannot change|`const int *ptr;`|
|**Constant Pointer**|Address cannot change|`int *const ptr;`|
|**Constant Pointer to Constant**|Neither value nor address can change|`const int *const ptr;`|

#### üî∏ Example

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 5, y = 10;
    const int *ptr = &x;     // Pointer to constant

    // *ptr = 20; ‚ùå Error: can't modify value through ptr
    ptr = &y;                // ‚úÖ Can point to another variable

    cout << *ptr;
    return 0;
}
```

### üîπ Summary

|Method|Keyword|Modifiable|Type-Safe|Compile-Time?|Scope|
|---|---|---|---|---|---|
|`#define`|Preprocessor|‚ùå No|‚ùå No|‚úÖ Yes|Global|
|`const`|Keyword|‚ùå No|‚úÖ Yes|‚ö†Ô∏è Sometimes|Scoped|
|`constexpr`|Keyword|‚ùå No|‚úÖ Yes|‚úÖ Yes|Scoped|
|`enum`|Keyword|‚ùå No|‚úÖ Yes|‚úÖ Yes|Scoped (in C++11 and later)|

---

## Typecasting in C++
**Typecasting** means **converting one data type into another** manually or automatically.

In simple terms:

> Typecasting allows you to **change how a value is interpreted or stored** by the compiler.

### ‚ùì Why Typecasting Is Needed
C++ is a **strongly typed language**, meaning:

- You cannot freely assign one type to another (e.g., `int` to `float`) without conversion.

- Sometimes you need to match types for calculations or function parameters. 

**Example Without Typecasting:**

```cpp
int x = 10;
int y = 3;
float result = x / y; // Integer division
cout << result;        // Output: 3, not 3.33
```

**With Typecasting:**

```cpp
float result = (float)x / y; // Now x becomes float
cout << result;              // Output: 3.33333
```

### Types of Typecasting in C++
C++ supports **two main categories**:

|Type|Description|
|---|---|
|**Implicit (Automatic)**|Conversion done automatically by compiler|
|**Explicit (Manual)**|Conversion done manually by programmer|

#### 1. Implicit Typecasting (Type Promotion)
Also called **type promotion** or **automatic conversion**.  
C++ automatically converts a smaller data type to a larger one **to prevent data loss**.

##### üî∏ Example:

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 5;
    float b = 2.5;
    float c = a + b;  // int ‚Üí float automatically
    cout << c;
    return 0;
}
```

**Output:**

```
7.5
```

**Explanation:**

- `a` (int) is automatically converted to `float`

- Then addition happens in `float` precision

##### ‚úÖ Common Implicit Conversions

|From Type|To Type|
|---|---|
|`char` ‚Üí `int`|ASCII value|
|`int` ‚Üí `float`|Integer becomes floating-point|
|`float` ‚Üí `double`|Float promoted to double|
|`short` ‚Üí `int`|Small integers promoted|

#### 2. Explicit Typecasting (Manual Conversion)
Manual conversion is when the **programmer explicitly tells the compiler** to convert one type to another.

##### ‚úÖ Syntax (C-style casting):

```cpp
(data_type) expression
```

or

```cpp
data_type(expression)
```

##### üî∏ Example:

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 5, b = 2;
    float result;
	
    result = (float)a / b; // explicitly convert 'a' to float
    cout << result;
    
    int num = 100;
	cout << (char)num;   // Output: 'd' (ASCII 100)
    return 0;
}
```

**Output:**

```
2.5
```

Without typecasting, result would be `2`.

#### 3. C++ Style Typecasting (Safer and Preferred)
C++ introduced **four specialized casting operators** to make conversions safer and clearer than the old C-style cast.

|Cast Type|Syntax|Purpose|
|---|---|---|
|`static_cast`|`static_cast<type>(expr)`|General-purpose, safe conversions|
|`dynamic_cast`|`dynamic_cast<type>(expr)`|Used in inheritance (runtime checks)|
|`const_cast`|`const_cast<type>(expr)`|Adds/removes `const` qualifier|
|`reinterpret_cast`|`reinterpret_cast<type>(expr)`|Reinterprets bit patterns (advanced use)|

##### 1. static_cast
Used for most normal type conversions (like int ‚Üî float).

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 7, b = 2;
    float result = static_cast<float>(a) / b;
    cout << result;
    return 0;
}
```

**Output:**

```
3.5
```

> ‚úÖ Safe and recommended replacement for `(float)a`.

##### 2. const_cast
Used to **remove or add** `const` from a variable.

```cpp
#include <iostream>
using namespace std;

int main() {
    const int x = 10;
    int* ptr = const_cast<int*>(&x);
    *ptr = 20;
    cout << *ptr;
    return 0;
}
```

‚ö†Ô∏è **Warning:** Modifying const data is _undefined behavior_, use only in low-level cases.

##### 3. reinterpret_cast
Used for **low-level bit reinterpretation**, e.g., converting a pointer of one type to another.

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 512;
    int* p = &a;
    char* ch = reinterpret_cast<char*>(p);
    cout << *ch;
    return 0;
}
```

> ‚ö†Ô∏è Used mostly in **system programming** (rarely in high-level apps).

##### 4. dynamic_cast
Used for **safe downcasting** in **inheritance** (runtime type check).

```cpp
#include <iostream>
using namespace std;

class Base { public: virtual void show() {} };
class Derived : public Base { public: void show() { cout << "Derived"; } };

int main() {
    Base* b = new Derived;
    Derived* d = dynamic_cast<Derived*>(b);
    if (d) d->show();
    return 0;
}
```

**Output:**

```
Derived
```

> `dynamic_cast` ensures the pointer is valid before casting.

### üìú Typecasting Rules

|Rule|Description|
|---|---|
|1|Smaller types are promoted automatically (implicit).|
|2|Explicit cast takes precedence over implicit.|
|3|You can‚Äôt convert incompatible types directly (e.g., `string` ‚Üí `int`).|
|4|Prefer `static_cast` over C-style casts for clarity.|
|5|Avoid using `reinterpret_cast` unless you know what you‚Äôre doing.|

### Example 
#### üî∏ Mixed-Type Expression

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 5;
    double b = 2.0;
    double c = a / b;    // implicit type conversion (int ‚Üí double)
    cout << c;
    return 0;
}
```

**Output:**

```
2.5
```

> The compiler automatically promotes `a` to `double` before division.

#### üî∏ Loss of Data During Conversion

```cpp
float f = 3.99;
int i = (int)f;
cout << i;
```

**Output:**

```
3
```

> Fractional part is lost ‚Äî conversion **truncates** decimal values.

#### üî∏ Typecasting with Characters

```cpp
char ch = 'A';
int code = static_cast<int>(ch);
cout << code;
```

**Output:**

```
65
```

#### üî∏ Typecasting in Expressions

```cpp
int x = 7, y = 2;
float result = (float)(x + y) / 2;
cout << result;
```

**Output:**

```
4.5
```

### üîπ Summary

|Conversion Type|Description|Example|Modern C++ Form|
|---|---|---|---|
|Implicit|Done automatically|`int a=5; float b=a;`|‚Äì|
|Explicit (C-style)|Manual conversion|`(float)a / b`|‚ùå (use static_cast)|
|`static_cast`|Safe, general-purpose|`static_cast<float>(a)`|‚úÖ Recommended|
|`dynamic_cast`|Runtime-safe for inheritance|`dynamic_cast<Derived*>(basePtr)`|For OOP|
|`const_cast`|Removes constness|`const_cast<int*>(&x)`|Advanced|
|`reinterpret_cast`|Bit-level re-interpretation|`reinterpret_cast<char*>(ptr)`|Low-level|

---

## Operators in C++
An **operator** is a **symbol** that tells the compiler to perform a **specific operation** on one or more operands (variables, constants, or expressions).

> Simply: Operators are used to perform _mathematical, logical, or relational operations_ in C++.

**Example:**

```cpp
int a = 10, b = 5;
int sum = a + b;  // '+' is an operator, a and b are operands
```

### Classification of Operators
C++ has several categories of operators:

|Category|Description|
|---|---|
|1. Arithmetic Operators|Mathematical operations|
|2. Relational Operators|Comparison between values|
|3. Logical Operators|Combine or invert logical conditions|
|4. Assignment Operators|Assign values to variables|
|5. Increment/Decrement Operators|Increase or decrease value by 1|
|6. Bitwise Operators|Operations on bits|
|7. Conditional (Ternary) Operator|Shorthand for `if-else`|
|8. sizeof Operator|Returns memory size of variable/type|
|9. Comma Operator|Evaluates multiple expressions|
|10. Miscellaneous Operators|Includes pointer, address, scope, etc.|

#### 1. Arithmetic Operators
Used to perform **basic mathematical operations**.

|Operator|Meaning|Example|Result|
|---|---|---|---|
|`+`|Addition|`5 + 2`|7|
|`-`|Subtraction|`5 - 2`|3|
|`*`|Multiplication|`5 * 2`|10|
|`/`|Division|`5 / 2`|2|
|`%`|Modulus (remainder)|`5 % 2`|1|

**Example:**

```cpp
int a = 9, b = 4;
cout << a + b << endl;   // 13
cout << a - b << endl;   // 5
cout << a * b << endl;   // 36
cout << a / b << endl;   // 2
cout << a % b << endl;   // 1
```

> ‚ö†Ô∏è Division of two integers always gives an **integer result**.  
> Use **typecasting** to get a floating-point result:  
> `float result = (float)a / b;`

#### 2. Increment and Decrement Operators
Used to **increase or decrease** a variable‚Äôs value by 1.

|Operator|Meaning|
|---|---|
|`++`|Increment|
|`--`|Decrement|

They come in **two forms**:

|Type|Example|When Increment Happens|
|---|---|---|
|**Pre-Increment**|`++x`|Before using the variable|
|**Post-Increment**|`x++`|After using the variable|

**Example:**

```cpp
int a = 5;
cout << ++a; // 6 (increment, then print)
cout << a++; // 6 (print, then increment)
cout << a;   // 7
```

> Same logic applies for `--a` and `a--`.

#### 3. Relational Operators
Used to **compare two values**.  
They return either **true (1)** or **false (0)**.

| Operator | Meaning          | Example  | Result |
| -------- | ---------------- | -------- | ------ |
| `==`     | Equal to         | `5 == 3` | 0      |
| `!=`     | Not equal to     | `5 != 3` | 1      |
| `>`      | Greater than     | `5 > 3`  | 1      |
| `<`      | Less than        | `5 < 3`  | 0      |
| `>=`     | Greater or equal | `5 >= 3` | 1      |
| `<=`     | Less or equal    | `5 <= 3` | 0      |

**Example:**

```cpp
int a = 10, b = 20;
cout << (a > b);   // 0
cout << (a != b);  // 1
```

#### 4. Logical Operators
Used to **combine conditions** (mostly in `if`, `while`, `for`).

| Operator | Meaning     | Example             | Result     |
| -------- | ----------- | ------------------- | ---------- |
| `&&`     | Logical AND | `(5 > 2 && 5 < 10)` | true       |
| `        |             | `                   | Logical OR |
| `!`      | Logical NOT | `!(5 > 10)`         | true       |

**Example:**

```cpp
int a = 5, b = 10;
if (a < b && b < 20)
    cout << "Condition True";
```

**Output:**

```
Condition True
```

#### 5. Assignment Operators
Used to **assign or update values** of variables.

|Operator|Example|Equivalent To|
|---|---|---|
|`=`|`a = 5`|Assigns 5 to a|
|`+=`|`a += 3`|`a = a + 3`|
|`-=`|`a -= 2`|`a = a - 2`|
|`*=`|`a *= 4`|`a = a * 4`|
|`/=`|`a /= 2`|`a = a / 2`|
|`%=`|`a %= 3`|`a = a % 3`|

**Example:**

```cpp
int x = 10;
x += 5;  // x = 15
x *= 2;  // x = 30
cout << x;
```

#### 6. Bitwise Operators
Operate directly on **binary bits** of integers.  
Used in low-level programming, embedded systems, and performance-critical code.

|Operator|Name|Meaning|Example|
|---|---|---|---|
|`&`|AND|1 if both bits are 1|`5 & 3 ‚Üí 1`|
|`|`|OR|1 if any bit is 1|
|`^`|XOR|1 if bits differ|`5 ^ 3 ‚Üí 6`|
|`~`|NOT|Inverts bits|`~5 ‚Üí -6`|
|`<<`|Left Shift|Shifts bits left|`5 << 1 ‚Üí 10`|
|`>>`|Right Shift|Shifts bits right|`5 >> 1 ‚Üí 2`|

**Example:**

```cpp
int a = 5, b = 3;
cout << (a & b) << endl;  // 1
cout << (a | b) << endl;  // 7
cout << (a ^ b) << endl;  // 6
cout << (~a) << endl;     // -6
cout << (a << 1) << endl; // 10
cout << (a >> 1) << endl; // 2
```

#### 7. Conditional (Ternary) Operator

Used as a **shorthand for if-else**.

**Syntax:**

```cpp
condition ? expression_if_true : expression_if_false;
```

**Example:**

```cpp
int a = 10, b = 20;
int max = (a > b) ? a : b;
cout << "Max: " << max;
```

**Output:**

```
Max: 20
```

#### 8. sizeof Operator
Returns the **size (in bytes)** of a data type or variable.

**Example:**

```cpp
cout << sizeof(int) << endl;
cout << sizeof(float) << endl;
cout << sizeof(double) << endl;
cout << sizeof(char);
```

**Output (may vary by compiler):**

```
4
4
8
1
```

#### 9. Comma Operator

Used to **separate multiple expressions**, evaluates all from left to right, and returns the value of the **last expression**.

**Example:**

```cpp
int a, b;
a = (b = 3, b + 2);
cout << a; // Output: 5
```

#### 10. Miscellaneous Operators

|Operator|Name|Description|Example|
|---|---|---|---|
|`&`|Address-of|Gives memory address|`&a`|
|`*`|Dereference|Access value at address|`*ptr`|
|`::`|Scope Resolution|Access global variable or class member|`::x`|
|`->`|Arrow Operator|Access member via pointer|`ptr->age`|
|`.`|Dot Operator|Access member of object|`obj.name`|
|`new`|Dynamic Allocation|Allocates memory|`int *p = new int;`|
|`delete`|Deallocation|Frees memory|`delete p;`|

### ‚úÖ Operator Precedence and Associativity
When multiple operators appear in one expression, **precedence** decides _which one executes first_, and **associativity** decides _execution order_ for same-precedence operators.

![[Screenshot From 2025-10-26 19-36-06.png]]

**Example:**

```cpp
int x = 10, y = 5, z = 2;
int result = x + y * z;   // Multiplication first
cout << result;           // Output: 20
```

### üîπ Summary

|Operator Type|Example|Purpose|
|---|---|---|
|Arithmetic|`a + b`|Math operations|
|Relational|`a > b`|Compare values|
|Logical|`a && b`|Combine conditions|
|Assignment|`a += 2`|Update variable|
|Increment/Decrement|`++a`|Change by 1|
|Bitwise|`a & b`|Bit manipulation|
|Ternary|`a > b ? a : b`|Conditional|
|sizeof|`sizeof(a)`|Memory size|
|Comma|`(a = 3, b = 5)`|Evaluate multiple expressions|

---

## <mark style="background: #BBFABBA6;">Day 3 - Class notes</mark>
```C++
#include <iostream>
#include <cmath>

using namespace std;

int main() {
    // Conditional Statement
    int age;
    cout << "Enter your age: ";
    cin >> age;
    if (age > 18) {
        cout << "You can vote!\n";
    } else {
        cout << "You can't vote!\n";
    }
    cout << "Thank you :)\n";
	
    cout << "--------------------\n";
	
    // Practice Q1: Print the largest of 2 number.
    int num1, num2;
    cout << "Enter two numbers (separated with space): ";
    cin >> num1 >> num2;
    if (num1 > num2) {
        cout << num1 << " is the largest!\n";
    } else if (num1 < num2) {
        cout << num2 << " is the largest!\n";
    } else {
        cout << "Both are same!\n";
    }
	
    cout << "--------------------\n";
	
    // practice Q2: Print if a number is even or, odd.
    int num3;
    cout << "Enter a number (even or, odd): ";
    cin >> num3;
    if (num3 % 2 == 0) {
        cout << num3 << " is even!\n";
    } else {
        cout << num3 << " is odd!\n";
    }
	
    cout << "--------------------\n";
	
    // Practice Q3: Build a basic income tax calculator.
    float income, tax = 0;
    cout << "Income Tax Calculator!\nEnter your income (in rupee): ";
    cin >> income;
    if (income >= 500000 && income < 1000000) {
        tax = income * 0.2;
    } else if (income >= 1000000) {
        tax = income * 0.3;
    }
    cout << "Your tax will be: " << tax << " rupee(s) only.\n";
	
    cout << "--------------------\n";
	
    // Practice Q4: Print the largest of 3 number.
    float num4, num5, num6, largest;
    cout << "Enter three numbers (separated with space): ";
    cin >> num4 >> num5 >> num6;
    if (num4 >= num5 && num4 >= num6) {
        largest = num4;
    } else if (num5 >= num6) {
        largest = num5;
    } else {
        largest = num6;
    }
    cout << largest << " is the largest!\n";
	
    cout << "--------------------\n";
	
    // ternary operator
    bool isAdult = (age >= 18) ? true : false;
    cout << "isAdult: " << (isAdult ? "true" : "false") << endl;
	
    cout << "--------------------\n";
	
    float operand1, operand2, ans;
    char op;
    cout << "Calculator\n";
    cin >> operand1 >> op >> operand2;
    switch (op) {
    case '+': cout << "Answer: " << operand1 + operand2 << endl;
        break;
    case '-': cout << "Answer: " << operand1 - operand2 << endl;
        break;
    case '*': cout << "Answer: " << operand1 * operand2 << endl;
        break;
    case '/': cout << "Answer: " << operand1 / operand2 << endl;
        break;
    case '%': cout << "Answer: " << (int)operand1 % (int)operand2 << endl;
        break;
    case '^': cout << "Answer: " << pow(operand1, operand2) << endl;
        break;
    default: "Invalid operation!";
        break;
    }
    return 0;
}
```

---

## Conditional Statements in C++
Conditional statements allow a program to make **decisions** and execute different blocks of code based on whether a specified condition is **true or false**.  
In C++, these conditions are evaluated using **Boolean expressions** (`true` or `false`).

### Types of Conditional Statements
C++ provides several forms of conditional statements:

#### (a) `if` Statement
Used to execute a block of code **only if** the condition is true.

**Syntax:**

```cpp
if (condition) {
    // code to execute if condition is true
}
```

**Example:**

```cpp
int age = 18;
if (age >= 18) {
    cout << "You are eligible to vote.";
}
```

#### (b) `if-else` Statement
Used when there are **two possible outcomes** ‚Äî one if the condition is true, another if it‚Äôs false.

**Syntax:**

```cpp
if (condition) {
    // executes if condition is true
} else {
    // executes if condition is false
}
```

**Example:**

```cpp
int number = 5;
if (number % 2 == 0) {
    cout << "Even number";
} else {
    cout << "Odd number";
}
```

#### (c) `if-else-if` Ladder
Used when you need to check **multiple conditions sequentially**.  
As soon as one condition is true, the corresponding block executes, and the rest are skipped.

**Syntax:**

```cpp
if (condition1) {
    // code
} else if (condition2) {
    // code
} else if (condition3) {
    // code
} else {
    // default block
}
```

**Example:**

```cpp
int marks = 85;
if (marks >= 90) {
    cout << "Grade A";
} else if (marks >= 75) {
    cout << "Grade B";
} else if (marks >= 60) {
    cout << "Grade C";
} else {
    cout << "Fail";
}
```

#### (d) Nested `if` Statement
An `if` statement placed **inside another `if` or `else` block**.  
Used for **multiple levels of decision making**.

**Syntax:**

```cpp
if (condition1) {
    if (condition2) {
        // executes if both conditions are true
    }
}
```

**Example:**

```cpp
int age = 20;
char gender = 'M';
if (age > 18) {
    if (gender == 'M') {
        cout << "Adult Male";
    } else {
        cout << "Adult Female";
    }
}
```

#### (e) `switch` Statement
Used for **multi-way branching** when you have a variable that can take **multiple discrete values**.  
It is often a cleaner alternative to a long `if-else-if` ladder.

**Syntax:**

```cpp
switch (expression) {
    case constant1:
        // code
        break;
    case constant2:
        // code
        break;
    ...
    default:
        // code
}
```

**Example:**

```cpp
int day = 3;
switch (day) {
    case 1:
        cout << "Monday";
        break;
    case 2:
        cout << "Tuesday";
        break;
    case 3:
        cout << "Wednesday";
        break;
    default:
        cout << "Invalid day";
}
```

> **Note:**
> The `break` statement prevents ‚Äúfall-through‚Äù (i.e., running into the next case unintentionally).
> The `default` case is optional but recommended.     

#### (f) Conditional (Ternary) Operator

A **shortcut for `if-else`** ‚Äî used for concise expressions.

**Syntax:**

```cpp
(condition) ? expression_if_true : expression_if_false;
```

**Example:**

```cpp
int a = 10, b = 20;
int max = (a > b) ? a : b;
cout << "Maximum = " << max;
```

### üîë Key Points

- Always use braces `{}` for clarity, even for single statements.

- Ensure every `if` has a clear logical condition.

- The `switch` statement only works with **integral** or **enumeration types** (like `int`, `char`, `enum`), not `float` or `string`.

- Avoid deep nesting; it reduces code readability.

### üîπ Summary

|Statement Type|Use Case|Example Keyword|
|---|---|---|
|`if`|Single condition check|`if (x > 0)`|
|`if-else`|Two possible outcomes|`else`|
|`if-else-if` ladder|Multiple conditional paths|`else if`|
|Nested `if`|Condition inside another condition|Nested blocks|
|`switch`|Multi-choice using discrete values|`switch-case`|
|Ternary operator|Compact conditional expression|`?:`|

---

## <mark style="background: #BBFABBA6;">Day 4 - Class notes</mark>
```C++
#include <iostream>
#include <cmath>

using namespace std;

int main() {
    // For loop
    for (int i = 1; i <= 5; i++) {
        cout << i << "\n";
    }
	
    cout << "-----------------\n";
	
    // Practice Q1: Print your name 5 times
    for (int i = 0; i < 5; i++) {
        cout << "Sankhadeep Pal\n";
    }
	
    cout << "-----------------\n";
	
    // Practice Q2: Print N natural numbers
    int num1;
    cout << "Enter a number: ";
    cin >> num1;
    for (int i = 1; i <= num1; i++) {
        cout << i << "\n";
    }
	
    cout << "-----------------\n";
	
    // Practice Q3: Print sum of N natural numbers
    int num2, sum1;
    cout << "Enter a number: ";
    cin >> num2;
    for (int i = 1; i <= num2; i++) {
        sum1 += i;
        (i == num2) ? cout << i : cout << i << " + ";
    }
    cout << " = " << sum1 << "\n";
	
    cout << "-----------------\n";
	
    // While loop
    int count1 = 1;
    while (count1 <= 10) {
        cout << count1 << "\n";
        count1++;
    }
	
    cout << "-----------------\n";
	
    // Practice Q4: print this square pattern using for loop:
    // ****
    // ****
    // ****
    // ****
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            cout << "* ";
        }
        cout << "\n";
    }
	
    cout << "-----------------\n";
	
    // Practice Q5: print numbers from n to 1 using for loop
    int num3;
    cout << "Enter a number: ";
    cin >> num3;
    for (int i = num3; i > 0; i--) {
        cout << i << " ";
    }
    cout << "\n";
	
    cout << "-----------------\n";
	
    // Practice Q6: Print the sum of digits of a number.
    int num4, sum2 = 0;
    cout << "Enter a number: ";
    cin >> num4;
    while (num4 != 0) {
        sum2 += num4 % 10;
        num4 /= 10;
    }
    cout << "sum of digit(s): " << sum2 << "\n";
	
    cout << "-----------------\n";
	
    // Practice Q7: Print the sum of odd digits of a number.
    int num5, sum3 = 0, digit;
    cout << "Enter a number: ";
    cin >> num5;
    while (num5 != 0) {
        digit = num5 % 10;
        if (digit % 2 != 0) {
            sum3 += num5 % 10;
        }
        num5 /= 10;
    }
    cout << "sum of odd digit(s): " << sum3 << "\n";
	
    cout << "-----------------\n";
	
    // Do-while loop
    int count2 = 1;
    do {
        cout << count2 << " ";
        count2++;
    } while (count2 <= 5);
    cout << "\n";
	
    cout << "-----------------\n";
	
    // Practice Q8: WAP where user can keep entering numbers till they enter a multiple of 10.
    int num6;
    while (true) {
        cout << "Enter a number: ";
        cin >> num6;
        if (num6 % 10 == 0) {
            break;
        }
    }
	
    cout << "-----------------\n";
	
    // Practice Q9: WAP to show numbers enters by the user except multiple of 10.
    int num7, count3 = 1;
    while (count3 <= 10) {
        cout << "Enter a number: ";
        cin >> num7;
        count3++;
        if (num7 % 10 == 0) {
            continue;
        }
        cout << "You entered: " << num7 << "\n";
    }
	
    cout << "-----------------\n";
	
    // Practice Q10: check if a number is prime or not.
    int num8, count4 = 0;
    cout << "Enter a number: ";
    cin >> num8;
    for (int i = 2; i <= sqrt(num8); i++) {
        if (num8 % i == 0) {
            count4++;
            break;
        }
    }
    cout << num8 << " is" << ((count4 == 0) ? " " : " not ") << "a prime!\n";
    return 0;
}

```

---

## Loops in C++
A **loop** is a control structure that allows a block of code to be executed **repeatedly** as long as a specified **condition** remains **true**.
It is one of the most powerful constructs in programming, used to perform repetitive tasks efficiently.

### üè≥Ô∏è Purpose of Loops
Loops help in:

* **Reducing code redundancy**
* **Automating repetitive tasks**
* **Improving readability and maintainability**

### Types of Loops in C++
C++ provides **three main types** of loops:

1. `for` loop
2. `while` loop
3. `do-while` loop

Let‚Äôs break down each.

#### 1. `for` Loop
The `for` loop is used when the **number of iterations is known** beforehand.

##### ‚úÖ Syntax:

```cpp
for (initialization; condition; update) {
    // code to execute repeatedly
}
```

##### ‚ùì How It Works:

1. **Initialization:** Executes once at the start (e.g., setting a counter).
2. **Condition:** Checked before every iteration. If true, the loop runs; if false, it stops.
3. **Update:** Executes after each iteration (e.g., increment or decrement).

##### üî∏ Example:

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 1; i <= 5; i++) {
        cout << "Iteration " << i << endl;
    }
    return 0;
}
```

**Output:**

```
Iteration 1
Iteration 2
Iteration 3
Iteration 4
Iteration 5
```

#### 2. `while` Loop
The `while` loop is used when the **number of iterations is not known in advance**, and you want to loop **until a condition becomes false**.

##### ‚úÖ Syntax:

```cpp
while (condition) {
    // code to execute repeatedly
}
```

##### üî∏ Example:

```cpp
int i = 1;
while (i <= 5) {
    cout << "Count: " << i << endl;
    i++;
}
```

**Output:**

```
Count: 1
Count: 2
Count: 3
Count: 4
Count: 5
```

> ‚ö†Ô∏è If the condition never becomes false, it results in an **infinite loop**.

#### 3. `do-while` Loop
The `do-while` loop is similar to `while`, but it **executes the loop body at least once**, even if the condition is false.

##### ‚úÖ Syntax:

```cpp
do {
    // code to execute
} while (condition);
```

##### üî∏ Example:

```cpp
int i = 1;
do {
    cout << "Number: " << i << endl;
    i++;
} while (i <= 5);
```

**Output:**

```
Number: 1
Number: 2
Number: 3
Number: 4
Number: 5
```

### üÜö Comparison Between Loops

| Feature             | `for` Loop                 | `while` Loop                 | `do-while` Loop        |
| ------------------- | -------------------------- | ---------------------------- | ---------------------- |
| **When used**       | Number of iterations known | Number of iterations unknown | Must run at least once |
| **Condition check** | Before each iteration      | Before each iteration        | After each iteration   |
| **Structure**       | Compact (all in one line)  | More flexible                | Ensures one execution  |

### Nested Loops
A **loop inside another loop** is called a **nested loop**.
Commonly used for **2D arrays**, **patterns**, or **matrix operations**.

#### üî∏ Example:

```cpp
for (int i = 1; i <= 3; i++) {
    for (int j = 1; j <= 3; j++) {
        cout << "(" << i << ", " << j << ") ";
    }
    cout << endl;
}
```

**Output:**

```
(1, 1) (1, 2) (1, 3)
(2, 1) (2, 2) (2, 3)
(3, 1) (3, 2) (3, 3)
```

### Control Statements in Loops
C++ provides **loop control statements** to manage loop execution flow:

#### (a) `break` Statement
Used to **terminate** the loop immediately, even if the condition is true.

**Example:**

```cpp
for (int i = 1; i <= 10; i++) {
    if (i == 5)
        break;
    cout << i << " ";
}
```

**Output:**

```
1 2 3 4
```

#### (b) `continue` Statement
Used to **skip the rest of the code** in the current iteration and move to the **next iteration**.

**Example:**

```cpp
for (int i = 1; i <= 5; i++) {
    if (i == 3)
        continue;
    cout << i << " ";
}
```

**Output:**

```
1 2 4 5
```

---

#### (c) `goto` Statement
Transfers control to a labeled statement.
It can make code hard to read and maintain, so avoid it.

**Example:**

```cpp
int i = 1;
loop:
if (i <= 5) {
    cout << i << " ";
    i++;
    goto loop;
}
```

**Output:**

```
1 2 3 4 5
```

>  ‚ö†Ô∏è *Rarely used, discouraged in modern C++*
 
### Infinite Loops
If the loop‚Äôs condition never becomes false, it will run forever ‚Äî an **infinite loop**.

**Example:**

```cpp
while (true) {
    cout << "Running forever!";
}
```

Use infinite loops carefully, usually for **servers**, **game loops**, or **continuous monitoring systems**.

### üîπ Summary

| Loop Type  | Condition Check | Executes At Least Once | Typical Use Case           |
| ---------- | --------------- | ---------------------- | -------------------------- |
| `for`      | Before loop     | No                     | Known number of iterations |
| `while`    | Before loop     | No                     | Condition-based looping    |
| `do-while` | After loop      | Yes                    | Menu-driven programs       |
| `nested`   | Multiple levels | Depends                | Matrices, patterns         |

---

