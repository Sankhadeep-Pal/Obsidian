# [JavaScript Tutorial](https://www.apnacollege.in/path-player?courseid=sigma-8&unit=685ffaa6e566eeb1db05a05dUnit)

## What is JavaScript?

**JavaScript** is a high-level, interpreted programming language that is primarily used to make web pages interactive. It is one of the core technologies of the web, alongside **HTML** and **CSS**.

### Key Features:

- **Client-side scripting**: JavaScript runs in the browser, allowing dynamic changes to content, form validation, interactive maps, animations, and more.

- **Lightweight and interpreted**: It doesn't need to be compiled before running.

- **Event-driven**: JavaScript can respond to user actions like clicks, key presses, or mouse movements.

- **Object-oriented and functional**: Supports both styles of programming.

- **Runs everywhere**: Supported by all modern web browsers without needing additional plugins.

### Common Uses:

- Updating content dynamically without reloading the page (AJAX)

- Form validation before sending data to the server

- Creating interactive UI components (dropdowns, sliders, modals)

- Building web apps (e.g., using frameworks like React, Vue, or Angular)

- Server-side development with Node.js

---

## Variables in JavaScript
A **variable** is a **container for storing data** in a program. You can think of it like a labeled box that holds a value ‚Äî such as a number, a string of text, or even a more complex structure like an object or an array.

### üß† In simple terms:

> A variable lets you **give a name** to some data so you can **use it later**.

### üí° Example in JavaScript:

```javascript
let name = "Alice";
let age = 25;
let isStudent = true;
```

Here:

- `name` is a variable storing the string `"Alice"`

- `age` is a variable storing the number `25`

- `isStudent` is a variable storing the boolean value `true`

### Why are variables important?

Variables allow your code to:

- Store user input

- Keep track of data (like scores in a game)

- React to changes over time

- Avoid repeating values

---

## Datatypes in JavaScript
In **JavaScript**, **data types** define the kind of value a variable can hold. They are grouped into **primitive types** and **reference types (objects)**.

### 1. Primitive Data Types
These are simple, single values ‚Äî not objects ‚Äî and are **immutable**.

|Type|Example|Description|
|---|---|---|
|`String`|`"Hello"`|Text data|
|`Number`|`42`, `3.14`|Integer or floating point numbers|
|`Boolean`|`true`, `false`|Logical values|
|`Undefined`|`let x;`|A variable declared but not assigned|
|`Null`|`let x = null;`|Explicitly no value|
|`Symbol`|`Symbol("id")`|Unique identifiers (advanced use)|
|`BigInt`|`12345678901234567890n`|Very large integers|

#### ‚úÖ Examples:

```javascript
let name = "Alice";       // String
let age = 30;             // Number
let isHappy = true;       // Boolean
let address;              // Undefined
let score = null;         // Null
let id = Symbol("id");    // Symbol
let big = 123456789012345678901234567890n; // BigInt
```

### 2. Reference (Object) Data Types
These hold **collections of values** or more **complex structures**.

| Type       | Example                      | Description            |
| ---------- | ---------------------------- | ---------------------- |
| `Object`   | `{ name: "Alice", age: 30 }` | Key-value pairs        |
| `Array`    | `[1, 2, 3]`                  | Ordered list           |
| `Function` | `function() {}`              | Reusable block of code |
| `Date`     | `new Date()`                 | Date and time          |

#### ‚úÖ Examples:

```javascript
let user = { name: "Alice", age: 30 }; // Object
let numbers = [10, 20, 30];            // Array
function greet() {
  console.log("Hi!");
}                                      // Function
let today = new Date();                // Date object
```

### Check a variable‚Äôs type:
Use `typeof`:

```javascript
typeof "Hello";       // "string"
typeof 42;            // "number"
typeof {};            // "object"
typeof [];            // "object" (arrays are objects)
typeof null;          // "object" (weird JS quirk)
```

---

## Primitive Datatypes

### Numbers
In **JavaScript**, **numbers** are one of the fundamental data types and are used to represent both integers and floating-point (decimal) values.

#### ‚úÖ 1. Integer and Floating-Point
JavaScript uses the same type (`number`) for:

- **Integers**: `1`, `100`, `-42`

- **Decimals**: `3.14`, `-0.001`

```javascript
let age = 25;
let price = 19.99;
```

#### ‚úÖ 2. Special Number Values

|Value|Description|
|---|---|
|`Infinity`|Greater than any number (`1 / 0`)|
|`-Infinity`|Less than any number (`-1 / 0`)|
|`NaN`|"Not-a-Number" (e.g., `"abc" / 2`)|

```javascript
console.log(1 / 0);         // Infinity
console.log("abc" * 3);     // NaN
```

#### ‚ûï Arithmetic Operations

|Operation|Symbol|Example|Result|
|---|---|---|---|
|Add|`+`|`5 + 3`|`8`|
|Subtract|`-`|`5 - 3`|`2`|
|Multiply|`*`|`5 * 3`|`15`|
|Divide|`/`|`6 / 2`|`3`|
|Modulus|`%`|`5 % 2`|`1`|
|Exponent|`**`|`2 ** 3`|`8`|

#### üîÑ Type Conversion
JavaScript is loosely typed, so numbers can mix with strings ‚Äî but results can be tricky:

```javascript
"5" + 2      // "52"  (string + number = string)
"5" - 2      // 3     (coerced to number)
"5" * "2"    // 10    (coerced to number)
```

Use `Number()`, `parseInt()`, or `parseFloat()` to convert:

```javascript
Number("123");       // 123
parseInt("10px");    // 10
parseFloat("3.14");  // 3.14
```

#### üî¢ BigInt (for large numbers)
If you need to work with very large integers beyond `2^53 - 1`:

```javascript
let big = 123456789012345678901234567890n;
```

---

### Booleans
The **Boolean** data type in JavaScript represents **one of two values**:

```javascript
true    // yes, correct, on
false   // no, incorrect, off
```

Booleans are often used in **conditions**, **comparisons**, and **control structures** like `if` statements.

#### Examples:

```javascript
let isRaining = true;
let hasLicense = false;
```

#### Boolean Results from Comparisons:

```javascript
5 > 3        // true
10 === 5     // false
"cat" !== "dog"  // true
```

#### Truthy and Falsy Values
In JavaScript, **non-boolean values can behave like booleans** in conditions.

##### ‚ùå **Falsy values (evaluated as `false`):**

- `false`

- `0`

- `""` (empty string)

- `null`

- `undefined`

- `NaN`

##### ‚úÖ **Truthy values:**

- Anything else: non-zero numbers, non-empty strings, objects, arrays, etc.

```javascript
if ("hello") {
  console.log("This is truthy!");  // This will run
}
```

#### Boolean Conversion
You can convert a value to a boolean using:

```javascript
Boolean(0);       // false
Boolean("hi");    // true
Boolean(null);    // false
```

Or by using double NOT:

```javascript
!!"text"          // true
!!0               // false
```

#### Boolean Logic Operators:

| Operator | Name | Example          | Result  |
| -------- | ---- | ---------------- | ------- |
| `&&`     | AND  | `true && false`  | `false` |
| \| \|    | OR   | true \| \| false | `true`  |
| `!`      | NOT  | `!true`          | `false` |

---

### Strings
In **JavaScript**, a **string** is a sequence of **characters** (letters, numbers, symbols, etc.) used to represent **text**. Strings are **immutable** in nature.

#### How to Declare Strings
You can create strings using:

```javascript
let name = "Alice";      // double quotes
let city = 'Paris';      // single quotes
let message = `Hello`;   // backticks (template literals)
```

All three are valid, but **backticks** offer special powers.

#### Common String Examples:

```javascript
let greeting = "Hello, world!";
let answer = 'Yes!';
let emoji = "üòä";
```

#### String Operations

##### ‚ûï **Concatenation (joining strings)**

```javascript
let firstName = "John";
let lastName = "Doe";
let fullName = firstName + " " + lastName;  // "John Doe"
```

##### üß© **Template Literals (with backticks)**
Use `${}` to insert variables into strings:

```javascript
let name = "Sara";
let age = 25;
let intro = `My name is ${name} and I am ${age} years old.`;
```

##### üî¢ **String Indices in JavaScript**
A **string index** is the **position of a character** in a string. JavaScript strings are **zero-indexed**, meaning the **first character is at index 0**, the second at index 1, and so on.

```javascript
let word = "hello";
```

Use **square brackets `[]`** or `.charAt()` to access the index:

```javascript
console.log(word[0]);        // "h"
console.log(word.charAt(1)); // "e"
```

If index is out of range:

```javascript
console.log(word[10]);       // undefined
console.log(word.charAt(10)); // "" (empty string)
```

#### Common String Methods
We can chain multiple methods together. i.e `string.method1().method()`

| Method              | Description                    | Example                                 |
| ------------------- | ------------------------------ | --------------------------------------- |
| `length`            | Returns the length             | `"Hi".length ‚Üí 2`                       |
| `toUpperCase()`     | Converts to uppercase          | `"hello".toUpperCase()` ‚Üí `"HELLO"`     |
| `toLowerCase()`     | Converts to lowercase          | `"Hi".toLowerCase()` ‚Üí `"hi"`           |
| `includes()`        | Checks if substring exists     | `"apple".includes("pp")` ‚Üí `true`       |
| `indexOf()`         | Finds position of a substring  | `"cat".indexOf("a")` ‚Üí `1`              |
| `slice(start, end)` | Extracts part of string        | `"hello".slice(1, 4)` ‚Üí `"ell"`         |
| `replace()`         | Replaces part of string        | `"hello".replace("h", "y")` ‚Üí `"yello"` |
| `trim()`            | Removes whitespace from ends   | `" hi ".trim()` ‚Üí `"hi"`                |
| `repeat()`          | Repeat a string multiple times | `"hi.repeat(3)"` ‚Üí `"hihihi"`           |

#### Looping Through a String

```javascript
let str = "dog";
for (let i = 0; i < str.length; i++) {
  console.log(str[i]);
}
// Output: d, o, g
```

#### Strings are Immutable
You **can't change characters** in a string directly:

```javascript
let word = "cat";
word[0] = "b";    // ‚ùå Doesn't work
word = "bat";     // ‚úÖ Reassign a new value
```

---

### Null & Undefined
In JavaScript, `null` and `undefined` are **two distinct data types** that both represent the absence of a value ‚Äî but they are **not the same**.

#### üü° `undefined`

- A variable that **has been declared** but **not assigned a value**.

- JavaScript automatically assigns `undefined` to uninitialized variables.

```javascript
let x;
console.log(x);     // undefined
```

- Also returned by functions with no `return`:

```javascript
function doNothing() {}
console.log(doNothing());  // undefined
```

#### üî¥ `null`

- A value that **represents "no value"** or **"nothing"**, **explicitly assigned** by the developer.

- You use `null` when you **want to say**: ‚ÄúThis should have a value, but it doesn‚Äôt yet.‚Äù

```javascript
let y = null;
console.log(y);     // null
```

#### üîç Differences at a Glance:

|Feature|`undefined`|`null`|
|---|---|---|
|Type|`undefined`|`object` (weird legacy quirk)|
|Assigned by|JavaScript (default)|Developer (manually)|
|Meaning|"No value assigned yet"|"Intentionally empty"|
|Use case|Uninitialized variables|Empty/reset values|

#### ‚ö†Ô∏è Comparison:

```javascript
undefined == null     // true (loose equality)
undefined === null    // false (strict equality)
```

> üîë Use `===` for precise comparison in most real-world code.

#### ‚úÖ When to Use Each:

- Use `undefined` when JavaScript does it for you (e.g., uninitialized or missing values).

- Use `null` when **you decide** a value is currently empty or to **clear/reset** something.

---
## Reference Datatypes

### Arrays
In JavaScript, **arrays** are a special type of object used to store ordered collections of values. They can hold elements of any type, including numbers, strings, objects, other arrays, etc.

#### Declaring an Array

```javascript
let fruits = ['apple', 'banana', 'cherry'];
let numbers = [1, 2, 3, 4, 5];
let mixed = [1, 'hello', true, null];
let empty = [];
```

You can also create arrays using the `Array` constructor:

```javascript
let arr = new Array(5); // creates an empty array with length 5
```

#### Accessing Array Elements

```javascript
let colors = ['red', 'green', 'blue'];
console.log(colors[0]); // 'red'
console.log(colors[2]); // 'blue'
```

#### Common Array Methods

- `length` - Print the length of array
	 
```javascript
let arr = [1, 2, 3];
let len = arr.length; // 3
``` 

-  `push()` ‚Äì Add to end
	
```javascript
let arr = [1, 2];
arr.push(3); // [1, 2, 3]
```

-  `pop()` ‚Äì Remove from end
	
```javascript
let arr = [1, 2, 3];
arr.pop(); // returns 3; arr is now [1, 2]
```

-  `shift()` ‚Äì Remove from start
	
```javascript
let arr = [1, 2, 3];
arr.shift(); // returns 1; arr is now [2, 3]
```

-  `unshift()` ‚Äì Add to start
	
```javascript
let arr = [2, 3];
arr.unshift(1); // [1, 2, 3]
```

-  `splice()` ‚Äì Add/Remove at index
	
```javascript
let languages = ["C++", "Java", "JavaScript"];

let sliced = languages.splice(2); // Slicing with main array deletion.
console.log(sliced); // ["JavaScript"]
console.log(languages);	// ["C++", "Java"]

languages.splice(2, 0, "Rust", "Python"); // Adding/deleting at last (push, pop)
console.log(languages); // ["C++", "Java", "Rust", "Python"]

languages.splice(0, 0, "javaScript"); // Adding/deleting at first (unshift, shift)
console.log(languages); // ["JavaScript", "C++", "Java", "Rust", "Python"]

languages.splice(3, 1, "C"); // Replacing any element
console.log(languages); // ["JavaScript", "C++", "Java", "C", "Python"]

languages.splice(2, 0, "TypeScript", "Go"); // Adding in middle of array
console.log(languages); // ["JavaScript", "C++", "Go", "Java", "C", "Python"]
```

-  `slice()` ‚Äì Get part of array
	
```javascript
let allColors = ["red", "yellow", "blue", "violet", "pink", "white"]

console.log("array.slice(starting_index, ending_index)");

console.log(allColors.slice()); 
// ["red", "yellow", "blue", "violet", "pink", "white"];
// a copy of the full array

console.log(allColors.slice(1, 4)); 
// ["yellow", "blue", "violet"]
// 4th index doesn't include. (a copy of 1st to 3rd index)

console.log(allColors.slice(5));
// ["white"]
// ending_index = array.length.

console.log(allColors.slice(-3)); 
// ["violet", "pink", "white"]
// starting_index = array.length - 3 & ending_index = array.length.

console.log(allColors.slice(100)); 
// insufficient indices returns empty array
```

-  `indexOf()` ‚Äì Find index of value
	
```javascript
let arr = ['a', 'b', 'c'];
arr.indexOf('b'); // 1
```

-  `includes()` ‚Äì Check if exists
	
```javascript
let arr = [1, 2, 3];
arr.includes(2); // true
arr.includes(4); // false
```

-  `forEach()` ‚Äì Loop through elements
	
```javascript
let arr = [1, 2, 3];
arr.forEach(num => {
  console.log(num * 2); // 2, 4, 6
});
```

-  `map()` ‚Äì Transform elements
	
```javascript
let arr = [1, 2, 3];
let doubled = arr.map(n => n * 2); // [2, 4, 6]
```

-  `filter()` ‚Äì Keep elements that match condition
	
```javascript
let arr = [1, 2, 3, 4];
let evens = arr.filter(n => n % 2 === 0); // [2, 4]
```

-  `reduce()` ‚Äì Reduce to single value
	
```javascript
let arr = [1, 2, 3, 4];
let sum = arr.reduce((acc, curr) => acc + curr, 0); // 10
```

-  `join()` ‚Äì Combine elements into string
	
```javascript
let arr = ['a', 'b', 'c'];
arr.join('-'); // "a-b-c"
```

-  `sort()` ‚Äì Sort elements (as strings by default)
	
```javascript
let arr = [3, 1, 4, 2];
arr.sort(); // [1, 2, 3, 4] (numbers may not sort as expected without a compare function)

let names = ['Zoe', 'Adam', 'John'];
names.sort(); // ['Adam', 'John', 'Zoe']
```
	
   | Custom sort:
	
```javascript
arr.sort((a, b) => a - b); // numeric sort ascending
```

-  `reverse()` ‚Äì Reverse the array
	
```javascript
let arr = [1, 2, 3];
arr.reverse(); // [3, 2, 1]
```

- `every()` - Checks if **all elements** in an array satisfy a given condition (returns `true` or `false`).
	
```js
const numbers = [2, 4, 6, 8];
const allEven = numbers.every(num => num % 2 === 0);
console.log(allEven); // true
```

- `some()` - Checks if **at least one element** in the array satisfies the given condition.
	
```js
const numbers = [1, 3, 5, 6];
const hasEven = numbers.some(num => num % 2 === 0);
console.log(hasEven); // true
```

	 Use Cases

| Method  | When to Use                             | Result Interpretation                     |
| ------- | --------------------------------------- | ----------------------------------------- |
| `every` | Validate that **all items** meet a rule | Returns `true` only if all pass           |
| `some`  | Check if **any item** meets a rule      | Returns `true` if **at least one** passes |

#### Array References
In JavaScript, arrays are **reference types**, which means when you assign an array to another variable or pass it into a function, you're passing a **reference to the same array in memory**, not a copy of the array.

##### ‚úÖ **Example: Array Reference Behavior**

```javascript
let arr1 = [1, 2, 3];
let arr2 = arr1;

arr2[0] = 99;

console.log(arr1); // [99, 2, 3]
console.log(arr2); // [99, 2, 3]
```

**Why?** Because `arr2 = arr1` creates a reference to the same array in memory. Modifying `arr2` also modifies `arr1`.

##### üôÖ **How to Copy an Array (Avoid Reference)**
If you want to copy an array instead of referencing it:

1. **Spread Operator**
	
```javascript
let arr1 = [1, 2, 3];
let arr2 = [...arr1];
arr2[0] = 99;

console.log(arr1); // [1, 2, 3]
```

2. **`slice()` Method**
	
```javascript
let arr2 = arr1.slice();
```

3. **`Array.from()`**
	
```javascript
let arr2 = Array.from(arr1);
```

4. **`concat()`**
	
```javascript
let arr2 = [].concat(arr1);
```

##### üìù **Deep vs Shallow Copy**
All the methods above create a **shallow copy**‚Äîthey copy the top-level elements. If the array contains objects or other arrays, their references will still be shared.

```javascript
let arr1 = [{ a: 1 }];
let arr2 = [...arr1];

arr2[0].a = 99;

console.log(arr1); // [{ a: 99 }] ‚Äî shared reference to the object
```

To avoid this, you need a **deep copy**, often done with:

```javascript
let arr2 = JSON.parse(JSON.stringify(arr1)); // simple but limited method
```

Or using libraries like Lodash:

```javascript
let arr2 = _.cloneDeep(arr1);
```

#### Nested Arrays in JavaScript

In JavaScript, **nested arrays** are arrays that contain other arrays as elements. This is commonly used to represent **matrices**, **grids**, or **tree-like data structures**.

##### ‚úÖ **Basic Example**

```javascript
let nestedArray = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

console.log(nestedArray[0]);    // [1, 2, 3]
console.log(nestedArray[0][1]); // 2
```

##### üîÑ **Looping Through a Nested Array**

```javascript
for (let i = 0; i < nestedArray.length; i++) {
  for (let j = 0; j < nestedArray[i].length; j++) {
    console.log(`Element at [${i}][${j}]:`, nestedArray[i][j]);
  }
}
```

Or using `forEach`:

```javascript
nestedArray.forEach((row, i) => {
  row.forEach((value, j) => {
    console.log(`Element at [${i}][${j}]:`, value);
  });
});
```

##### ‚úèÔ∏è **Modifying Nested Array Values**

```javascript
nestedArray[1][2] = 99;
console.log(nestedArray); // [[1, 2, 3], [4, 5, 99], [7, 8, 9]]
```

##### üîç **Flattening a Nested Array**

1. One Level Deep
	
```javascript
let flat = nestedArray.flat();
console.log(flat); // [1, 2, 3, 4, 5, 99, 7, 8, 9]
```

2. Deeply Nested Example
	
```javascript
let deepNested = [1, [2, [3, [4]]]];
let flatAll = deepNested.flat(Infinity);
console.log(flatAll); // [1, 2, 3, 4]
```

##### üß† **Use Cases**

- **Matrices:** `matrix[row][col]`

- **Game Boards:** `board[y][x]`

- **Hierarchical Data:** Nested lists or trees

---

### Object Literals
In JavaScript, **object literals** are a way to create objects using a concise syntax. An object literal is a comma-separated list of key-value pairs enclosed in curly braces `{}`.

#### Basic Syntax

```javascript
const person = {
  name: "Alice",
  age: 30,
  isStudent: false
};
```

- `name`, `age`, and `isStudent` are **keys** (also called properties).

- `"Alice"`, `30`, and `false` are the corresponding **values**.

#### Object Property Manipulation
##### üéØ **Accessing Object Properties**
You can access properties using:

- **Dot notation**:
    
```javascript
console.log(person.name); // "Alice"
```

- **Bracket notation** (useful when the key is dynamic or not a valid identifier):
    
```javascript
console.log(person["age"]); // 30
```

‚≠ê‚≠ê‚≠ê<mark style="background: #ABF7F7A6;">Remember: </mark>‚≠ê‚≠ê‚≠ê
```javascript
// Unusual keys and values
const unusual = {
	1: "a",
	2: "b",
	3: "c",
	// 1null: "d", // throws error because, naming rules not followed
	null: "no_value", // then it throws error!!
	true: "truth",
	const: "constant",
	let: "variable",
};
console.log(unusual); // makes the keys a string.
console.log(unusual.null);
console.log(unusual[null]);

console.log(unusual[true]); // first true converted to string then compared.
// console.log(unusual[const]); // Why it throws error? = because it is a identifier and compiler thought you want to declare a variable
console.log(unusual["const"]);

// console.log(unusual.1); // throws error.
console.log(unusual.null); // why this works but not 1? = because 1 is not valid identifier but null is.

// Conclusion = valid identifiers, numbers, reserved keywords can be used a key (only, no naming rules should be broken) & on the other hand dot notation only handles valid identifiers and reserved keywords not numbers........ this is stupid!! It just shows the incompleteness of JS
```

##### ‚úçÔ∏è **Adding or Modifying Properties**

```javascript
person.job = "Developer";      // Add new property
person.age = 31;               // Modify existing property
```

##### ‚ûñ **Removing Properties**

```javascript
delete person.isStudent;
```

#### Multi level Objects
##### üî∂ **Methods in Object Literals**
You can include functions (methods) in objects:

```javascript
const calculator = {
  add(a, b) {
    return a + b;
  }
};

console.log(calculator.add(2, 3)); // 5
```

##### üî∂ **Nested Objects**

```javascript
const user = {
  name: "Bob",
  address: {
    city: "New York",
    zip: "10001"
  }
};

console.log(user.address.city); // "New York"
```

##### üî∂ **Array of Objects**
```javascript
Const users = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 22 }
];

console.log(users[0].name); // "Alice"
console.log(users[2].age);  // 22
```

#### Dynamic Property Names

You can use **computed property names**:

```javascript
const key = "score";
const game = {
  [key]: 100
};

console.log(game.score); // 100
```

---

## Keywords in JavaScript
In **JavaScript**, **keywords** are **reserved words** that have special meaning in the language. You **cannot use them as variable names**, function names, or identifiers.

### ‚úÖ Common JavaScript Keywords (with meanings)

| Learn | Keyword      | Description                                          | Example                         |
| :---: | ------------ | ---------------------------------------------------- | ------------------------------- |
|   ‚úÖ   | `var`        | Declares a variable (function-scoped, old style)     | `var x = 5;`                    |
|   ‚úÖ   | `let`        | Declares a block-scoped variable (modern)            | `let age = 25;`                 |
|   ‚úÖ   | `const`      | Declares a block-scoped constant                     | `const PI = 3.14;`              |
|       | `function`   | Declares a function                                  | `function greet() {}`           |
|       | `return`     | Returns a value from a function                      | `return x + y;`                 |
|   ‚úÖ   | `if`         | Starts a conditional block                           | `if (x > 5) { ... }`            |
|   ‚úÖ   | `else`       | Specifies code to run if `if` condition is false     | `else { ... }`                  |
|   ‚úÖ   | `switch`     | Conditional selection among multiple cases           | `switch(x) { case 1: ... }`     |
|       | `case`       | Defines a condition in a `switch` block              | `case 2: break;`                |
|   ‚úÖ   | `break`      | Exits a loop or switch                               | `break;`                        |
|       | `continue`   | Skips to the next loop iteration                     | `continue;`                     |
|   ‚úÖ   | `for`        | Starts a loop                                        | `for (let i = 0; i < 5; i++)`   |
|       | `while`      | Starts a loop that continues while condition is true | `while (i < 5) { ... }`         |
|       | `do`         | Like `while`, but runs at least once                 | `do { ... } while (i < 5);`     |
|       | `try`        | Starts a block to test for errors                    | `try { ... }`                   |
|       | `catch`      | Handles errors from `try`                            | `catch (error) { ... }`         |
|       | `finally`    | Runs after `try`/`catch` regardless of outcome       | `finally { ... }`               |
|       | `throw`      | Manually throws an error                             | `throw new Error("Oops")`       |
|       | `class`      | Declares a class                                     | `class Car {}`                  |
|       | `new`        | Creates an instance of an object                     | `new Date()`                    |
|       | `this`       | Refers to the current object                         | `this.name`                     |
|   ‚úÖ   | `typeof`     | Returns the type of a variable                       | `typeof "hello"`                |
|       | `delete`     | Deletes an object property                           | `delete obj.name;`              |
|       | `in`         | Checks if property exists in object                  | `"name" in obj`                 |
|       | `instanceof` | Checks if object is an instance of a class           | `obj instanceof Car`            |
|       | `void`       | Evaluates expression without returning value         | `void(0)`                       |
|       | `await`      | Waits for a promise to resolve (in `async` funcs)    | `await fetch()`                 |
|       | `async`      | Declares an asynchronous function                    | `async function fetchData() {}` |
|       | `import`     | Imports functions/modules (ES6)                      | `import fs from "fs";`          |
|       | `export`     | Exports functions/modules                            | `export default function() {}`  |
|       | `super`      | Calls a parent class constructor                     | `super()`                       |
|       | `extends`    | Creates a class that inherits from another class     | `class Dog extends Animal`      |

### ‚ùå Reserved but rarely used:

These are usually reserved for future use or advanced cases:

- `enum`, `yield`, `with`, `debugger`, `implements`, `interface`, `package`, `protected`, `private`, `public`, `static`, `let` (in older JS, treated as reserved).

### ‚ö†Ô∏è You **can't** use these as variable names:

```javascript
let return = 5;     // ‚ùå SyntaxError
const if = "test";  // ‚ùå SyntaxError
```

---

## Operators & operator precedence in JavaScript
In **JavaScript**, **operators** are symbols used to **perform operations** on variables and values ‚Äî like addition, comparison, or logic. **Operator precedence** determines **which operation runs first** when multiple operators appear in one expression.

### Types of Operators

#### 1. Arithmetic Operators

| Operator | Meaning        | Example  | Result      |
| -------- | -------------- | -------- | ----------- |
| `+`      | Addition       | `5 + 2`  | `7`         |
| `-`      | Subtraction    | `5 - 2`  | `3`         |
| `*`      | Multiplication | `5 * 2`  | `10`        |
| `/`      | Division       | `10 / 2` | `5`         |
| `%`      | Modulus        | `5 % 2`  | `1`         |
| `**`     | Exponentiation | `2 ** 3` | `8`         |
| `++`     | Increment      | `x++`    | Adds 1      |
| `--`     | Decrement      | `x--`    | Subtracts 1 |

#### 2. Assignment Operators

| Operator | Meaning           | Example                |
| -------- | ----------------- | ---------------------- |
| `=`      | Assign value      | `x = 5`                |
| `+=`     | Add & assign      | `x += 3` ‚Üí `x = x + 3` |
| `-=`     | Subtract & assign | `x -= 2`               |
| `*=`     | Multiply & assign | `x *= 2`               |
| `/=`     | Divide & assign   | `x /= 2`               |
| `%=`     | Modulus & assign  | `x %= 2`               |

#### 3. Comparison Operators

| Operator | Meaning               | Example     | Result  |
| -------- | --------------------- | ----------- | ------- |
| `==`     | Equal (loose)         | `5 == "5"`  | `true`  |
| `===`    | Equal (strict)        | `5 === "5"` | `false` |
| `!=`     | Not equal (loose)     | `5 != "5"`  | `false` |
| `!==`    | Not equal (strict)    | `5 !== "5"` | `true`  |
| `>`      | Greater than          | `7 > 5`     | `true`  |
| `<`      | Less than             | `5 < 7`     | `true`  |
| `>=`     | Greater than or equal | `5 >= 5`    | `true`  |
| `<=`     | Less than or equal    | `4 <= 3`    | `false` |

#### 4. Logical Operators

| Operator | Meaning     | Example          | Result  |
| -------- | ----------- | ---------------- | ------- |
| `&&`     | Logical AND | `true && false`  | `false` |
| \| \|    | Logical OR  | true \| \| false | `true`  |
| `!`      | Logical NOT | `!true`          | `false` |

#### 5. String Concatenation

```javascript
"Hello" + " World"   // "Hello World"
```

#### 6. Ternary Operator (conditional)

```javascript
let result = (age >= 18) ? "Adult" : "Minor";
```

#### 7. `typeof` & ` instanceof`

```javascript
typeof "hello";        // "string"
x instanceof Array;    // true or false
```

---

### Operator Precedence
**Operator precedence** determines the order in which operations are executed.

> Think of it like **math rules**: `()` comes before `*`, which comes before `+`.

#### üìä Precedence Table (high to low)

| Precedence | Operator (s)              | Type            |
| ---------- | ------------------------- | --------------- |
| 20         | `()`                      | Grouping        |
| 17         | `new`, `super`            | Object creation |
| 16         | `++`, `--` (postfix)      | Increment       |
| 15         | `!`, `++`, `--`, `typeof` | Unary           |
| 14         | `**`                      | Exponentiation  |
| 13         | `*`, `/`, `%`             | Multiply, etc.  |
| 12         | `+`, `-`                  | Add/Subtract    |
| 11         | `<<`, `>>`, `>>>`         | Bitwise shifts  |
| 10         | `<`, `<=`, `>`, `>=`      | Comparison      |
| 9          | `==`, `!=`, `===`, `!==`  | Equality        |
| 6          | `&&`                      | Logical AND     |
| 5          | \| \|                     | Logical OR      |
| 4          | `? :`                     | Ternary         |
| 3          | `=`, `+=`, `-=` etc.      | Assignment      |

#### üîç Example:

```javascript
let result = 3 + 4 * 5;   // 3 + (4 * 5) = 23 (not 35)
```

Use parentheses `()` to control precedence:

```javascript
let fixed = (3 + 4) * 5;  // 7 * 5 = 35
```

---

## Identifier Rules in JavaScript
In **JavaScript**, an **identifier** is the **name** used to identify variables, functions, classes, or other user-defined elements.

### Identifier Rules in JavaScript
Here are the **rules** for writing valid identifiers (names):

#### 1. Can contain:

- Letters (A‚ÄìZ, a‚Äìz)

- Digits (0‚Äì9)

- Underscores `_`

- Dollar signs `$`

#### 2. Must NOT:

- **Begin with a number**  
    ‚ùå `1name` is invalid  
    ‚úÖ `name1` is valid

- **Use reserved keywords** like `let`, `class`, `return`, etc.

#### 3. Case sensitive
`Name`, `name`, and `NAME` are **different** identifiers.

#### 4. Can include Unicode letters
You can technically use things like:

```javascript
let caf√© = "coffee";  // valid
```

### Examples

#### üü¢ Valid Identifiers

```javascript
let user;
let _private;
let $dollar;
let userName;
let user123;
```

#### üî¥ Invalid Identifiers

```javascript
let 2ndUser;     // ‚ùå starts with number
let let;         // ‚ùå keyword
let user-name;   // ‚ùå hyphen not allowed
let @home;       // ‚ùå special symbol
```

### Which Identifiers Are Used in JavaScript?
JavaScript frequently uses:

- `camelCase` for variables/functions: `userName`, `getData()`

- `PascalCase` for classes/constructors: `Person`, `CarModel`

- `_underscore` prefix for private/internal variables: `_id`

- `$dollar` prefix in libraries (like jQuery): `$`, `$element`

---

## Output methods in JavaScript
In JavaScript, there are several methods to **output data**. Here's a list of the most commonly used ones, depending on your context (web page, console, alert, etc.):

### üñ•Ô∏è 1. `console.log()`

- **Use**: Outputs to the browser's console (mainly for debugging).

```javascript
console.log("Hello, world!");
```

### üó®Ô∏è 2. `alert()`

- **Use**: Shows a popup alert box in the browser.

```javascript
alert("This is an alert box!");
```

### ‚úçÔ∏è 3. `document.write()`

- **Use**: Writes directly to the HTML document. _Not recommended for modern use_ (especially after page load).
    

```javascript
document.write("This is written to the page.");
```

### üì§ 4. `innerHTML`

- **Use**: Inserts content into an HTML element.

```html
<div id="output"></div>

<script>
  document.getElementById("output").innerHTML = "Output via innerHTML";
</script>
```

### üìã 5. `window.prompt()`

- **Use**: Outputs a message and takes user input.

```javascript
var name = prompt("Enter your name:");
console.log("Hello, " + name);
```

### üì¨ 6. `confirm()`

- **Use**: Shows a confirmation dialog with OK/Cancel.

```javascript
var result = confirm("Are you sure?");
console.log(result);  // true or false
```

### üß± 7. [[DOM]] manipulation methods (like `createElement`, `appendChild`)

- **Use**: Dynamically creates and displays elements.

```javascript
let p = document.createElement("p");
p.textContent = "This was created dynamically!";
document.body.appendChild(p);
```

---

## Conditional Statements in JavaScript
Conditional statements **control the flow** of your program based on **conditions** (true/false values).

### 1. `if` Statement
Executes a block if the condition is true.

```javascript
let age = 20;

if (age >= 18) {
  console.log("You are an adult.");
}
```

### 2. `if...else` Statement
Adds an alternative if the condition is false.

```javascript
let age = 16;

if (age >= 18) {
  console.log("You can vote.");
} else {
  console.log("You are too young to vote.");
}
```

### 3. `if...else if...else` Statement
Tests multiple conditions in order.

```javascript
let score = 85;

if (score >= 90) {
  console.log("Grade: A");
} else if (score >= 80) {
  console.log("Grade: B");
} else {
  console.log("Grade: C or below");
}
```

### 4. `switch` Statement
Better for checking one variable against multiple exact values.

```javascript
let color = "blue";

switch (color) {
  case "red":
    console.log("Color is red");
    break;
  case "blue":
    console.log("Color is blue");
    break;
  default:
    console.log("Unknown color");
}
```

### 5. Ternary Operator (`? :`)
A shorthand for simple `if...else`.

```javascript
let age = 18;
let message = (age >= 18) ? "Adult" : "Minor";
console.log(message);
```

---

## Loops in JavaScript
Loops in JavaScript allow you to execute a block of code repeatedly, based on a condition. Here‚Äôs a breakdown of the main types of loops in JavaScript:

### For Loops
**For loops** are the most **common** type of loops.
#### üîÅ Basic `for` Loop Syntax

```javascript
for (initialization; condition; increment) {
	// code to execute 
}
```

- **`initialization`** ‚Äì runs once before the loop starts (usually used to declare a counter variable).

- **`condition`** ‚Äì the loop runs **while this condition is true**.

- **`increment`** ‚Äì runs **after each iteration**.

#### ‚úÖ Example

```javascript
for (let i = 0; i <= 5; i++) {   
	console.log(i); 
}
```

üì§ Output:

```
1
2
3
4
5
```

### While Loops
A **while loop** repeatedly executes a block of code **as long as a specified condition is `true`**.

#### üîÅ Basic `while` Loop Syntax

```javascript
while (condition) {
  // code block to be executed
}
```

- The condition is checked **before** the code block runs.

- If the condition is `false`, the loop **does not run at all**.

#### ‚úÖ Example

```javascript
let i = 1;
while (i <= 5) {
  console.log(i);
  i++;
}
```

üì§ Output:

```
1
2
3
4
5
```

### For... Of Loops
The `for...of` loop is used to **iterate over iterate-able objects** like:

- Arrays

- Strings

- Maps

- Sets

- [[DOM]] NodeLists, etc.

#### üîÅ Basic `for...of` Loop Syntax

```javascript
for (const element of iterable) {
  // code to execute
}
```

#### ‚úÖ Example: Loop Through an Array

```javascript
const fruits = ['apple', 'banana', 'cherry'];

for (const fruit of fruits) {
  console.log(fruit);
}
```

üì§ Output:

```
apple
banana
cherry
```

### For... In Loops
The `for...in` loop is used to **iterate over the enumerable properties (keys)** of an object.

#### üîÅ Basic `for...in` Loop Syntax

```javascript
for (const key in object) {
  // code to execute
}
```

- Iterates over all **enumerable string keys** in an object (including inherited properties if not filtered).

#### ‚úÖ Example: Loop Through an Object

```javascript
const person = {
  name: "Alice",
  age: 30,
  job: "Developer"
};

for (const key in person) {
  console.log(`${key}: ${person[key]}`);
}
```

üì§ Output:

```
name: Alice
age: 30
job: Developer
```

#### ‚ö†Ô∏è `for...in` with Arrays ‚Äì Be Careful

```javascript
const colors = ['red', 'green', 'blue'];

for (const index in colors) {
  console.log(index, colors[index]);
}
```

üì§ Output:

```
0 red
1 green
2 blue
```

- This **loops over indices**, not values.

- Use `for...of` for array **values** instead.

#### üõë Inherited Properties Warning
`for...in` will also iterate over **inherited properties**, unless you filter them:

```javascript
const obj = Object.create({ inherited: true });
obj.own = 'yes';

for (const key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(key); // only "own"
  }
}
```

#### ‚úÖ Use Cases

- Best for looping through **object properties**

- Avoid for arrays unless you need **indices** (use `for` or `for...of` for values)


### `do...while` Loop in JavaScript
The `do...while` loop is similar to a `while` loop, **but it always executes the code block at least once**, **before** checking the condition.

#### üîÅ Basic `do...while` Loop Syntax

```javascript
do {
  // code block to execute
} while (condition);
```

- The block runs **once before** the condition is checked.

- If the condition is true, it runs again‚Äîand repeats until the condition is false.

#### ‚úÖ Example

```javascript
let i = 1;

do {
  console.log(i);
  i++;
} while (i <= 5);
```

üì§ Output:

```
1
2
3
4
5
```

#### ‚úÖ When to Use `do...while`:

- Use when the **code should run at least once**, even if the condition is initially false.

- Input validation loops (run at least once)

- Menus or retry systems

- Scenarios where action must happen before the condition is meaningful


### `break` and `continue` in JavaScript Loops
These are **control flow statements** that help you manage how loops behave.

#### üîì `break` ‚Äì **Exits** the Loop Immediately
When JavaScript encounters a `break` statement inside a loop, it **stops** the loop right there and jumps to the next line **after** the loop.

‚úÖ Example:

```javascript
for (let i = 1; i <= 5; i++) {
  if (i === 3) break;
  console.log(i);
}
```

üì§ Output:

```
1
2
```

#### ‚è≠Ô∏è `continue` ‚Äì **Skips** to the Next Iteration
When JavaScript encounters `continue`, it **skips the rest of the current iteration** and jumps back to the loop condition for the next cycle.

‚úÖ Example:

```javascript
for (let i = 1; i <= 5; i++) {
  if (i === 3) continue;
  console.log(i);
}
```

üì§ Output:

```
1
2
4
5
```

#### ‚ö†Ô∏è Tip

Using `break` or `continue` too much can make your code harder to read. Use them when:

- `break`: You want to stop the loop based on a condition.

- `continue`: You want to skip specific values or cases.

---

## Math Methods in JavaScript (`Math` Object)
JavaScript provides a built-in `Math` object with **properties and methods** for performing mathematical tasks.

### üìå Most-Used `Math` Methods

|Method|Description|Example|Result|
|---|---|---|---|
|`Math.abs(x)`|Returns absolute value|`Math.abs(-7)`|`7`|
|`Math.ceil(x)`|Rounds **up** to the nearest integer|`Math.ceil(4.2)`|`5`|
|`Math.floor(x)`|Rounds **down** to the nearest integer|`Math.floor(4.9)`|`4`|
|`Math.round(x)`|Rounds to the **nearest** integer|`Math.round(4.5)`|`5`|
|`Math.trunc(x)`|Removes decimal part (no rounding)|`Math.trunc(4.9)`|`4`|
|`Math.max(...values)`|Returns the **largest** number|`Math.max(3, 5, 1)`|`5`|
|`Math.min(...values)`|Returns the **smallest** number|`Math.min(3, 5, 1)`|`1`|
|`Math.sqrt(x)`|Square root|`Math.sqrt(16)`|`4`|
|`Math.pow(x, y)`|`x` to the power of `y`|`Math.pow(2, 3)`|`8`|
|`Math.random()`|Random number between `0` and `1`|‚Äî|e.g. `0.7356`|
|`Math.PI`|œÄ constant|`Math.PI`|`3.14159...`|

### üìê More Advanced

| Method                                        | Description                                       |
| --------------------------------------------- | ------------------------------------------------- |
| `Math.sin(x)` / `Math.cos(x)` / `Math.tan(x)` | Trigonometric functions (in radians)              |
| `Math.log(x)`                                 | Natural logarithm (base **e**)                    |
| `Math.log10(x)`                               | Log base 10                                       |
| `Math.exp(x)`                                 | Exponential function, returns `e^x`               |
| `Math.cbrt(x)`                                | Cube root                                         |
| `Math.hypot(a, b)`                            | Returns ‚àö(a¬≤ + b¬≤) (like the Pythagorean theorem) |

### üçÄ Generating Random Number

``` javascript
// Generate a random number in between [0,1)
console.log(Math.random()); 

// Generate a random integer in between [1, 10]
console.log(Math.floor(Math.random() * 10) + 1); 

// General formula
Math.floor(Math.random() * (max -min + 1)) + min
```

---

## Functions in JavaScript
A **function** is a reusable block of code that performs a specific task.

Think of it like a **tool** in a toolbox: when you need to perform a task (e.g., calculate a number, fetch data, modify an object), you use that tool.

### Syntax:

```js
function functionName(parameters) {
  // code to execute
  return result; // optional
}
```

### Function Types in JavaScript

#### A. Function Declaration

```js
function greet(name) {
  return `Hello, ${name}`;
}
```

- **Hoisted**: Can be used before it's defined in the code.

#### B. Function Expression

```js
const greet = function(name) {
  return `Hello, ${name}`;
};
```

- Not hoisted. Safer in larger apps due to scope clarity.

#### C. Arrow Function (ES6+)

```js
const greet = (name) => `Hello, ${name}`;
```

- Shorter syntax.

- Doesn‚Äôt have its own `this`, `arguments`, or `super`.

- Great for **callbacks**, **array methods**, and **functional programming**.

### Parameters vs Arguments

```js
function sum(a, b) {
  return a + b; // 'a' and 'b' are parameters
}

sum(5, 10); // 5 and 10 are arguments
```

#### üîπDefault Parameters

```js
function greet(name = "Guest") {
  return `Hello, ${name}`;
}
```

#### üîπRest Parameters & Spread Syntax

```js
function sumAll(...nums) {
  return nums.reduce((acc, val) => acc + val, 0);
}
sumAll(1, 2, 3, 4); // 10
```

### Callback Functions

> A function passed as an argument to another function.

```js
function fetchData(callback) {
  setTimeout(() => {
    callback("Data loaded");
  }, 1000);
}

fetchData((data) => console.log(data)); // "Data loaded"
```

### Anonymous Functions

> Functions without a name (often used inline).

```js
setTimeout(function () {
  console.log("Executed after 1 second");
}, 1000);
```

### IIFE (Immediately Invoked Function Expression)
Executes **immediately** after creation. Good for **isolated scope**, often used in **modular design**.

```js
(function() {
  console.log("This runs immediately");
})();
```

### Higher-Order Functions (HOFs)

> Functions that **take other functions** as arguments or **return functions**.

```js
function multiply(factor) {
  return function(num) {
    return num * factor;
  };
}

const double = multiply(2);
console.log(double(5)); // 10
```

This is where **JavaScript power** really shines ‚Äî used heavily in frameworks, FP (Functional Programming), and more.

### Closures

A function that **remembers** its lexical scope, even when the outer function has finished execution.

```js
function outer() {
  let count = 0;
  return function() {
    count++;
    return count;
  };
}

const counter = outer();
console.log(counter()); // 1
console.log(counter()); // 2
```

Use cases:

- Data encapsulation

- Private variables

- Functional state

### Async Functions
Used with `await`, makes asynchronous code **clean and readable**.

```js
async function fetchUser() {
  const response = await fetch("https://api.example.com/user");
  const user = await response.json();
  return user;
}
```

### Methods
**Methods** are nothing but **functions in an object literal**.

```js
const Calculator = {
	add: function (a, b) { // Functions inside objects call method
		return a + b;
	},
	sub: function (a, b) {
		return a - b;
	},
	mul(a, b) { // Shorthand to create method	
		return a * b;
	},
	div(a, b) {
		return a / b;
	},
};

console.log(Calculator.add(2, 3));

console.log(Calculator.sub(60, 20));

console.log(Calculator.mul(3, 6));

console.log(Calculator.div(5, 2));

```

### SetTimeout function
The `setTimeout()` function in JavaScript is used to **execute a piece of code after a specified delay** (in milliseconds). It‚Äôs part of the **Web APIs**, provided by the browser environment, not the core JavaScript language itself.
#### üîß Syntax:

```javascript
setTimeout(callback, delay, ...args);
```

- `callback` ‚Äì The function to execute after the delay.

- `delay` ‚Äì Time to wait before executing the function (in **milliseconds**).

- `...args` ‚Äì Optional arguments to pass to the callback function.

---

#### ‚úÖ Example:

```javascript
console.log("Start");

setTimeout(() => {
  console.log("This runs after 2 seconds");
}, 2000);

console.log("End");
```

Output:

```
Start
End
This runs after 2 seconds
```

üîç **Explanation**:  
JavaScript is non-blocking and asynchronous. So even though you set a timeout, the rest of the code continues executing without waiting.

#### ‚õî Clearing a Timeout
You can cancel a timeout using `clearTimeout()` if it hasn‚Äôt fired yet.

```javascript
const id = setTimeout(() => {
  console.log("This won't run");
}, 3000);

clearTimeout(id);
```

### SetInterval function
The `setInterval` function in JavaScript is used to **repeatedly execute a function at specified time intervals** (in milliseconds). It's part of the Web APIs provided by browsers and also available in Node.js.

#### üîß Syntax:

```javascript
let intervalID = setInterval(function, delay, param1, param2, ...);
```

- `function` ‚Äì The function to be executed.

- `delay` ‚Äì Time in **milliseconds** between executions.

- `param1, param2, ...` ‚Äì Optional parameters passed to the function.

#### ‚õî Stopping `setInterval`:

Use `clearInterval(intervalID)` where `intervalID` is the identifier returned by `setInterval`.

#### ‚ö†Ô∏è Warning:

- **setInterval is not precise**. It doesn't guarantee exact timing due to event loop delays. If the callback takes longer than the interval, delays stack up.

- **Memory leaks**: Forgetting `clearInterval()` leads to infinite loops and memory issues in long-running apps.

###  Bonus: setTimeout vs setInterval

|Feature|`setTimeout()`|`setInterval()`|
|---|---|---|
|Runs after|One-time delay|Repeats at every interval|
|Can be recursive|Yes (by calling it again)|No (needs `clearInterval`)|
|Control|More control with recursion|Harder to manage dynamically|

---

## Scope in JavaScript
**Scope** in JavaScript determines **where a variable is accessible** ‚Äî like where it's "visible" or "reachable" in your code.

### üì¶ Think of it like containers:

- Imagine each function or block is a box üì¶.

- Variables declared inside a box **stay in that box** unless explicitly passed out.

- You can **see inside your own box** and the outer ones, but **not inside other boxes**.

### 1. Global Scope

```js
let name = "Sankha"; // global

function greet() {
  console.log("Hi " + name); // can access global
}

greet(); // Hi Sankha
```

- `name` is global, available _anywhere_ in your code.

- Be careful! Global variables stay in memory until the page is closed.

### 2. Function Scope

```js
function showAge() {
  let age = 21; // function-scoped
  console.log("Age is", age);
}

showAge();
// console.log(age); ‚ùå Error: age is not defined
```

- `age` exists **only inside** `showAge()`

- Try to access it outside? üí• Boom, it's undefined.

### 3. Block Scope (with `let` & `const` only)

```js
if (true) {
  let hobby = "coding";  // block-scoped
  const mood = "focused";
  console.log(hobby); // coding
}

console.log(hobby); // ‚ùå Error: hobby is not defined
```

- `var` does **not** follow block scope ‚Äî only `let` and `const` do.

#### ‚ö†Ô∏è Important Behavior: `var` vs `let` / `const`

```js
if (true) {
  var x = 5;
  let y = 10;
}

console.log(x); // ‚úÖ 5
console.log(y); // ‚ùå ReferenceError
```

- `var` is **function-scoped**, not block-scoped.

- `let` and `const` are **block-scoped**, safer to use in modern JS.

### 4.Lexical Scope
 Lexical scope means **the accessibility of variables is determined by where you write your code (at _definition time_)**, _not where you call it (at runtime)_.

In plain words:

- JS **reads your code from top to bottom**, and **decides the scope tree** before the program even runs.

- Inner functions have access to variables in the outer scopes **where they are written**, _regardless of where they're called later._

```js
function outer() {
  let name = "Sankha";

  function inner() {
    console.log(name); // ‚úÖ has access
  }

  inner();
}
```

Here, `inner()` can access `name` **because it's lexically inside `outer()`**.

#### ‚ö†Ô∏è But Watch This:

```js
function outer() {
  let secret = "hidden";
  return inner;
}

function inner() {
  console.log(secret); // ‚ùå ReferenceError: secret is not defined
}

outer()(); // üí• BOOM
```

Why? Because `inner` was **not written inside `outer`**, so it doesn‚Äôt have access to `outer`'s scope.  
Even though it's **called from `outer()`**, that doesn't matter.

**Lexical scope is about where it was written, not where it's called.**

### üéØ How Scope Works in Layers

```js
let outer = "I‚Äôm global";

function outerFunc() {
  let inner = "I‚Äôm inside outerFunc";

  function innerFunc() {
    let deep = "I‚Äôm deep inside";
    console.log(outer); // ‚úÖ I‚Äôm global
    console.log(inner); // ‚úÖ I‚Äôm inside outerFunc
    console.log(deep);  // ‚úÖ I‚Äôm deep inside
  }

  innerFunc();
  console.log(deep); // ‚ùå Error: deep is not defined
}

outerFunc();
```

- Inner scopes can **access outer scopes**, but **not the other way around**.

---

Alright Sankha, let's talk **hoisting** ‚Äî a fundamental yet often confusing concept in **JavaScript**. You _must_ understand this thoroughly if you're serious about mastering JS. So buckle in.

---

## Hoisting in JavaScript
**Hoisting** is JavaScript's default behavior of **moving declarations to the top** of the current scope (either global or function scope) **during the compilation phase**.

In simpler terms:

> JavaScript **scans** your code before it actually runs it, and **pulls all variable and function declarations** to the **top** of their scope.

### But Be Careful ‚Äî Not Everything is Hoisted Equally

#### 1. `var` is Hoisted (But Only the Declaration)

```js
console.log(a); // undefined
var a = 5;
console.log(a); // 5
```

What actually happens behind the scenes:

```js
var a;         // hoisted declaration
console.log(a); // undefined
a = 5;          // assignment stays in place
console.log(a); // 5
```

üß® So you don‚Äôt get an error‚Ä¶ but you don‚Äôt get the value either. You get `undefined`.

#### 2. `let` and `const` are Hoisted Too ‚Äî BUT...
They are hoisted to the top of the block **but not initialized**. This leads to a **Temporal Dead Zone (TDZ)**.

```js
console.log(b); // ‚ùå ReferenceError
let b = 10;
```

So unlike `var`, you can't use `let` or `const` **before** their declaration line.

Why? Because they are in a "dead zone" from the start of the scope until their declaration is reached.

#### 3. Function Declarations Are Fully Hoisted

```js
sayHello(); // ‚úÖ Works!

function sayHello() {
  console.log("Hi Sankha!");
}
```

Here, the **entire function** is hoisted, not just the name.

BUT:

##### ‚ö†Ô∏è **Function Expressions Are NOT Hoisted**

```js
sayHi(); // ‚ùå TypeError: sayHi is not a function

var sayHi = function () {
  console.log("Hi again!");
};
```

Only the **`var sayHi`** part is hoisted, which becomes `undefined` initially ‚Äî not the function.

Same applies to `let` or `const` function expressions. They fall into the TDZ and throw `ReferenceError`.

---

## Try & Catch in JavaScript
In JavaScript, `try...catch` is used for **error handling**. It allows you to test a block of code (`try`) for errors, and if an error occurs, handle it in the `catch` block instead of letting the program crash.

### üîß Syntax:

```javascript
try {
  // Code that might throw an error
} catch (error) {
  // Code to handle the error
}
```

### ‚úÖ Optional `finally` Block

```javascript
try {
  // Code that might throw an error
} catch (error) {
  // Handle the error
} finally {
  // Code that will always run, regardless of an error
}
```

### üß† Example:

```javascript
try {
  let result = riskyFunction();
  console.log("Result:", result);
} catch (err) {
  console.error("Something went wrong:", err.message);
} finally {
  console.log("This will always run.");
}
```

### üëÄ Notes:

- Only **runtime errors** (not syntax errors) can be caught.

- The `error` object in `catch(error)` contains info about the error (like `error.name`, `error.message`, `error.stack`).

- `try...catch` works **synchronously**; to catch async errors, use `.catch()` with Promises or `try...catch` inside `async/await` functions.

### üîÑ Example with `async/await`:

```javascript
async function fetchData() {
  try {
    let response = await fetch("https://api.example.com/data");
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Failed to fetch data:", error);
  }
}
```

---

## This keyword in JavaScript
In JavaScript, the `this` keyword refers to the **context in which a function is called**. Its value depends on **how** the function is invoked, and it can be tricky because it changes depending on the situation.

### Common `this` Scenarios

#### 1. Global Context

```javascript
console.log(this); // In browsers, this is the `window` object
```

#### 2. Inside a Function (Non-strict mode)

```javascript
function show() {
  console.log(this);
}
show(); // `this` is the global object (`window` in browsers)
```

#### 3. Inside a Method (Object Context)

```javascript
const user = {
  name: "Alice",
  greet() {
    console.log(this.name);
  }
};
user.greet(); // `this` refers to `user`
```

#### 4. Arrow Functions
Arrow functions **do not have their own `this`**. They inherit it from the enclosing (lexical) scope.

```javascript
const user = {
  name: "Bob",
  greet: () => {
    console.log(this.name);
  }
};
user.greet(); // `this` is not `user`, it's the outer (global) `this`
```

#### 5. Inside Classes

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
  greet() {
    console.log(`Hello, ${this.name}`);
  }
}
const p = new Person("Eve");
p.greet(); // this ‚Üí instance of Person
```

#### 6. Using `bind`, `call`, and `apply`

```javascript
function greet() {
  console.log(this.name);
}
const person = { name: "Dave" };

greet.call(person);  // Dave
greet.apply(person); // Dave
const boundGreet = greet.bind(person);
boundGreet();        // Dave
```

### Summary

|Context|`this` refers to|
|---|---|
|Global scope|`window` (browser) or `global` (Node.js)|
|Object method|The object itself|
|Arrow function|Inherits `this` from surrounding context|
|Class method|The instance of the class|
|`bind` / `call` / `apply`|Explicitly defined object|

---

## Spread & Rest in JavaScript

### Spread

#### What is the Spread Syntax?
**Spread (`...`)** expands:

- Arrays

- Objects

- Iterables (like Sets, Strings, Maps)  
    into individual elements or properties.

#### Spread with Arrays

##### ‚úÖ Copying an Array

```js
const nums = [1, 2, 3];
const copy = [...nums]; // [1, 2, 3]
```

> _Creates a shallow copy (not deep)._

##### ‚úÖ Merging Arrays

```js
const arr1 = [1, 2];
const arr2 = [3, 4];
const merged = [...arr1, ...arr2]; // [1, 2, 3, 4]
```

##### ‚úÖ Spreading into Function Arguments

```js
function add(a, b, c) {
  return a + b + c;
}

const values = [1, 2, 3];
console.log(add(...values)); // 6
```

##### ‚úÖ Spreading Strings (turns into array of characters)

```js
const word = "hello";
const letters = [...word]; // ['h', 'e', 'l', 'l', 'o']
```

#### Spread with Objects

##### ‚úÖ Cloning an Object

```js
const user = { name: "Alice", age: 25 };
const clone = { ...user }; // { name: "Alice", age: 25 }
```

##### ‚úÖ Merging Objects

```js
const defaults = { theme: "dark", font: "Arial" };
const settings = { font: "Roboto", layout: "grid" };

const final = { ...defaults, ...settings };
// { theme: "dark", font: "Roboto", layout: "grid" }
```

> _Right-most object overwrites previous values._

#### Limitations & Caveats

- Spread only performs a **shallow copy**.
	
```js
const original = { a: 1, b: { c: 2 } };
onst copy = { ...original };
copy.b.c = 99; // changes original.b.c too
```

- Can‚Äôt spread **non-iterables** (e.g., numbers or objects in arrays directly).

- Can't spread into **constructor arguments** unless using `apply()` or modern class spreading patterns.

#### Summary

| Feature       | Spread Use Case Example         |
| ------------- | ------------------------------- |
| Copy array    | `const copy = [...array]`       |
| Merge arrays  | `const combined = [...a, ...b]` |
| Spread string | `const chars = [..."text"]`     |
| Clone object  | `const newObj = { ...obj }`     |
| Merge objects | `const result = { ...a, ...b }` |
| Function args | `func(...argsArray)`            |

### Rest in JavaScript

#### What is Rest?
**Rest syntax** uses `...` to **gather** remaining elements/args/properties into a new array or object.

Think:
 
 - **Spread** = ‚Äúexplode‚Äù

 - **Rest** = ‚Äúgather‚Äù

#### Rest in Function Parameters

##### ‚úÖ Capture Unlimited Arguments

```js
function logAll(...args) {
  console.log(args);
}

logAll(1, 2, 3); // [1, 2, 3]
```

> `args` becomes a real array (not `arguments` object).

##### ‚úÖ With Named Params

```js
function greet(first, ...others) {
  console.log(first);  // 'Hello'
  console.log(others); // ['World', '!']
}

greet('Hello', 'World', '!'); 
```


#### Important Rules

- **Only one** rest element is allowed.

- Must be the **last** in parameter/destructuring list.
	
```js
function wrong(...args, x) {} // ‚ùå SyntaxError
```

#### Use Cases

| Use Case                         | Rest Syntax Example                   |
| -------------------------------- | ------------------------------------- |
| Unlimited function arguments     | `function sum(...nums)`               |
| Array destructuring (skip first) | `const [_, ...rest] = arr`            |
| Object property separation       | `const {id, ...others} = obj`         |
| Custom wrapper over functions    | `(...args) => func.apply(null, args)` |

#### Don‚Äôt Confuse Rest vs Spread

|Feature|Role|Example|
|---|---|---|
|Rest|Gather items|`function f(...args) {}`|
|Spread|Expand items|`f(...[1, 2, 3])`|

#### Summary

- **Rest = collect multiple elements into one**.

- Use it in:
    
    - Function parameters
    
    - Array/object destructuring
    
- It‚Äôs a tool for **flexibility**, **clean syntax**, and **modularity**.

---

## Destructuring in JavaScript

### What Is Destructuring?
**Destructuring** means extracting values from arrays or properties from objects and assigning them to variables using a concise syntax.

> TL;DR: Break down data structures into variables ‚Äî clean and fast.

### Array Destructuring

#### ‚úÖ Basic Usage

```js
const arr = [10, 20, 30];
const [a, b, c] = arr;

console.log(a); // 10
console.log(b); // 20
```

#### ‚úÖ Skip Items

```js
const [x, , z] = [1, 2, 3];
console.log(z); // 3
```

#### ‚úÖ Use with Rest

```js
const [first, ...rest] = [1, 2, 3, 4];
console.log(first); // 1
console.log(rest);  // [2, 3, 4]
```

#### ‚úÖ Set Defaults

```js
const [a = 1, b = 2] = [];
console.log(a, b); // 1 2
```

### Object Destructuring

#### ‚úÖ Basic Usage

```js
const user = { name: "Sankho", age: 21 };
const { name, age } = user;
console.log(name); // 'Sankho'
```

#### ‚úÖ Rename Variables

```js
const { name: userName, age: userAge } = user;
console.log(userName); // 'Sankho'
```

#### ‚úÖ Set Defaults

```js
const { role = "user" } = user;
console.log(role); // 'user'
```

#### ‚úÖ Nested Destructuring

```js
const user = {
  name: "Sankho",
  address: {
    city: "Delhi",
    zip: 12345,
  },
};

const {
  address: { city },
} = user;
console.log(city); // 'Delhi'
```

### Destructuring in Function Parameters

#### ‚úÖ Object Params

```js
function greet({ name, age }) {
  console.log(`Hello ${name}, you are ${age}`);
}

greet({ name: "Sankho", age: 21 });
```

#### ‚úÖ Array Params

```js
function sum([a, b]) {
  return a + b;
}
console.log(sum([5, 7])); // 12
```

### Gotchas

- **Order matters in arrays**, not in objects.

- For **nested values**, destructure safely ‚Äî use optional chaining or defaults to avoid `undefined`.

- **Deep nested destructuring** can kill readability. Know when to stop.

### When to Use

|Situation|Use Destructuring?|
|---|---|
|Pulling multiple values from obj|‚úÖ Yes|
|Handling function params|‚úÖ Yes|
|Deep destructuring|‚ö†Ô∏è With caution|
|One or two properties only|ü§∑‚Äç‚ôÇÔ∏è Up to you|

---

