 # [JavaScript Tutorial](https://www.apnacollege.in/path-player?courseid=sigma-8&unit=685ffaa6e566eeb1db05a05dUnit)

## What is JavaScript?

**JavaScript** is a high-level, interpreted programming language that is primarily used to make web pages interactive. It is one of the core technologies of the web, alongside **HTML** and **CSS**.

### Key Features:

- **Client-side scripting**: JavaScript runs in the browser, allowing dynamic changes to content, form validation, interactive maps, animations, and more.

- **Lightweight and interpreted**: It doesn't need to be compiled before running.

- **Event-driven**: JavaScript can respond to user actions like clicks, key presses, or mouse movements.

- **Object-oriented and functional**: Supports both styles of programming.

- **Runs everywhere**: Supported by all modern web browsers without needing additional plugins.

### Common Uses:

- Updating content dynamically without reloading the page (AJAX)

- Form validation before sending data to the server

- Creating interactive UI components (dropdowns, sliders, modals)

- Building web apps (e.g., using frameworks like React, Vue, or Angular)

- Server-side development with Node.js

---

## Variables in JavaScript
A **variable** is a **container for storing data** in a program. You can think of it like a labeled box that holds a value ‚Äî such as a number, a string of text, or even a more complex structure like an object or an array.

### üß† In simple terms:

> A variable lets you **give a name** to some data so you can **use it later**.

### üí° Example in JavaScript:

```javascript
let name = "Alice";
let age = 25;
let isStudent = true;
```

Here:

- `name` is a variable storing the string `"Alice"`

- `age` is a variable storing the number `25`

- `isStudent` is a variable storing the boolean value `true`

### Why are variables important?

Variables allow your code to:

- Store user input

- Keep track of data (like scores in a game)

- React to changes over time

- Avoid repeating values

---

## Datatypes in JavaScript
In **JavaScript**, **data types** define the kind of value a variable can hold. They are grouped into **primitive types** and **reference types (objects)**.

### 1. Primitive Data Types
These are simple, single values ‚Äî not objects ‚Äî and are **immutable**.

|Type|Example|Description|
|---|---|---|
|`String`|`"Hello"`|Text data|
|`Number`|`42`, `3.14`|Integer or floating point numbers|
|`Boolean`|`true`, `false`|Logical values|
|`Undefined`|`let x;`|A variable declared but not assigned|
|`Null`|`let x = null;`|Explicitly no value|
|`Symbol`|`Symbol("id")`|Unique identifiers (advanced use)|
|`BigInt`|`12345678901234567890n`|Very large integers|

#### ‚úÖ Examples:

```javascript
let name = "Alice";       // String
let age = 30;             // Number
let isHappy = true;       // Boolean
let address;              // Undefined
let score = null;         // Null
let id = Symbol("id");    // Symbol
let big = 123456789012345678901234567890n; // BigInt
```

### 2. Reference (Object) Data Types
These hold **collections of values** or more **complex structures**.

| Type       | Example                      | Description            |
| ---------- | ---------------------------- | ---------------------- |
| `Object`   | `{ name: "Alice", age: 30 }` | Key-value pairs        |
| `Array`    | `[1, 2, 3]`                  | Ordered list           |
| `Function` | `function() {}`              | Reusable block of code |
| `Date`     | `new Date()`                 | Date and time          |

#### ‚úÖ Examples:

```javascript
let user = { name: "Alice", age: 30 }; // Object
let numbers = [10, 20, 30];            // Array
function greet() {
  console.log("Hi!");
}                                      // Function
let today = new Date();                // Date object
```

### Check a variable‚Äôs type:
Use `typeof`:

```javascript
typeof "Hello";       // "string"
typeof 42;            // "number"
typeof {};            // "object"
typeof [];            // "object" (arrays are objects)
typeof null;          // "object" (weird JS quirk)
```

---

## Primitive Datatypes

### Numbers
In **JavaScript**, **numbers** are one of the fundamental data types and are used to represent both integers and floating-point (decimal) values.

#### ‚úÖ 1. Integer and Floating-Point
JavaScript uses the same type (`number`) for:

- **Integers**: `1`, `100`, `-42`

- **Decimals**: `3.14`, `-0.001`

```javascript
let age = 25;
let price = 19.99;
```

#### ‚úÖ 2. Special Number Values

|Value|Description|
|---|---|
|`Infinity`|Greater than any number (`1 / 0`)|
|`-Infinity`|Less than any number (`-1 / 0`)|
|`NaN`|"Not-a-Number" (e.g., `"abc" / 2`)|

```javascript
console.log(1 / 0);         // Infinity
console.log("abc" * 3);     // NaN
```

#### ‚ûï Arithmetic Operations

|Operation|Symbol|Example|Result|
|---|---|---|---|
|Add|`+`|`5 + 3`|`8`|
|Subtract|`-`|`5 - 3`|`2`|
|Multiply|`*`|`5 * 3`|`15`|
|Divide|`/`|`6 / 2`|`3`|
|Modulus|`%`|`5 % 2`|`1`|
|Exponent|`**`|`2 ** 3`|`8`|

#### üîÑ Type Conversion
JavaScript is loosely typed, so numbers can mix with strings ‚Äî but results can be tricky:

```javascript
"5" + 2      // "52"  (string + number = string)
"5" - 2      // 3     (coerced to number)
"5" * "2"    // 10    (coerced to number)
```

Use `Number()`, `parseInt()`, or `parseFloat()` to convert:

```javascript
Number("123");       // 123
parseInt("10px");    // 10
parseFloat("3.14");  // 3.14
```

#### üî¢ BigInt (for large numbers)
If you need to work with very large integers beyond `2^53 - 1`:

```javascript
let big = 123456789012345678901234567890n;
```

---

### Booleans
The **Boolean** data type in JavaScript represents **one of two values**:

```javascript
true    // yes, correct, on
false   // no, incorrect, off
```

Booleans are often used in **conditions**, **comparisons**, and **control structures** like `if` statements.

#### Examples:

```javascript
let isRaining = true;
let hasLicense = false;
```

#### Boolean Results from Comparisons:

```javascript
5 > 3        // true
10 === 5     // false
"cat" !== "dog"  // true
```

#### Truthy and Falsy Values
In JavaScript, **non-boolean values can behave like booleans** in conditions.

##### ‚ùå **Falsy values (evaluated as `false`):**

- `false`

- `0`

- `""` (empty string)

- `null`

- `undefined`

- `NaN`

##### ‚úÖ **Truthy values:**

- Anything else: non-zero numbers, non-empty strings, objects, arrays, etc.

```javascript
if ("hello") {
  console.log("This is truthy!");  // This will run
}
```

#### Boolean Conversion
You can convert a value to a boolean using:

```javascript
Boolean(0);       // false
Boolean("hi");    // true
Boolean(null);    // false
```

Or by using double NOT:

```javascript
!!"text"          // true
!!0               // false
```

#### Boolean Logic Operators:

| Operator | Name | Example          | Result  |
| -------- | ---- | ---------------- | ------- |
| `&&`     | AND  | `true && false`  | `false` |
| \| \|    | OR   | true \| \| false | `true`  |
| `!`      | NOT  | `!true`          | `false` |

---

### Strings
In **JavaScript**, a **string** is a sequence of **characters** (letters, numbers, symbols, etc.) used to represent **text**. Strings are **immutable** in nature.

#### How to Declare Strings
You can create strings using:

```javascript
let name = "Alice";      // double quotes
let city = 'Paris';      // single quotes
let message = `Hello`;   // backticks (template literals)
```

All three are valid, but **backticks** offer special powers.

#### Common String Examples:

```javascript
let greeting = "Hello, world!";
let answer = 'Yes!';
let emoji = "üòä";
```

#### String Operations

##### ‚ûï **Concatenation (joining strings)**

```javascript
let firstName = "John";
let lastName = "Doe";
let fullName = firstName + " " + lastName;  // "John Doe"
```

##### üß© **Template Literals (with backticks)**
Use `${}` to insert variables into strings:

```javascript
let name = "Sara";
let age = 25;
let intro = `My name is ${name} and I am ${age} years old.`;
```

##### üî¢ **String Indices in JavaScript**
A **string index** is the **position of a character** in a string. JavaScript strings are **zero-indexed**, meaning the **first character is at index 0**, the second at index 1, and so on.

```javascript
let word = "hello";
```

Use **square brackets `[]`** or `.charAt()` to access the index:

```javascript
console.log(word[0]);        // "h"
console.log(word.charAt(1)); // "e"
```

If index is out of range:

```javascript
console.log(word[10]);       // undefined
console.log(word.charAt(10)); // "" (empty string)
```

#### Common String Methods
We can chain multiple methods together. i.e `string.method1().method()`

| Method              | Description                    | Example                                 |
| ------------------- | ------------------------------ | --------------------------------------- |
| `length`            | Returns the length             | `"Hi".length ‚Üí 2`                       |
| `toUpperCase()`     | Converts to uppercase          | `"hello".toUpperCase()` ‚Üí `"HELLO"`     |
| `toLowerCase()`     | Converts to lowercase          | `"Hi".toLowerCase()` ‚Üí `"hi"`           |
| `includes()`        | Checks if substring exists     | `"apple".includes("pp")` ‚Üí `true`       |
| `indexOf()`         | Finds position of a substring  | `"cat".indexOf("a")` ‚Üí `1`              |
| `slice(start, end)` | Extracts part of string        | `"hello".slice(1, 4)` ‚Üí `"ell"`         |
| `replace()`         | Replaces part of string        | `"hello".replace("h", "y")` ‚Üí `"yello"` |
| `trim()`            | Removes whitespace from ends   | `" hi ".trim()` ‚Üí `"hi"`                |
| `repeat()`          | Repeat a string multiple times | `"hi.repeat(3)"` ‚Üí `"hihihi"`           |

#### Looping Through a String

```javascript
let str = "dog";
for (let i = 0; i < str.length; i++) {
  console.log(str[i]);
}
// Output: d, o, g
```

#### Strings are Immutable
You **can't change characters** in a string directly:

```javascript
let word = "cat";
word[0] = "b";    // ‚ùå Doesn't work
word = "bat";     // ‚úÖ Reassign a new value
```

---

### Null & Undefined
In JavaScript, `null` and `undefined` are **two distinct data types** that both represent the absence of a value ‚Äî but they are **not the same**.

#### üü° `undefined`

- A variable that **has been declared** but **not assigned a value**.

- JavaScript automatically assigns `undefined` to uninitialized variables.

```javascript
let x;
console.log(x);     // undefined
```

- Also returned by functions with no `return`:

```javascript
function doNothing() {}
console.log(doNothing());  // undefined
```

#### üî¥ `null`

- A value that **represents "no value"** or **"nothing"**, **explicitly assigned** by the developer.

- You use `null` when you **want to say**: ‚ÄúThis should have a value, but it doesn‚Äôt yet.‚Äù

```javascript
let y = null;
console.log(y);     // null
```

#### üîç Differences at a Glance:

|Feature|`undefined`|`null`|
|---|---|---|
|Type|`undefined`|`object` (weird legacy quirk)|
|Assigned by|JavaScript (default)|Developer (manually)|
|Meaning|"No value assigned yet"|"Intentionally empty"|
|Use case|Uninitialized variables|Empty/reset values|

#### ‚ö†Ô∏è Comparison:

```javascript
undefined == null     // true (loose equality)
undefined === null    // false (strict equality)
```

> üîë Use `===` for precise comparison in most real-world code.

#### ‚úÖ When to Use Each:

- Use `undefined` when JavaScript does it for you (e.g., uninitialized or missing values).

- Use `null` when **you decide** a value is currently empty or to **clear/reset** something.

---
## Reference Datatypes

### Arrays
In JavaScript, **arrays** are a special type of object used to store ordered collections of values. They can hold elements of any type, including numbers, strings, objects, other arrays, etc.

#### Declaring an Array

```javascript
let fruits = ['apple', 'banana', 'cherry'];
let numbers = [1, 2, 3, 4, 5];
let mixed = [1, 'hello', true, null];
let empty = [];
```

You can also create arrays using the `Array` constructor:

```javascript
let arr = new Array(5); // creates an empty array with length 5
```

#### Accessing Array Elements

```javascript
let colors = ['red', 'green', 'blue'];
console.log(colors[0]); // 'red'
console.log(colors[2]); // 'blue'
```

#### Common Array Methods

- `length` - Print the length of array
	 
```javascript
let arr = [1, 2, 3];
let len = arr.length; // 3
``` 

-  `push()` ‚Äì Add to end
	
```javascript
let arr = [1, 2];
arr.push(3); // [1, 2, 3]
```

-  `pop()` ‚Äì Remove from end
	
```javascript
let arr = [1, 2, 3];
arr.pop(); // returns 3; arr is now [1, 2]
```

-  `shift()` ‚Äì Remove from start
	
```javascript
let arr = [1, 2, 3];
arr.shift(); // returns 1; arr is now [2, 3]
```

-  `unshift()` ‚Äì Add to start
	
```javascript
let arr = [2, 3];
arr.unshift(1); // [1, 2, 3]
```

-  `splice()` ‚Äì Add/Remove at index
	
```javascript
let languages = ["C++", "Java", "JavaScript"];

let sliced = languages.splice(2); // Slicing with main array deletion.
console.log(sliced); // ["JavaScript"]
console.log(languages);	// ["C++", "Java"]

languages.splice(2, 0, "Rust", "Python"); // Adding/deleting at last (push, pop)
console.log(languages); // ["C++", "Java", "Rust", "Python"]

languages.splice(0, 0, "javaScript"); // Adding/deleting at first (unshift, shift)
console.log(languages); // ["JavaScript", "C++", "Java", "Rust", "Python"]

languages.splice(3, 1, "C"); // Replacing any element
console.log(languages); // ["JavaScript", "C++", "Java", "C", "Python"]

languages.splice(2, 0, "TypeScript", "Go"); // Adding in middle of array
console.log(languages); // ["JavaScript", "C++", "Go", "Java", "C", "Python"]
```

-  `slice()` ‚Äì Get part of array
	
```javascript
let allColors = ["red", "yellow", "blue", "violet", "pink", "white"]

console.log("array.slice(starting_index, ending_index)");

console.log(allColors.slice()); 
// ["red", "yellow", "blue", "violet", "pink", "white"];
// a copy of the full array

console.log(allColors.slice(1, 4)); 
// ["yellow", "blue", "violet"]
// 4th index doesn't include. (a copy of 1st to 3rd index)

console.log(allColors.slice(5));
// ["white"]
// ending_index = array.length.

console.log(allColors.slice(-3)); 
// ["violet", "pink", "white"]
// starting_index = array.length - 3 & ending_index = array.length.

console.log(allColors.slice(100)); 
// insufficient indices returns empty array
```

-  `indexOf()` ‚Äì Find index of value
	
```javascript
let arr = ['a', 'b', 'c'];
arr.indexOf('b'); // 1
```

-  `includes()` ‚Äì Check if exists
	
```javascript
let arr = [1, 2, 3];
arr.includes(2); // true
arr.includes(4); // false
```

-  `forEach()` ‚Äì Loop through elements
	
```javascript
let arr = [1, 2, 3];
arr.forEach(num => {
  console.log(num * 2); // 2, 4, 6
});
```

-  `map()` ‚Äì Transform elements
	
```javascript
let arr = [1, 2, 3];
let doubled = arr.map(n => n * 2); // [2, 4, 6]
```

-  `filter()` ‚Äì Keep elements that match condition
	
```javascript
let arr = [1, 2, 3, 4];
let evens = arr.filter(n => n % 2 === 0); // [2, 4]
```

-  `reduce()` ‚Äì Reduce to single value
	
```javascript
let arr = [1, 2, 3, 4];
let sum = arr.reduce((acc, curr) => acc + curr, 0); // 10
```

-  `join()` ‚Äì Combine elements into string
	
```javascript
let arr = ['a', 'b', 'c'];
arr.join('-'); // "a-b-c"
```

-  `sort()` ‚Äì Sort elements (as strings by default)
	
```javascript
let arr = [3, 1, 4, 2];
arr.sort(); // [1, 2, 3, 4] (numbers may not sort as expected without a compare function)

let names = ['Zoe', 'Adam', 'John'];
names.sort(); // ['Adam', 'John', 'Zoe']
```
	
   | Custom sort:
	
```javascript
arr.sort((a, b) => a - b); // numeric sort ascending
```

-  `reverse()` ‚Äì Reverse the array
	
```javascript
let arr = [1, 2, 3];
arr.reverse(); // [3, 2, 1]
```

- `every()` - Checks if **all elements** in an array satisfy a given condition (returns `true` or `false`).
	
```js
const numbers = [2, 4, 6, 8];
const allEven = numbers.every(num => num % 2 === 0);
console.log(allEven); // true
```

- `some()` - Checks if **at least one element** in the array satisfies the given condition.
	
```js
const numbers = [1, 3, 5, 6];
const hasEven = numbers.some(num => num % 2 === 0);
console.log(hasEven); // true
```

	 Use Cases

| Method  | When to Use                             | Result Interpretation                     |
| ------- | --------------------------------------- | ----------------------------------------- |
| `every` | Validate that **all items** meet a rule | Returns `true` only if all pass           |
| `some`  | Check if **any item** meets a rule      | Returns `true` if **at least one** passes |

#### Array References
In JavaScript, arrays are **reference types**, which means when you assign an array to another variable or pass it into a function, you're passing a **reference to the same array in memory**, not a copy of the array.

##### ‚úÖ **Example: Array Reference Behavior**

```javascript
let arr1 = [1, 2, 3];
let arr2 = arr1;

arr2[0] = 99;

console.log(arr1); // [99, 2, 3]
console.log(arr2); // [99, 2, 3]
```

**Why?** Because `arr2 = arr1` creates a reference to the same array in memory. Modifying `arr2` also modifies `arr1`.

##### üôÖ **How to Copy an Array (Avoid Reference)**
If you want to copy an array instead of referencing it:

1. **Spread Operator**
	
```javascript
let arr1 = [1, 2, 3];
let arr2 = [...arr1];
arr2[0] = 99;

console.log(arr1); // [1, 2, 3]
```

2. **`slice()` Method**
	
```javascript
let arr2 = arr1.slice();
```

3. **`Array.from()`**
	
```javascript
let arr2 = Array.from(arr1);
```

4. **`concat()`**
	
```javascript
let arr2 = [].concat(arr1);
```

##### üìù **Deep vs Shallow Copy**
All the methods above create a **shallow copy**‚Äîthey copy the top-level elements. If the array contains objects or other arrays, their references will still be shared.

```javascript
let arr1 = [{ a: 1 }];
let arr2 = [...arr1];

arr2[0].a = 99;

console.log(arr1); // [{ a: 99 }] ‚Äî shared reference to the object
```

To avoid this, you need a **deep copy**, often done with:

```javascript
let arr2 = JSON.parse(JSON.stringify(arr1)); // simple but limited method
```

Or using libraries like Lodash:

```javascript
let arr2 = _.cloneDeep(arr1);
```

#### Nested Arrays in JavaScript

In JavaScript, **nested arrays** are arrays that contain other arrays as elements. This is commonly used to represent **matrices**, **grids**, or **tree-like data structures**.

##### ‚úÖ **Basic Example**

```javascript
let nestedArray = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

console.log(nestedArray[0]);    // [1, 2, 3]
console.log(nestedArray[0][1]); // 2
```

##### üîÑ **Looping Through a Nested Array**

```javascript
for (let i = 0; i < nestedArray.length; i++) {
  for (let j = 0; j < nestedArray[i].length; j++) {
    console.log(`Element at [${i}][${j}]:`, nestedArray[i][j]);
  }
}
```

Or using `forEach`:

```javascript
nestedArray.forEach((row, i) => {
  row.forEach((value, j) => {
    console.log(`Element at [${i}][${j}]:`, value);
  });
});
```

##### ‚úèÔ∏è **Modifying Nested Array Values**

```javascript
nestedArray[1][2] = 99;
console.log(nestedArray); // [[1, 2, 3], [4, 5, 99], [7, 8, 9]]
```

##### üîç **Flattening a Nested Array**

1. One Level Deep
	
```javascript
let flat = nestedArray.flat();
console.log(flat); // [1, 2, 3, 4, 5, 99, 7, 8, 9]
```

2. Deeply Nested Example
	
```javascript
let deepNested = [1, [2, [3, [4]]]];
let flatAll = deepNested.flat(Infinity);
console.log(flatAll); // [1, 2, 3, 4]
```

##### üß† **Use Cases**

- **Matrices:** `matrix[row][col]`

- **Game Boards:** `board[y][x]`

- **Hierarchical Data:** Nested lists or trees

---

### Object Literals
In JavaScript, **object literals** are a way to create objects using a concise syntax. An object literal is a comma-separated list of key-value pairs enclosed in curly braces `{}`.

#### Basic Syntax

```javascript
const person = {
  name: "Alice",
  age: 30,
  isStudent: false
};
```

- `name`, `age`, and `isStudent` are **keys** (also called properties).

- `"Alice"`, `30`, and `false` are the corresponding **values**.

#### Object Property Manipulation
##### üéØ **Accessing Object Properties**
You can access properties using:

- **Dot notation**:
    
```javascript
console.log(person.name); // "Alice"
```

- **Bracket notation** (useful when the key is dynamic or not a valid identifier):
    
```javascript
console.log(person["age"]); // 30
```

‚≠ê‚≠ê‚≠ê<mark style="background: #ABF7F7A6;">Remember: </mark>‚≠ê‚≠ê‚≠ê
```javascript
// Unusual keys and values
const unusual = {
	1: "a",
	2: "b",
	3: "c",
	// 1null: "d", // throws error because, naming rules not followed
	null: "no_value", // then it throws error!!
	true: "truth",
	const: "constant",
	let: "variable",
};
console.log(unusual); // makes the keys a string.
console.log(unusual.null);
console.log(unusual[null]);

console.log(unusual[true]); // first true converted to string then compared.
// console.log(unusual[const]); // Why it throws error? = because it is a identifier and compiler thought you want to declare a variable
console.log(unusual["const"]);

// console.log(unusual.1); // throws error.
console.log(unusual.null); // why this works but not 1? = because 1 is not valid identifier but null is.

// Conclusion = valid identifiers, numbers, reserved keywords can be used a key (only, no naming rules should be broken) & on the other hand dot notation only handles valid identifiers and reserved keywords not numbers........ this is stupid!! It just shows the incompleteness of JS
```

##### ‚úçÔ∏è **Adding or Modifying Properties**

```javascript
person.job = "Developer";      // Add new property
person.age = 31;               // Modify existing property
```

##### ‚ûñ **Removing Properties**

```javascript
delete person.isStudent;
```

#### Multi level Objects
##### üî∂ **Methods in Object Literals**
You can include functions (methods) in objects:

```javascript
const calculator = {
  add(a, b) {
    return a + b;
  }
};

console.log(calculator.add(2, 3)); // 5
```

##### üî∂ **Nested Objects**

```javascript
const user = {
  name: "Bob",
  address: {
    city: "New York",
    zip: "10001"
  }
};

console.log(user.address.city); // "New York"
```

##### üî∂ **Array of Objects**
```javascript
Const users = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 22 }
];

console.log(users[0].name); // "Alice"
console.log(users[2].age);  // 22
```

#### Dynamic Property Names

You can use **computed property names**:

```javascript
const key = "score";
const game = {
  [key]: 100
};

console.log(game.score); // 100
```

---

## Keywords in JavaScript
In **JavaScript**, **keywords** are **reserved words** that have special meaning in the language. You **cannot use them as variable names**, function names, or identifiers.

### ‚úÖ Common JavaScript Keywords (with meanings)

| Learn | Keyword      | Description                                          | Example                         |
| :---: | ------------ | ---------------------------------------------------- | ------------------------------- |
|   ‚úÖ   | `var`        | Declares a variable (function-scoped, old style)     | `var x = 5;`                    |
|   ‚úÖ   | `let`        | Declares a block-scoped variable (modern)            | `let age = 25;`                 |
|   ‚úÖ   | `const`      | Declares a block-scoped constant                     | `const PI = 3.14;`              |
|       | `function`   | Declares a function                                  | `function greet() {}`           |
|       | `return`     | Returns a value from a function                      | `return x + y;`                 |
|   ‚úÖ   | `if`         | Starts a conditional block                           | `if (x > 5) { ... }`            |
|   ‚úÖ   | `else`       | Specifies code to run if `if` condition is false     | `else { ... }`                  |
|   ‚úÖ   | `switch`     | Conditional selection among multiple cases           | `switch(x) { case 1: ... }`     |
|       | `case`       | Defines a condition in a `switch` block              | `case 2: break;`                |
|   ‚úÖ   | `break`      | Exits a loop or switch                               | `break;`                        |
|       | `continue`   | Skips to the next loop iteration                     | `continue;`                     |
|   ‚úÖ   | `for`        | Starts a loop                                        | `for (let i = 0; i < 5; i++)`   |
|       | `while`      | Starts a loop that continues while condition is true | `while (i < 5) { ... }`         |
|       | `do`         | Like `while`, but runs at least once                 | `do { ... } while (i < 5);`     |
|       | `try`        | Starts a block to test for errors                    | `try { ... }`                   |
|       | `catch`      | Handles errors from `try`                            | `catch (error) { ... }`         |
|       | `finally`    | Runs after `try`/`catch` regardless of outcome       | `finally { ... }`               |
|       | `throw`      | Manually throws an error                             | `throw new Error("Oops")`       |
|       | `class`      | Declares a class                                     | `class Car {}`                  |
|       | `new`        | Creates an instance of an object                     | `new Date()`                    |
|       | `this`       | Refers to the current object                         | `this.name`                     |
|   ‚úÖ   | `typeof`     | Returns the type of a variable                       | `typeof "hello"`                |
|       | `delete`     | Deletes an object property                           | `delete obj.name;`              |
|       | `in`         | Checks if property exists in object                  | `"name" in obj`                 |
|       | `instanceof` | Checks if object is an instance of a class           | `obj instanceof Car`            |
|       | `void`       | Evaluates expression without returning value         | `void(0)`                       |
|       | `await`      | Waits for a promise to resolve (in `async` funcs)    | `await fetch()`                 |
|       | `async`      | Declares an asynchronous function                    | `async function fetchData() {}` |
|       | `import`     | Imports functions/modules (ES6)                      | `import fs from "fs";`          |
|       | `export`     | Exports functions/modules                            | `export default function() {}`  |
|       | `super`      | Calls a parent class constructor                     | `super()`                       |
|       | `extends`    | Creates a class that inherits from another class     | `class Dog extends Animal`      |

### ‚ùå Reserved but rarely used:

These are usually reserved for future use or advanced cases:

- `enum`, `yield`, `with`, `debugger`, `implements`, `interface`, `package`, `protected`, `private`, `public`, `static`, `let` (in older JS, treated as reserved).

### ‚ö†Ô∏è You **can't** use these as variable names:

```javascript
let return = 5;     // ‚ùå SyntaxError
const if = "test";  // ‚ùå SyntaxError
```

---

## Operators & operator precedence in JavaScript
In **JavaScript**, **operators** are symbols used to **perform operations** on variables and values ‚Äî like addition, comparison, or logic. **Operator precedence** determines **which operation runs first** when multiple operators appear in one expression.

### Types of Operators

#### 1. Arithmetic Operators

| Operator | Meaning        | Example  | Result      |
| -------- | -------------- | -------- | ----------- |
| `+`      | Addition       | `5 + 2`  | `7`         |
| `-`      | Subtraction    | `5 - 2`  | `3`         |
| `*`      | Multiplication | `5 * 2`  | `10`        |
| `/`      | Division       | `10 / 2` | `5`         |
| `%`      | Modulus        | `5 % 2`  | `1`         |
| `**`     | Exponentiation | `2 ** 3` | `8`         |
| `++`     | Increment      | `x++`    | Adds 1      |
| `--`     | Decrement      | `x--`    | Subtracts 1 |

#### 2. Assignment Operators

| Operator | Meaning           | Example                |
| -------- | ----------------- | ---------------------- |
| `=`      | Assign value      | `x = 5`                |
| `+=`     | Add & assign      | `x += 3` ‚Üí `x = x + 3` |
| `-=`     | Subtract & assign | `x -= 2`               |
| `*=`     | Multiply & assign | `x *= 2`               |
| `/=`     | Divide & assign   | `x /= 2`               |
| `%=`     | Modulus & assign  | `x %= 2`               |

#### 3. Comparison Operators

| Operator | Meaning               | Example     | Result  |
| -------- | --------------------- | ----------- | ------- |
| `==`     | Equal (loose)         | `5 == "5"`  | `true`  |
| `===`    | Equal (strict)        | `5 === "5"` | `false` |
| `!=`     | Not equal (loose)     | `5 != "5"`  | `false` |
| `!==`    | Not equal (strict)    | `5 !== "5"` | `true`  |
| `>`      | Greater than          | `7 > 5`     | `true`  |
| `<`      | Less than             | `5 < 7`     | `true`  |
| `>=`     | Greater than or equal | `5 >= 5`    | `true`  |
| `<=`     | Less than or equal    | `4 <= 3`    | `false` |

#### 4. Logical Operators

| Operator | Meaning     | Example          | Result  |
| -------- | ----------- | ---------------- | ------- |
| `&&`     | Logical AND | `true && false`  | `false` |
| \| \|    | Logical OR  | true \| \| false | `true`  |
| `!`      | Logical NOT | `!true`          | `false` |

#### 5. String Concatenation

```javascript
"Hello" + " World"   // "Hello World"
```

#### 6. Ternary Operator (conditional)

```javascript
let result = (age >= 18) ? "Adult" : "Minor";
```

#### 7. `typeof` & ` instanceof`

```javascript
typeof "hello";        // "string"
x instanceof Array;    // true or false
```

---

### Operator Precedence
**Operator precedence** determines the order in which operations are executed.

> Think of it like **math rules**: `()` comes before `*`, which comes before `+`.

#### üìä Precedence Table (high to low)

| Precedence | Operator (s)              | Type            |
| ---------- | ------------------------- | --------------- |
| 20         | `()`                      | Grouping        |
| 17         | `new`, `super`            | Object creation |
| 16         | `++`, `--` (postfix)      | Increment       |
| 15         | `!`, `++`, `--`, `typeof` | Unary           |
| 14         | `**`                      | Exponentiation  |
| 13         | `*`, `/`, `%`             | Multiply, etc.  |
| 12         | `+`, `-`                  | Add/Subtract    |
| 11         | `<<`, `>>`, `>>>`         | Bitwise shifts  |
| 10         | `<`, `<=`, `>`, `>=`      | Comparison      |
| 9          | `==`, `!=`, `===`, `!==`  | Equality        |
| 6          | `&&`                      | Logical AND     |
| 5          | \| \|                     | Logical OR      |
| 4          | `? :`                     | Ternary         |
| 3          | `=`, `+=`, `-=` etc.      | Assignment      |

#### üîç Example:

```javascript
let result = 3 + 4 * 5;   // 3 + (4 * 5) = 23 (not 35)
```

Use parentheses `()` to control precedence:

```javascript
let fixed = (3 + 4) * 5;  // 7 * 5 = 35
```

---

## Identifier Rules in JavaScript
In **JavaScript**, an **identifier** is the **name** used to identify variables, functions, classes, or other user-defined elements.

### Identifier Rules in JavaScript
Here are the **rules** for writing valid identifiers (names):

#### 1. Can contain:

- Letters (A‚ÄìZ, a‚Äìz)

- Digits (0‚Äì9)

- Underscores `_`

- Dollar signs `$`

#### 2. Must NOT:

- **Begin with a number**  
    ‚ùå `1name` is invalid  
    ‚úÖ `name1` is valid

- **Use reserved keywords** like `let`, `class`, `return`, etc.

#### 3. Case sensitive
`Name`, `name`, and `NAME` are **different** identifiers.

#### 4. Can include Unicode letters
You can technically use things like:

```javascript
let caf√© = "coffee";  // valid
```

### Examples

#### üü¢ Valid Identifiers

```javascript
let user;
let _private;
let $dollar;
let userName;
let user123;
```

#### üî¥ Invalid Identifiers

```javascript
let 2ndUser;     // ‚ùå starts with number
let let;         // ‚ùå keyword
let user-name;   // ‚ùå hyphen not allowed
let @home;       // ‚ùå special symbol
```

### Which Identifiers Are Used in JavaScript?
JavaScript frequently uses:

- `camelCase` for variables/functions: `userName`, `getData()`

- `PascalCase` for classes/constructors: `Person`, `CarModel`

- `_underscore` prefix for private/internal variables: `_id`

- `$dollar` prefix in libraries (like jQuery): `$`, `$element`

---

## Output methods in JavaScript
In JavaScript, there are several methods to **output data**. Here's a list of the most commonly used ones, depending on your context (web page, console, alert, etc.):

### üñ•Ô∏è 1. `console.log()`

- **Use**: Outputs to the browser's console (mainly for debugging).

```javascript
console.log("Hello, world!");
```

### üó®Ô∏è 2. `alert()`

- **Use**: Shows a popup alert box in the browser.

```javascript
alert("This is an alert box!");
```

### ‚úçÔ∏è 3. `document.write()`

- **Use**: Writes directly to the HTML document. _Not recommended for modern use_ (especially after page load).
    

```javascript
document.write("This is written to the page.");
```

### üì§ 4. `innerHTML`

- **Use**: Inserts content into an HTML element.

```html
<div id="output"></div>

<script>
  document.getElementById("output").innerHTML = "Output via innerHTML";
</script>
```

### üìã 5. `window.prompt()`

- **Use**: Outputs a message and takes user input.

```javascript
var name = prompt("Enter your name:");
console.log("Hello, " + name);
```

### üì¨ 6. `confirm()`

- **Use**: Shows a confirmation dialog with OK/Cancel.

```javascript
var result = confirm("Are you sure?");
console.log(result);  // true or false
```

### üß± 7. [[DOM]] manipulation methods (like `createElement`, `appendChild`)

- **Use**: Dynamically creates and displays elements.

```javascript
let p = document.createElement("p");
p.textContent = "This was created dynamically!";
document.body.appendChild(p);
```

---

## Conditional Statements in JavaScript
Conditional statements **control the flow** of your program based on **conditions** (true/false values).

### 1. `if` Statement
Executes a block if the condition is true.

```javascript
let age = 20;

if (age >= 18) {
  console.log("You are an adult.");
}
```

### 2. `if...else` Statement
Adds an alternative if the condition is false.

```javascript
let age = 16;

if (age >= 18) {
  console.log("You can vote.");
} else {
  console.log("You are too young to vote.");
}
```

### 3. `if...else if...else` Statement
Tests multiple conditions in order.

```javascript
let score = 85;

if (score >= 90) {
  console.log("Grade: A");
} else if (score >= 80) {
  console.log("Grade: B");
} else {
  console.log("Grade: C or below");
}
```

### 4. `switch` Statement
Better for checking one variable against multiple exact values.

```javascript
let color = "blue";

switch (color) {
  case "red":
    console.log("Color is red");
    break;
  case "blue":
    console.log("Color is blue");
    break;
  default:
    console.log("Unknown color");
}
```

### 5. Ternary Operator (`? :`)
A shorthand for simple `if...else`.

```javascript
let age = 18;
let message = (age >= 18) ? "Adult" : "Minor";
console.log(message);
```

---

## Loops in JavaScript
Loops in JavaScript allow you to execute a block of code repeatedly, based on a condition. Here‚Äôs a breakdown of the main types of loops in JavaScript:

### For Loops
**For loops** are the most **common** type of loops.
#### üîÅ Basic `for` Loop Syntax

```javascript
for (initialization; condition; increment) {
	// code to execute 
}
```

- **`initialization`** ‚Äì runs once before the loop starts (usually used to declare a counter variable).

- **`condition`** ‚Äì the loop runs **while this condition is true**.

- **`increment`** ‚Äì runs **after each iteration**.

#### ‚úÖ Example

```javascript
for (let i = 0; i <= 5; i++) {   
	console.log(i); 
}
```

üì§ Output:

```
1
2
3
4
5
```

### While Loops
A **while loop** repeatedly executes a block of code **as long as a specified condition is `true`**.

#### üîÅ Basic `while` Loop Syntax

```javascript
while (condition) {
  // code block to be executed
}
```

- The condition is checked **before** the code block runs.

- If the condition is `false`, the loop **does not run at all**.

#### ‚úÖ Example

```javascript
let i = 1;
while (i <= 5) {
  console.log(i);
  i++;
}
```

üì§ Output:

```
1
2
3
4
5
```

### For... Of Loops
The `for...of` loop is used to **iterate over iterate-able objects** like:

- Arrays

- Strings

- Maps

- Sets

- [[DOM]] NodeLists, etc.

#### üîÅ Basic `for...of` Loop Syntax

```javascript
for (const element of iterable) {
  // code to execute
}
```

#### ‚úÖ Example: Loop Through an Array

```javascript
const fruits = ['apple', 'banana', 'cherry'];

for (const fruit of fruits) {
  console.log(fruit);
}
```

üì§ Output:

```
apple
banana
cherry
```

### For... In Loops
The `for...in` loop is used to **iterate over the enumerable properties (keys)** of an object.

#### üîÅ Basic `for...in` Loop Syntax

```javascript
for (const key in object) {
  // code to execute
}
```

- Iterates over all **enumerable string keys** in an object (including inherited properties if not filtered).

#### ‚úÖ Example: Loop Through an Object

```javascript
const person = {
  name: "Alice",
  age: 30,
  job: "Developer"
};

for (const key in person) {
  console.log(`${key}: ${person[key]}`);
}
```

üì§ Output:

```
name: Alice
age: 30
job: Developer
```

#### ‚ö†Ô∏è `for...in` with Arrays ‚Äì Be Careful

```javascript
const colors = ['red', 'green', 'blue'];

for (const index in colors) {
  console.log(index, colors[index]);
}
```

üì§ Output:

```
0 red
1 green
2 blue
```

- This **loops over indices**, not values.

- Use `for...of` for array **values** instead.

#### üõë Inherited Properties Warning
`for...in` will also iterate over **inherited properties**, unless you filter them:

```javascript
const obj = Object.create({ inherited: true });
obj.own = 'yes';

for (const key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(key); // only "own"
  }
}
```

#### ‚úÖ Use Cases

- Best for looping through **object properties**

- Avoid for arrays unless you need **indices** (use `for` or `for...of` for values)


### `do...while` Loop in JavaScript
The `do...while` loop is similar to a `while` loop, **but it always executes the code block at least once**, **before** checking the condition.

#### üîÅ Basic `do...while` Loop Syntax

```javascript
do {
  // code block to execute
} while (condition);
```

- The block runs **once before** the condition is checked.

- If the condition is true, it runs again‚Äîand repeats until the condition is false.

#### ‚úÖ Example

```javascript
let i = 1;

do {
  console.log(i);
  i++;
} while (i <= 5);
```

üì§ Output:

```
1
2
3
4
5
```

#### ‚úÖ When to Use `do...while`:

- Use when the **code should run at least once**, even if the condition is initially false.

- Input validation loops (run at least once)

- Menus or retry systems

- Scenarios where action must happen before the condition is meaningful


### `break` and `continue` in JavaScript Loops
These are **control flow statements** that help you manage how loops behave.

#### üîì `break` ‚Äì **Exits** the Loop Immediately
When JavaScript encounters a `break` statement inside a loop, it **stops** the loop right there and jumps to the next line **after** the loop.

‚úÖ Example:

```javascript
for (let i = 1; i <= 5; i++) {
  if (i === 3) break;
  console.log(i);
}
```

üì§ Output:

```
1
2
```

#### ‚è≠Ô∏è `continue` ‚Äì **Skips** to the Next Iteration
When JavaScript encounters `continue`, it **skips the rest of the current iteration** and jumps back to the loop condition for the next cycle.

‚úÖ Example:

```javascript
for (let i = 1; i <= 5; i++) {
  if (i === 3) continue;
  console.log(i);
}
```

üì§ Output:

```
1
2
4
5
```

#### ‚ö†Ô∏è Tip

Using `break` or `continue` too much can make your code harder to read. Use them when:

- `break`: You want to stop the loop based on a condition.

- `continue`: You want to skip specific values or cases.

---

## Math Methods in JavaScript (`Math` Object)
JavaScript provides a built-in `Math` object with **properties and methods** for performing mathematical tasks.

### üìå Most-Used `Math` Methods

|Method|Description|Example|Result|
|---|---|---|---|
|`Math.abs(x)`|Returns absolute value|`Math.abs(-7)`|`7`|
|`Math.ceil(x)`|Rounds **up** to the nearest integer|`Math.ceil(4.2)`|`5`|
|`Math.floor(x)`|Rounds **down** to the nearest integer|`Math.floor(4.9)`|`4`|
|`Math.round(x)`|Rounds to the **nearest** integer|`Math.round(4.5)`|`5`|
|`Math.trunc(x)`|Removes decimal part (no rounding)|`Math.trunc(4.9)`|`4`|
|`Math.max(...values)`|Returns the **largest** number|`Math.max(3, 5, 1)`|`5`|
|`Math.min(...values)`|Returns the **smallest** number|`Math.min(3, 5, 1)`|`1`|
|`Math.sqrt(x)`|Square root|`Math.sqrt(16)`|`4`|
|`Math.pow(x, y)`|`x` to the power of `y`|`Math.pow(2, 3)`|`8`|
|`Math.random()`|Random number between `0` and `1`|‚Äî|e.g. `0.7356`|
|`Math.PI`|œÄ constant|`Math.PI`|`3.14159...`|

### üìê More Advanced

| Method                                        | Description                                       |
| --------------------------------------------- | ------------------------------------------------- |
| `Math.sin(x)` / `Math.cos(x)` / `Math.tan(x)` | Trigonometric functions (in radians)              |
| `Math.log(x)`                                 | Natural logarithm (base **e**)                    |
| `Math.log10(x)`                               | Log base 10                                       |
| `Math.exp(x)`                                 | Exponential function, returns `e^x`               |
| `Math.cbrt(x)`                                | Cube root                                         |
| `Math.hypot(a, b)`                            | Returns ‚àö(a¬≤ + b¬≤) (like the Pythagorean theorem) |

### üçÄ Generating Random Number

``` javascript
// Generate a random number in between [0,1)
console.log(Math.random()); 

// Generate a random integer in between [1, 10]
console.log(Math.floor(Math.random() * 10) + 1); 

// General formula
Math.floor(Math.random() * (max -min + 1)) + min
```

---

## Functions in JavaScript
A **function** is a reusable block of code that performs a specific task.

Think of it like a **tool** in a toolbox: when you need to perform a task (e.g., calculate a number, fetch data, modify an object), you use that tool.

### Syntax:

```js
function functionName(parameters) {
  // code to execute
  return result; // optional
}
```

### Function Types in JavaScript

#### A. Function Declaration

```js
function greet(name) {
  return `Hello, ${name}`;
}
```

- **Hoisted**: Can be used before it's defined in the code.

#### B. Function Expression

```js
const greet = function(name) {
  return `Hello, ${name}`;
};
```

- Not hoisted. Safer in larger apps due to scope clarity.

#### C. Arrow Function (ES6+)

```js
const greet = (name) => `Hello, ${name}`;
```

- Shorter syntax.

- Doesn‚Äôt have its own `this`, `arguments`, or `super`.

- Great for **callbacks**, **array methods**, and **functional programming**.

### Parameters vs Arguments

```js
function sum(a, b) {
  return a + b; // 'a' and 'b' are parameters
}

sum(5, 10); // 5 and 10 are arguments
```

#### üîπDefault Parameters

```js
function greet(name = "Guest") {
  return `Hello, ${name}`;
}
```

#### üîπRest Parameters & Spread Syntax

```js
function sumAll(...nums) {
  return nums.reduce((acc, val) => acc + val, 0);
}
sumAll(1, 2, 3, 4); // 10
```

### Callback Functions

> A function passed as an argument to another function.

```js
function fetchData(callback) {
  setTimeout(() => {
    callback("Data loaded");
  }, 1000);
}

fetchData((data) => console.log(data)); // "Data loaded"
```

### Anonymous Functions

> Functions without a name (often used inline).

```js
setTimeout(function () {
  console.log("Executed after 1 second");
}, 1000);
```

### IIFE (Immediately Invoked Function Expression)
Executes **immediately** after creation. Good for **isolated scope**, often used in **modular design**.

```js
(function() {
  console.log("This runs immediately");
})();
```

### Higher-Order Functions (HOFs)

> Functions that **take other functions** as arguments or **return functions**.

```js
function multiply(factor) {
  return function(num) {
    return num * factor;
  };
}

const double = multiply(2);
console.log(double(5)); // 10
```

This is where **JavaScript power** really shines ‚Äî used heavily in frameworks, FP (Functional Programming), and more.

### Closures

A function that **remembers** its lexical scope, even when the outer function has finished execution.

```js
function outer() {
  let count = 0;
  return function() {
    count++;
    return count;
  };
}

const counter = outer();
console.log(counter()); // 1
console.log(counter()); // 2
```

Use cases:

- Data encapsulation

- Private variables

- Functional state

### Async Functions
An `async` function in JavaScript is a modern syntax for writing asynchronous code that looks and behaves more like synchronous code. It returns a **Promise**, and allows you to use the `await` keyword inside it to pause execution until a **Promise** is resolved or rejected.

#### üîß How It Works

1. When you declare a function with `async`, it **always returns a Promise**.

2. Inside an `async` function, you can use `await` to wait for a Promise to resolve/reject.

3. If the awaited Promise is resolved, the result is returned.

4. If it's rejected, it throws an error ‚Äî you handle it with `try/catch`.

#### üí° Example

```js
// Async keyword
function add(a, b) {
    // Normal function
    return a + b;
}

async function greet() {
    // async function -> returns a promise by default
    
    let netSpeed = Math.floor(Math.random() * 10) + 1;
    
    if (netSpeed > 5) {
        return "Hello!"; 
        // if resolved (netSpeed > 5) then a fulfilled promise will 'return'
    } else {
        throw "Weak Connection!"; 
        // If not (netSpeed <= 5) then a rejected promise will 'throw'
    }
}
greet()
    .then((result) => console.log("Operation succeeded! Stored:", result))
    .catch((err) =>
        console.log("An unexpected error occurred! Error:", err)
    );

function newNum() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            let num = Math.floor(Math.random() * 100) + 1;
            console.log(num);
            resolve();
        }, 1000);
    });
}

async function getNewNum(num) {
    for (let i = 0; i <= num; i++) {
        await newNum();
    }
    console.log("Operation completed");
}
getNewNum(20);

// Ok... Explanation time! We transfer the core logic to a normal function newNum. In real world it could be some APIs permissions from user, DB related work.... Which means it can take a good amount of time (variable)... but we need to execute them one after another... we can use promises, .then, .catch. But, we have much readable way!

// The await keyword can be used only if the function is async! It's the core reason to make getNewNum a async one.

// With await keyword, we trying to say to single threaded js "That's greet, you are giving the async task to the browser but in this task wait for browser for reply.". It has a much better syntax than callback hell & .then, .catch.

// Problem!!! : Let's take the above example, if one of the promises rejects then... BOOMüí•... the code execution will stop and the "Completed" message will never be displayed...even though the message was not directly associate to the awaits.

// Solution: try & catch block!
// Let's refactor the fist example of this & add a 5 sec timer for each task!

function job() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            let netSpeed = Math.floor(Math.random() * 10) + 1;
            if (netSpeed > 5) {
                resolve("Hello!");
            } else {
                reject("Weak Connection!");
            }
        }, 5000);
    });
}

async function doTheJob(num) {
    try {
        for (let i = 0; i <= num; i++) {
            let message = await job();
            console.log("Operation succeeded! Stored:", message);
        }
    } catch (err) {
        console.log("An unexpected error occurred! Error:", err);
    }
	
    // This will now run even though the above code throws error.
    let pass = true;
    console.log(typeof pass);
}
doTheJob(5);

// Keep core logic in normal functions. Use async only when necessary ‚Äî like for orchestration (calling, sequencing, awaiting).
```

#### üß† Key Points

- `await` can **only** be used inside an `async` function.

- Makes code cleaner than using `.then()` and `.catch()`.

- Helps avoid "callback hell" and deeply nested Promises.

#### üîç Behind the Scenes
This:

```js
async function example() {
  return "Hello";
}
```

Is basically this under the hood:

```js
function example() {
  return Promise.resolve("Hello");
}
```

### Methods
**Methods** are nothing but **functions in an object literal**.

```js
const Calculator = {
	add: function (a, b) { // Functions inside objects call method
		return a + b;
	},
	sub: function (a, b) {
		return a - b;
	},
	mul(a, b) { // Shorthand to create method	
		return a * b;
	},
	div(a, b) {
		return a / b;
	},
};

console.log(Calculator.add(2, 3));

console.log(Calculator.sub(60, 20));

console.log(Calculator.mul(3, 6));

console.log(Calculator.div(5, 2));

```

### SetTimeout function
The `setTimeout()` function in JavaScript is used to **execute a piece of code after a specified delay** (in milliseconds). It‚Äôs part of the **Web APIs**, provided by the browser environment, not the core JavaScript language itself.
#### üîß Syntax:

```javascript
setTimeout(callback, delay, ...args);
```

- `callback` ‚Äì The function to execute after the delay.

- `delay` ‚Äì Time to wait before executing the function (in **milliseconds**).

- `...args` ‚Äì Optional arguments to pass to the callback function.

---

#### ‚úÖ Example:

```javascript
console.log("Start");

setTimeout(() => {
  console.log("This runs after 2 seconds");
}, 2000);

console.log("End");
```

Output:

```
Start
End
This runs after 2 seconds
```

üîç **Explanation**:  
JavaScript is non-blocking and asynchronous. So even though you set a timeout, the rest of the code continues executing without waiting.

#### ‚õî Clearing a Timeout
You can cancel a timeout using `clearTimeout()` if it hasn‚Äôt fired yet.

```javascript
const id = setTimeout(() => {
  console.log("This won't run");
}, 3000);

clearTimeout(id);
```

### SetInterval function
The `setInterval` function in JavaScript is used to **repeatedly execute a function at specified time intervals** (in milliseconds). It's part of the Web APIs provided by browsers and also available in Node.js.

#### üîß Syntax:

```javascript
let intervalID = setInterval(function, delay, param1, param2, ...);
```

- `function` ‚Äì The function to be executed.

- `delay` ‚Äì Time in **milliseconds** between executions.

- `param1, param2, ...` ‚Äì Optional parameters passed to the function.

#### ‚õî Stopping `setInterval`:

Use `clearInterval(intervalID)` where `intervalID` is the identifier returned by `setInterval`.

#### ‚ö†Ô∏è Warning:

- **setInterval is not precise**. It doesn't guarantee exact timing due to event loop delays. If the callback takes longer than the interval, delays stack up.

- **Memory leaks**: Forgetting `clearInterval()` leads to infinite loops and memory issues in long-running apps.

####  Bonus: setTimeout vs setInterval

|Feature|`setTimeout()`|`setInterval()`|
|---|---|---|
|Runs after|One-time delay|Repeats at every interval|
|Can be recursive|Yes (by calling it again)|No (needs `clearInterval`)|
|Control|More control with recursion|Harder to manage dynamically|

### Call Stack in JavaScript
The **call stack** is a **mechanism that tracks function execution** in JavaScript. It works on the **LIFO (Last In, First Out)** principle ‚Äî meaning the **last function called is the first one to finish and get removed**.

#### üîß How It Works ‚Äî Step by Step

1. **Function is called ‚Üí pushed onto the stack**

2. **That function calls another ‚Üí new one pushed on top**

3. **When a function completes ‚Üí popped off the stack**

4. **The stack unwinds until all functions are done**

#### üß† Example

```js
function one() {
    return 1;
}

function two() {
    return one() + one();
}

function three() {
    let ans = two() + one();
    console.log(ans);
}

three();
```

### üëÅÔ∏è‚Äçüó®Ô∏è Visualization

```text
Step 1: Call -> three() (JS line = 18)
    Stack - +--------------------------+
            |          Three           |
            | ans (local) = undefined  |
            | calling -> two (Char=19) |
            +--------------------------+

Step 2: Call -> two() (JS line = 14)
    Stack - +--------------------------+
            |           Two            |
            |       return pending     |
            | calling -> one (Char=16) |
            +--------------------------+
            |          Three           |
            | ans (local) = undefined  |
            |       (calling)          |
            +--------------------------+

Step 3: Call -> one() (JS line = 5)
    Stack - +--------------------------+
            |           One            |
            |         return 1         |
            +--------------------------+
            |           Two            |
            | return pending (calling) |
            +--------------------------+
            |          Three           |
            | ans (local) = undefined  |
            |       (calling)          |
            +--------------------------+

Step 4: returns value 1 (JS line = 7)
    Stack - +--------------------------+
            |           Two            |
            |    return 1 + pending    |
            | calling -> one (Char=24) |
            +--------------------------+
            |          Three           |
            | ans (local) = undefined  |
            |       (calling)          |
            +--------------------------+

Step 5: Call -> one() (JS line = 10)
    Stack - +--------------------------+
            |           One            |
            |         return 1         |
            +--------------------------+
            |           Two            |
            |    return 1 + pending    |
            |       (calling)          |
            +--------------------------+
            |          Three           |
            | ans (local) = undefined  |
            |       (calling)          |
            +--------------------------+

Step 6: Calculate value 2 (JS line = 10)
    Stack - +--------------------------+
            |           Two            |
            |    return (1 + 1) = 2    |
            +--------------------------+
            |          Three           |
            | ans (local) = undefined  |
            |       (calling)          |
            +--------------------------+

Step 7: Returns value 2 (JS line = 14)
    Stack - +--------------------------+
            |          Three           |
            | ans (local) = 2 + pending|
            | calling -> one (Char=27) |
            +--------------------------+

Step 8: Call -> one()(JS line = 14)
    Stack - +--------------------------+
            |           One            |
            |         return 1         |
            +--------------------------+
            |          Three           |
            | ans (local) = 2 + pending|
            |       (calling)          |
            +--------------------------+

Step 9: Returns value 1 (JS line = 14)
    Stack - +--------------------------+
            |          Three           |
            |    ans (local) = 2 + 1   |
            +--------------------------+

Step 10: print value 3 (JS line = 15)
    Stack - +--------------------------+
            |          Three           |
            |    ans (local) = 3       |
            |     print -> 3           |
            +--------------------------+

Step 11: Execute line number 19
    stack - <anonymous>
```

> That's why var also follows functional scope although it doesn't follow block scope. Because, At the end of the calling the stack becomes empty and those variables that was declared also get deleted from stack.

#### üí• What Happens on Stack Overflow?
If recursion or nested calls go too deep, the stack gets overwhelmed:

```javascript
function crash() {
  crash();
}
crash(); // üí• Maximum call stack size exceeded
```

#### üîç Where It's Used

- Tracks what function is currently running

- Helps with **debugging** (stack traces)

- Manages **synchronous** function execution

#### ‚úÖ Key Points

- It‚Äôs **synchronous** ‚Äî runs one function at a time.

- Stack is cleared only after **all function calls finish**.

- JavaScript uses this model because it's **single-threaded**.

---

## Scope in JavaScript
**Scope** in JavaScript determines **where a variable is accessible** ‚Äî like where it's "visible" or "reachable" in your code.

### üì¶ Think of it like containers:

- Imagine each function or block is a box üì¶.

- Variables declared inside a box **stay in that box** unless explicitly passed out.

- You can **see inside your own box** and the outer ones, but **not inside other boxes**.

### 1. Global Scope

```js
let name = "Sankha"; // global

function greet() {
  console.log("Hi " + name); // can access global
}

greet(); // Hi Sankha
```

- `name` is global, available _anywhere_ in your code.

- Be careful! Global variables stay in memory until the page is closed.

### 2. Function Scope

```js
function showAge() {
  let age = 21; // function-scoped
  console.log("Age is", age);
}

showAge();
// console.log(age); ‚ùå Error: age is not defined
```

- `age` exists **only inside** `showAge()`

- Try to access it outside? üí• Boom, it's undefined.

### 3. Block Scope (with `let` & `const` only)

```js
if (true) {
  let hobby = "coding";  // block-scoped
  const mood = "focused";
  console.log(hobby); // coding
}

console.log(hobby); // ‚ùå Error: hobby is not defined
```

- `var` does **not** follow block scope ‚Äî only `let` and `const` do.

#### ‚ö†Ô∏è Important Behavior: `var` vs `let` / `const`

```js
if (true) {
  var x = 5;
  let y = 10;
}

console.log(x); // ‚úÖ 5
console.log(y); // ‚ùå ReferenceError
```

- `var` is **function-scoped**, not block-scoped.

- `let` and `const` are **block-scoped**, safer to use in modern JS.

### 4.Lexical Scope
 Lexical scope means **the accessibility of variables is determined by where you write your code (at _definition time_)**, _not where you call it (at runtime)_.

In plain words:

- JS **reads your code from top to bottom**, and **decides the scope tree** before the program even runs.

- Inner functions have access to variables in the outer scopes **where they are written**, _regardless of where they're called later._

```js
function outer() {
  let name = "Sankha";

  function inner() {
    console.log(name); // ‚úÖ has access
  }

  inner();
}
```

Here, `inner()` can access `name` **because it's lexically inside `outer()`**.

#### ‚ö†Ô∏è But Watch This:

```js
function outer() {
  let secret = "hidden";
  return inner;
}

function inner() {
  console.log(secret); // ‚ùå ReferenceError: secret is not defined
}

outer()(); // üí• BOOM
```

Why? Because `inner` was **not written inside `outer`**, so it doesn‚Äôt have access to `outer`'s scope.  
Even though it's **called from `outer()`**, that doesn't matter.

**Lexical scope is about where it was written, not where it's called.**

### üéØ How Scope Works in Layers

```js
let outer = "I‚Äôm global";

function outerFunc() {
  let inner = "I‚Äôm inside outerFunc";

  function innerFunc() {
    let deep = "I‚Äôm deep inside";
    console.log(outer); // ‚úÖ I‚Äôm global
    console.log(inner); // ‚úÖ I‚Äôm inside outerFunc
    console.log(deep);  // ‚úÖ I‚Äôm deep inside
  }

  innerFunc();
  console.log(deep); // ‚ùå Error: deep is not defined
}

outerFunc();
```

- Inner scopes can **access outer scopes**, but **not the other way around**.

---

Alright Sankha, let's talk **hoisting** ‚Äî a fundamental yet often confusing concept in **JavaScript**. You _must_ understand this thoroughly if you're serious about mastering JS. So buckle in.

---

## Hoisting in JavaScript
**Hoisting** is JavaScript's default behavior of **moving declarations to the top** of the current scope (either global or function scope) **during the compilation phase**.

In simpler terms:

> JavaScript **scans** your code before it actually runs it, and **pulls all variable and function declarations** to the **top** of their scope.

### But Be Careful ‚Äî Not Everything is Hoisted Equally

#### 1. `var` is Hoisted (But Only the Declaration)

```js
console.log(a); // undefined
var a = 5;
console.log(a); // 5
```

What actually happens behind the scenes:

```js
var a;         // hoisted declaration
console.log(a); // undefined
a = 5;          // assignment stays in place
console.log(a); // 5
```

üß® So you don‚Äôt get an error‚Ä¶ but you don‚Äôt get the value either. You get `undefined`.

#### 2. `let` and `const` are Hoisted Too ‚Äî BUT...
They are hoisted to the top of the block **but not initialized**. This leads to a **Temporal Dead Zone (TDZ)**.

```js
console.log(b); // ‚ùå ReferenceError
let b = 10;
```

So unlike `var`, you can't use `let` or `const` **before** their declaration line.

Why? Because they are in a "dead zone" from the start of the scope until their declaration is reached.

#### 3. Function Declarations Are Fully Hoisted

```js
sayHello(); // ‚úÖ Works!

function sayHello() {
  console.log("Hi Sankha!");
}
```

Here, the **entire function** is hoisted, not just the name.

BUT:

##### ‚ö†Ô∏è **Function Expressions Are NOT Hoisted**

```js
sayHi(); // ‚ùå TypeError: sayHi is not a function

var sayHi = function () {
  console.log("Hi again!");
};
```

Only the **`var sayHi`** part is hoisted, which becomes `undefined` initially ‚Äî not the function.

Same applies to `let` or `const` function expressions. They fall into the TDZ and throw `ReferenceError`.

---

## Try & Catch in JavaScript
In JavaScript, `try...catch` is used for **error handling**. It allows you to test a block of code (`try`) for errors, and if an error occurs, handle it in the `catch` block instead of letting the program crash.

### üîß Syntax:

```javascript
try {
  // Code that might throw an error
} catch (error) {
  // Code to handle the error
}
```

### ‚úÖ Optional `finally` Block

```javascript
try {
  // Code that might throw an error
} catch (error) {
  // Handle the error
} finally {
  // Code that will always run, regardless of an error
}
```

### üß† Example:

```javascript
try {
  let result = riskyFunction();
  console.log("Result:", result);
} catch (err) {
  console.error("Something went wrong:", err.message);
} finally {
  console.log("This will always run.");
}
```

### üëÄ Notes:

- Only **runtime errors** (not syntax errors) can be caught.

- The `error` object in `catch(error)` contains info about the error (like `error.name`, `error.message`, `error.stack`).

- `try...catch` works **synchronously**; to catch async errors, use `.catch()` with Promises or `try...catch` inside `async/await` functions.

### üîÑ Example with `async/await`:

```javascript
async function fetchData() {
  try {
    let response = await fetch("https://api.example.com/data");
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Failed to fetch data:", error);
  }
}
```

---

## This keyword in JavaScript
In JavaScript, the `this` keyword refers to the **context in which a function is called**. Its value depends on **how** the function is invoked, and it can be tricky because it changes depending on the situation.

### Common `this` Scenarios

#### 1. Global Context

```javascript
console.log(this); // In browsers, this is the `window` object
```

#### 2. Inside a Function (Non-strict mode)

```javascript
function show() {
  console.log(this);
}
show(); // `this` is the global object (`window` in browsers)
```

#### 3. Inside a Method (Object Context)

```javascript
const user = {
  name: "Alice",
  greet() {
    console.log(this.name);
  }
};
user.greet(); // `this` refers to `user`
```

#### 4. Arrow Functions
Arrow functions **do not have their own `this`**. They inherit it from the enclosing (lexical) scope.

```javascript
const user = {
  name: "Bob",
  greet: () => {
    console.log(this.name);
  }
};
user.greet(); // `this` is not `user`, it's the outer (global) `this`
```

#### 5. Inside Classes

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
  greet() {
    console.log(`Hello, ${this.name}`);
  }
}
const p = new Person("Eve");
p.greet(); // this ‚Üí instance of Person
```

#### 6. Using `bind`, `call`, and `apply`

```javascript
function greet() {
  console.log(this.name);
}
const person = { name: "Dave" };

greet.call(person);  // Dave
greet.apply(person); // Dave
const boundGreet = greet.bind(person);
boundGreet();        // Dave
```

### Summary

|Context|`this` refers to|
|---|---|
|Global scope|`window` (browser) or `global` (Node.js)|
|Object method|The object itself|
|Arrow function|Inherits `this` from surrounding context|
|Class method|The instance of the class|
|`bind` / `call` / `apply`|Explicitly defined object|

---

## Spread & Rest in JavaScript

### Spread

#### What is the Spread Syntax?
**Spread (`...`)** expands:

- Arrays

- Objects

- Iterables (like Sets, Strings, Maps)  
    into individual elements or properties.

#### Spread with Arrays

##### ‚úÖ Copying an Array

```js
const nums = [1, 2, 3];
const copy = [...nums]; // [1, 2, 3]
```

> _Creates a shallow copy (not deep)._

##### ‚úÖ Merging Arrays

```js
const arr1 = [1, 2];
const arr2 = [3, 4];
const merged = [...arr1, ...arr2]; // [1, 2, 3, 4]
```

##### ‚úÖ Spreading into Function Arguments

```js
function add(a, b, c) {
  return a + b + c;
}

const values = [1, 2, 3];
console.log(add(...values)); // 6
```

##### ‚úÖ Spreading Strings (turns into array of characters)

```js
const word = "hello";
const letters = [...word]; // ['h', 'e', 'l', 'l', 'o']
```

#### Spread with Objects

##### ‚úÖ Cloning an Object

```js
const user = { name: "Alice", age: 25 };
const clone = { ...user }; // { name: "Alice", age: 25 }
```

##### ‚úÖ Merging Objects

```js
const defaults = { theme: "dark", font: "Arial" };
const settings = { font: "Roboto", layout: "grid" };

const final = { ...defaults, ...settings };
// { theme: "dark", font: "Roboto", layout: "grid" }
```

> _Right-most object overwrites previous values._

#### Limitations & Caveats

- Spread only performs a **shallow copy**.
	
```js
const original = { a: 1, b: { c: 2 } };
onst copy = { ...original };
copy.b.c = 99; // changes original.b.c too
```

- Can‚Äôt spread **non-iterables** (e.g., numbers or objects in arrays directly).

- Can't spread into **constructor arguments** unless using `apply()` or modern class spreading patterns.

#### Summary

| Feature       | Spread Use Case Example         |
| ------------- | ------------------------------- |
| Copy array    | `const copy = [...array]`       |
| Merge arrays  | `const combined = [...a, ...b]` |
| Spread string | `const chars = [..."text"]`     |
| Clone object  | `const newObj = { ...obj }`     |
| Merge objects | `const result = { ...a, ...b }` |
| Function args | `func(...argsArray)`            |

### Rest in JavaScript

#### What is Rest?
**Rest syntax** uses `...` to **gather** remaining elements/args/properties into a new array or object.

Think:
 
 - **Spread** = ‚Äúexplode‚Äù

 - **Rest** = ‚Äúgather‚Äù

#### Rest in Function Parameters

##### ‚úÖ Capture Unlimited Arguments

```js
function logAll(...args) {
  console.log(args);
}

logAll(1, 2, 3); // [1, 2, 3]
```

> `args` becomes a real array (not `arguments` object).

##### ‚úÖ With Named Params

```js
function greet(first, ...others) {
  console.log(first);  // 'Hello'
  console.log(others); // ['World', '!']
}

greet('Hello', 'World', '!'); 
```


#### Important Rules

- **Only one** rest element is allowed.

- Must be the **last** in parameter/destructuring list.
	
```js
function wrong(...args, x) {} // ‚ùå SyntaxError
```

#### Use Cases

| Use Case                         | Rest Syntax Example                   |
| -------------------------------- | ------------------------------------- |
| Unlimited function arguments     | `function sum(...nums)`               |
| Array destructuring (skip first) | `const [_, ...rest] = arr`            |
| Object property separation       | `const {id, ...others} = obj`         |
| Custom wrapper over functions    | `(...args) => func.apply(null, args)` |

#### Don‚Äôt Confuse Rest vs Spread

|Feature|Role|Example|
|---|---|---|
|Rest|Gather items|`function f(...args) {}`|
|Spread|Expand items|`f(...[1, 2, 3])`|

#### Summary

- **Rest = collect multiple elements into one**.

- Use it in:
    
    - Function parameters
    
    - Array/object destructuring
    
- It‚Äôs a tool for **flexibility**, **clean syntax**, and **modularity**.

---

## Destructuring in JavaScript

### What Is Destructuring?
**Destructuring** means extracting values from arrays or properties from objects and assigning them to variables using a concise syntax.

> TL;DR: Break down data structures into variables ‚Äî clean and fast.

### Array Destructuring

#### ‚úÖ Basic Usage

```js
const arr = [10, 20, 30];
const [a, b, c] = arr;

console.log(a); // 10
console.log(b); // 20
```

#### ‚úÖ Skip Items

```js
const [x, , z] = [1, 2, 3];
console.log(z); // 3
```

#### ‚úÖ Use with Rest

```js
const [first, ...rest] = [1, 2, 3, 4];
console.log(first); // 1
console.log(rest);  // [2, 3, 4]
```

#### ‚úÖ Set Defaults

```js
const [a = 1, b = 2] = [];
console.log(a, b); // 1 2
```

### Object Destructuring

#### ‚úÖ Basic Usage

```js
const user = { name: "Sankho", age: 21 };
const { name, age } = user;
console.log(name); // 'Sankho'
```

#### ‚úÖ Rename Variables

```js
const { name: userName, age: userAge } = user;
console.log(userName); // 'Sankho'
```

#### ‚úÖ Set Defaults

```js
const { role = "user" } = user;
console.log(role); // 'user'
```

#### ‚úÖ Nested Destructuring

```js
const user = {
  name: "Sankho",
  address: {
    city: "Delhi",
    zip: 12345,
  },
};

const {
  address: { city },
} = user;
console.log(city); // 'Delhi'
```

### Destructuring in Function Parameters

#### ‚úÖ Object Params

```js
function greet({ name, age }) {
  console.log(`Hello ${name}, you are ${age}`);
}

greet({ name: "Sankho", age: 21 });
```

#### ‚úÖ Array Params

```js
function sum([a, b]) {
  return a + b;
}
console.log(sum([5, 7])); // 12
```

### Gotchas

- **Order matters in arrays**, not in objects.

- For **nested values**, destructure safely ‚Äî use optional chaining or defaults to avoid `undefined`.

- **Deep nested destructuring** can kill readability. Know when to stop.

### When to Use

| Situation                        | Use Destructuring? |
| -------------------------------- | ------------------ |
| Pulling multiple values from obj | ‚úÖ Yes              |
| Handling function params         | ‚úÖ Yes              |
| Deep destructuring               | ‚ö†Ô∏è With caution    |
| One or two properties only       | ü§∑‚Äç‚ôÇÔ∏è Up to you    |

---

## [[DOM]] Manipulation in JavaScript
**[[DOM]] (Document Object Model) manipulation** in JavaScript means using JavaScript to interact with and change elements on a web page‚Äîlike updating text, changing styles, adding/removing elements, or responding to user actions.

### Document Object
The `document` object in JavaScript is a part of the **DOM (Document Object Model)** and represents the **entire HTML page** loaded in the browser. It allows you to **access, manipulate, and change** the structure, style, and content of the webpage dynamically.

#### üîç Basic Definition

```javascript
console.log(document);
```

- `document` is an object automatically created by the browser when a webpage loads.

- It gives you the entry point to interact with HTML.

#### üìå Common Uses

|Task|Example|
|---|---|
|**Select Elements**|`document.getElementById('myDiv')`|
|**Change Content**|`document.getElementById('myDiv').innerText = 'Hello!'`|
|**Change Style**|`document.body.style.backgroundColor = 'black'`|
|**Create Elements**|`let div = document.createElement('div')`|
|**Add Event Listeners**|`document.addEventListener('click', myFunction)`|

#### üìÅ Structure
You can think of `document` as the **root node** of your HTML content. Example:

```html
<!DOCTYPE html>
<html>
	<head>
    	<title>Example</title>
	</head>
	<body>
    	<p>Hello, World!</p>
	</body>
</html>
```

You can access these parts like this:

```javascript
document.documentElement;  // <html>
document.head;             // <head>
document.body;             // <body>
```

#### üöÄ Useful Properties & Methods

|Property/Method|Purpose|
|---|---|
|`document.title`|Get/set the page title|
|`document.URL`|Get the full URL|
|`document.querySelector()`|Select the **first** element matching a CSS selector|
|`document.querySelectorAll()`|Select **all** elements matching a CSS selector|
|`document.createElement()`|Create new HTML elements|
|`document.getElementsByClassName()`|Get all elements with a specific class|
|`document.forms`, `document.images`|Access all forms or images on the page|

#### ‚ö†Ô∏è Things to Watch

- `document` only exists in the **browser environment**, not in Node.js.

- DOM manipulations can cause **performance issues** if done excessively.

- Use `DOMContentLoaded` event to ensure HTML is fully parsed:

```javascript
document.addEventListener('DOMContentLoaded', () => {
  // Safe to manipulate DOM here
});
```

#### ‚úÖ Summary

- `document` is your gateway to controlling the web page.

- It's the foundation of client-side scripting in JavaScript.

- Mastering the `document` object is essential for **dynamic UIs** and **user interaction**.

### Element Selector Methods

#### 1. `document.getElementById(id)`

- üîç Selects a single element **by its `id`**.

- ‚ö†Ô∏è Returns `null` if not found.

```js
const el = document.getElementById('header');
```

#### 2. `document.getElementsByClassName(className)`

- üîç Returns an **HTMLCollection** of elements with a specific class.

- ‚ö†Ô∏è It's **live**, so changes in DOM are reflected automatically.

- Use indexing to access individual elements.

- Wrong element class return a HTML collection of length 0.

```js
const items = document.getElementsByClassName('menu-item');
console.log(items[0]); // First .menu-item
```

#### 3. `document.getElementsByTagName(tagName)`

- üîç Selects all elements with the given tag name.

- ‚ö†Ô∏è Also returns a **live HTMLCollection**.

```js
const allDivs = document.getElementsByTagName('div');
```

#### 4. `document.querySelector(selector)`

- üîç Returns the **first** element that matches a CSS selector.

- ‚úÖ Supports **all CSS selectors**.

```js
const firstButton = document.querySelector('button.submit');
const input = document.querySelector('#search');
```

#### 5. `document.querySelectorAll(selector)`

- üîç Returns **all** matching elements as a **static NodeList**.

- ‚úÖ Iterate-able with `forEach`, unlike HTMLCollection.

```js
const allButtons = document.querySelectorAll('.btn');
allButtons.forEach(btn => btn.style.color = 'red');
```

#### ‚ö†Ô∏è Live vs Static Node Lists

|Method|Type|Live/Static|
|---|---|---|
|`getElementsByClassName`|HTMLCollection|**Live**|
|`getElementsByTagName`|HTMLCollection|**Live**|
|`querySelectorAll`|NodeList|**Static**|

#### ‚úÖ Best Practice Tips

- Use `querySelector` and `querySelectorAll` for **modern, flexible, and CSS-style selectors**.

- Prefer `querySelector` over `getElementById` for consistency and scalability.

- If performance is critical and you know the ID, `getElementById` is fastest.

---

### Setting content in element object
Setting content inside an element in JavaScript is a **core DOM manipulation task**. You usually use **`element.innerHTML`**, **`element.textContent`**, or **`element.innerText`**, depending on what exactly you want to do.

#### 1. `element.innerHTML`

- ‚úÖ Sets or gets the **HTML content** / **Markup Text** inside an element.

- ‚ö†Ô∏è Accepts **HTML tags**, not just text.

```js
document.getElementById('box').innerHTML = '<strong>Hello</strong>';
```

- Pros:
	
	- Allows embedding HTML.

- Cons:
	
	- **Risky** if you insert user data (can lead to XSS attacks).

#### 2. `element.textContent`

- ‚úÖ Sets or gets the **text content** (no HTML).

- Escapes HTML, so it‚Äôs **safe**.

```js
document.getElementById('box').textContent = '<strong>Hello</strong>';
// Output: <strong>Hello</strong>
```

- Pros:
	
	- Safe from XSS.
    
	- Includes all text (even hidden by CSS).

- Cons:
	
	- Doesn‚Äôt render HTML tags.

#### 3. `element.innerText`

- Similar to `textContent`, but:
    
    - **Ignores hidden text** (e.g., `display: none`)
    
    - Triggers **reflow/layout** (slower)
    
    - Matches **visual text** seen on screen

```js
document.getElementById('box').innerText = 'Welcome!';
```

#### ‚ö†Ô∏è Which One Should You Use?

|Use Case|Recommended|
|---|---|
|Injecting HTML|`innerHTML`|
|Injecting plain text safely|`textContent`|
|Matching what‚Äôs visible|`innerText`|
#### üß† Appending Content

If you want to **add** to existing content:

```js
element.innerHTML += "<p>More stuff</p>";
```

But the **better practice** is to use DOM methods:

```js
const p = document.createElement('p');
p.textContent = "More stuff";
document.getElementById('box').appendChild(p);
```

### Manipulating Attributes
In JavaScript, you can **manipulate HTML element attributes** using two main techniques:

#### 1. Attribute Getter & Setter Methods

##### 1. **`element.getAttribute(attrName)`**

- ‚úÖ Retrieves the value of an attribute as a **string**.

```js
const link = document.querySelector('a');
console.log(link.getAttribute('href'));  // e.g., "https://example.com"
```

##### 2. **`element.setAttribute(attrName, value)`**

- ‚úÖ Sets or updates the value of an attribute.

```js
link.setAttribute('href', 'https://google.com');
link.setAttribute('target', '_blank');
```

##### 3. **`element.removeAttribute(attrName)`**

- ‚úÖ Removes an attribute entirely.

```js
link.removeAttribute('target');
```

##### 4. **`element.hasAttribute(attrName)`**

- ‚úÖ Checks if the element has a specific attribute.

```js
if (link.hasAttribute('href')) {
  console.log('This link has an href!');
}
```

#### 2. Direct Property Access (Alternative for Common Attributes)
You can also get/set certain **standard attributes directly** using properties:

```js
const input = document.querySelector('input');

// Get value
console.log(input.value);

// Set value
input.value = 'New value';
```

##### üîÑ **Common Attribute‚ÄìProperty Mappings**

| Attribute  | Property            |
| ---------- | ------------------- |
| `id`       | `element.id`        |
| `class`    | `element.className` |
| `href`     | `element.href`      |
| `value`    | `element.value`     |
| `checked`  | `element.checked`   |
| `disabled` | `element.disabled`  |
| `src`      | `element.src`       |

#### Method vs Property Differences

- `getAttribute()` returns **the original attribute value**.

- Direct property access reflects the **current state**.

Example:

```html
<input type="text" value="hello" />
```

```js
const input = document.querySelector('input');

input.value = "updated";

console.log(input.getAttribute("value")); // "hello"
console.log(input.value);                 // "updated"
```

#### Manipulating Style Attribute
Manipulating the `style` attribute in JavaScript lets you **dynamically change the appearance** of HTML elements. You can do this either through the `.style` property or using `setAttribute()`.

##### üîß **Method 1: Using `element.style.propertyName`**

- Best Practice (Preferred for inline styles)
	
```js
const box = document.getElementById('box');

box.style.backgroundColor = 'blue';
box.style.color = 'white';
box.style.fontSize = '18px';
```

> ‚úÖ Use **camelCase** for multi-word CSS properties:  
> `background-color` ‚Üí `backgroundColor`

##### üîß **Method 2: Using `element.setAttribute('style', ...)`**

- ‚ö†Ô∏è Overwrites entire inline style
	
```js
box.setAttribute('style', 'background-color: red; font-size: 20px;');
```

> ‚ö†Ô∏è Be cautious: This **replaces** all inline styles on the element.

---

##### üîç **Method 3: Accessing Existing Styles**
You can **read inline styles** directly:

```js
console.log(box.style.backgroundColor);  // "blue"
```

To **read computed styles** (including CSS from stylesheets):

```js
const computed = getComputedStyle(box);
console.log(computed.backgroundColor);
```

##### üß† **Remove a Style**

```js
box.style.border = ''; // Removes the inline border style
```

### ClassList property
The `classList` property in JavaScript gives you a **powerful, clean, and flexible way** to manipulate classes on an HTML element. It returns a **DOMTokenList**, which acts like a special array of class names with built-in methods.

#### üìå Syntax

```js
element.classList
```

#### ‚úÖ Common Methods

|Method|Description|Example|
|---|---|---|
|`.add(className)`|Adds a class|`el.classList.add('active')`|
|`.remove(className)`|Removes a class|`el.classList.remove('hidden')`|
|`.toggle(className)`|Adds if missing, removes if present|`el.classList.toggle('dark')`|
|`.contains(className)`|Checks if class exists|`el.classList.contains('error')`|
|`.replace(oldClass, newClass)`|Replaces one class with another|`el.classList.replace('open', 'closed')`|

#### üß† Example

```html
<div id="box" class="container dark"></div>
```

```js
const box = document.getElementById('box');

// Add a class
box.classList.add('active');

// Remove a class
box.classList.remove('dark');

// Toggle a class
box.classList.toggle('visible');

// Check if class exists
if (box.classList.contains('container')) {
  console.log('Box has the container class');
}

// Replace a class
box.classList.replace('container', 'wrapper');
```

---

#### üîç Why Use `classList` (vs `className`)?

- `element.className`
	
	- Gets/sets the **entire** class string (can overwrite all classes accidentally).
		
```js
box.className = "newClass"; // üíÄ overwrites all previous classes
```

- `element.classList`
	
	- Lets you **safely add/remove/toggle** individual classes.

‚úÖ Use `classList` unless you're doing low-level string manipulation.

#### ‚ö†Ô∏è Notes

- `classList` is not supported in IE9 and below (ancient browsers).

- Multiple classes can be added/removed at once:
    
```js
box.classList.add('a', 'b', 'c');
box.classList.remove('a', 'b');
```

### Navigating Through the page using hierarchy
Navigating the DOM using **hierarchy** means moving between elements based on their **parent-child-sibling relationships**‚Äîinstead of selecting directly by ID/class.

This is powerful when you're dealing with **dynamic content**, reusable components, or when direct selectors aren't viable.

#### üîÅ DOM Navigation Overview

| Property                       | Description                       | Returns  |
| ------------------------------ | --------------------------------- | -------- |
| `parentNode` / `parentElement` | Go to parent                      | Element  |
| `children`                     | Get all children (HTMLCollection) | Elements |
| `firstElementChild`            | First child (element)             | Element  |
| `lastElementChild`             | Last child (element)              | Element  |
| `nextElementSibling`           | Next sibling element              | Element  |
| `previousElementSibling`       | Previous sibling element          | Element  |

### Adding & Removing element from DOM
Adding and removing elements in the DOM (Document Object Model) is a **must-know skill** for dynamic front-end development. Below is a **straight-to-the-point guide** with methods and examples.

#### Adding Elements to the DOM

##### üîß 1. **`document.createElement()`**
Creates a new element **in memory**.

```js
const newDiv = document.createElement('div');
newDiv.textContent = "I'm new here!";
```

##### üîß 2. **`element.appendChild()`**
Adds a child **at the end** of the parent.

```js
document.body.appendChild(newDiv);  // Adds to end of <body>
```

##### üîß 3. **`element.prepend()`**
Adds as the **first child**.

```js
document.body.prepend(newDiv);
```

##### üîß 4. **`element.append()`** _(Modern)_
Can append **multiple nodes or strings**.

```js
parent.append("Hello ", newDiv);
```

##### üîß 5. **`element.insertBefore(newNode, referenceNode)`**
Inserts a node **before** another existing node.

```js
parent.insertBefore(newDiv, parent.firstElementChild);
```

##### üîß 6. **`element.insertAdjacentHTML(position, htmlString)`**
Injects raw HTML **relative** to an existing element.

```js
element.insertAdjacentHTML('beforeend', '<p>New content</p>');
```

|Position|Description|
|---|---|
|`'beforebegin'`|Before the element|
|`'afterbegin'`|Inside, before first child|
|`'beforeend'`|Inside, after last child|
|`'afterend'`|After the element|

#### Removing Elements from the DOM

##### üîß 1. **`element.remove()`** _(Modern & Simple)_

```js
const item = document.getElementById('remove-me');
item.remove();
```

##### üîß 2. **`parent.removeChild(child)`**
Compatible with **older browsers** like IE11.

```js
const parent = document.getElementById('container');
const child = document.getElementById('remove-me');
parent.removeChild(child);
```

#### Pro Tips

- `createElement` only creates‚Äîit **won‚Äôt appear** in the DOM until you append it.

- For **multiple elements**, use `DocumentFragment` for better performance.

- Always **check for existence** before removing or inserting around nodes.

---

## Event Handling in JavaScript
Event handling is how JavaScript responds to user interactions or browser actions ‚Äî like **clicks**, **keyboard input**, **form submission**, etc.

### What is an Event
An **event** is a signal or notification that something has happened ‚Äî either because the **user interacted** with the web page or something **occurred in the browser**.

#### ‚öôÔ∏è Think of it like:

> "Hey JavaScript, the user just clicked a button!"  
> Or ‚Äî "The page just finished loading!"  
> Or ‚Äî "A key was pressed!"

#### üîπ Common Sources of Events:

|Trigger|Event Name|
|---|---|
|Clicking a button|`click`|
|Moving the mouse over an element|`mouseover`|
|Typing on the keyboard|`keydown`|
|Submitting a form|`submit`|
|Resizing the window|`resize`|
|Finishing loading a page or image|`load`|
|Scrolling the page|`scroll`|

#### üì¶ What Happens When an Event Occurs?
When an event occurs:

1. The **browser detects it**.

2. If you've set up an **event listener** for that event...

3. JavaScript runs the **callback function** you provided.

### Inline Event Handling

**Inline event handling** means directly adding JavaScript code to an HTML element‚Äôs attribute ‚Äî typically the `on<event>` attributes like `onclick`, `onmouseover`, etc.

Basic Syntax:

```html
<tagname onevent="JavaScript code"></tagname>
```

Example:

```html
<button onclick="alert('Button clicked!')">Click Me</button>
```

When you click the button, the `onclick` attribute triggers the `alert()` function.

#### üî• Common Inline Event Attributes:

|HTML Attribute|JavaScript Equivalent|
|---|---|
|`onclick`|Click event|
|`onmouseover`|Mouse over|
|`onmouseout`|Mouse leaves|
|`onchange`|Input value changes|
|`onkeydown`|Key pressed down|
|`onload`|Element/page finished loading|

#### ‚ö†Ô∏è Why Inline Event Handling Is Not Recommended
While it **works**, it's not good practice in real-world development. Here's why:

| Problem                                      | Explanation                                              |
| -------------------------------------------- | -------------------------------------------------------- |
| ‚ùå **Mixes HTML and JS**                      | Breaks separation of concerns (harder to maintain/debug) |
| ‚ùå **Hard to scale**                          | Repetitive and cluttered for large projects              |
| ‚ùå **No access to modern JS features easily** | Arrow functions, event delegation, etc. get awkward      |
| ‚ùå **Limits reusability**                     | Can't reuse logic cleanly across elements                |
| ‚ùå **One function for one element**           | We can only set one function for each html attribute.    |

#### When is Inline Handling Acceptable?

üîπ Tiny personal projects  
üîπ Quick prototypes  
üîπ Learning basics

But once you go pro or want **clean, scale-able code**, **avoid inline handling**. Use `addEventListener()` and modular JavaScript.

### `addEventListener()` Method
The `addEventListener()` method is the **standard, modern, and flexible** way to handle events in JavaScript.

- Syntax:
	
```javascript
element.addEventListener(eventType, callbackFunction, useCapture);
```
	
|Parameter|Description|
|---|---|
|`eventType`|The name of the event (e.g., `"click"`, `"keydown"`)|
|`callbackFunction`|Function to run when the event occurs|
|`useCapture` _(optional)_|Boolean for event phase (usually `false`)|

- Example:
	
```html
<button id="myBtn">Click Me</button>

<script>
  document.getElementById("myBtn").addEventListener("click", function () {
    alert("Button clicked!");
  });
</script>
```

- Using Named Functions:
	
```javascript
function handleClick() {
  console.log("Button clicked!");
}

const btn = document.getElementById("myBtn");
btn.addEventListener("click", handleClick);
```
	
> This approach makes it easier to **remove** the event later.

#### Event Object Access

```javascript
btn.addEventListener("click", function (event) {
  console.log(event.type);      // "click"
  console.log(event.target);    // The clicked element
});
```

#### Multiple Event Listeners on Same Element

```javascript
btn.addEventListener("click", function () {
  console.log("First listener");
});

btn.addEventListener("click", function () {
  console.log("Second listener");
});
```

‚úÖ Both will run ‚Äî unlike using HTML attributes, which **overwrites** the previous one.

#### Removing an Event Listener

Only works with **named functions** (not anonymous ones):

```javascript
btn.removeEventListener("click", handleClick);
```

#### Third Parameter: `useCapture` (Advanced)

- `false` = Bubbling phase (default, most common)

- `true` = Capturing phase (rarely used)

```javascript
element.addEventListener("click", callback, true); // Capture mode
```

#### Why Use `addEventListener()`?

|Feature|Advantage|
|---|---|
|‚úÖ Separation of HTML and JS|Cleaner, modular code|
|‚úÖ Multiple listeners|Attach several handlers to same element|
|‚úÖ Event control|Fine-grained control over propagation|
|‚úÖ Works with dynamic elements|Ideal for event delegation|

#### Event Types
JavaScript has **many event types**, organized by what they respond to ‚Äî like mouse actions, keyboard input, browser activity, etc. Here's a clear breakdown:

##### üñ±Ô∏è 1. **Mouse Events**

|Event|Trigger|
|---|---|
|`click`|Single mouse click|
|`dblclick`|Double click|
|`mousedown`|Mouse button pressed|
|`mouseup`|Mouse button released|
|`mousemove`|Mouse moved|
|`mouseover`|Mouse enters element|
|`mouseout`|Mouse leaves element|
|`contextmenu`|Right-click|

```javascript
para1.addEventListener("click", function () {
	console.log("Paragraph is clicked!");
});

box1.addEventListener("mouseenter", function () {
	console.log("Cursor is inside the box!");
});

box1.addEventListener("mouseleave", function () {
	console.log("Cursor leaved :(");
});
```

##### ‚å®Ô∏è 2. **Keyboard Events**

|Event|Trigger|
|---|---|
|`keydown`|Key is pressed|
|`keypress`|Key is pressed and character is printed (deprecated)|
|`keyup`|Key is released|

```javascript
input1.addEventListener("keydown", function (event) {
	console.log("Key:", event.key); // These two properties are most important
	console.log("Code:", event.code);
});
```

##### üßæ 3. **Form Events**

|Event|Trigger|
|---|---|
|`submit`|Form is submitted|
|`change`|Value of an input/select/textarea changes|
|`input`|Value of an `<input>` or `<textarea>` changes (real-time)|
|`focus`|Element gains focus|
|`blur`|Element loses focus|
|`reset`|Form is reset|

```javascript
form.addEventListener("submit", function (event) {
    event.preventDefault(); // This method prevent the default behavior of 			an element; in this case it prevents the form submission.
    console.log(event);
    alert("From is submitted.");	
    
    // Accessing form data
    console.dir(form); // Form object has a elements property that stores 			every element inside form.
    
    console.dir(form.elements); // The elements inside form can be accessed 		in two ways. 1. querySelector 2.form.elements[index(key)value]; second 			process is more scalable.
    
    let user = this.elements[0].value; // this -> form
    let pass = this.elements.pass1.value; // We can access elements in two 			ways! 1. key number 2. id
    
    // We can use name attribute to select here, & it's the best
    // user input doesn't store in innerText... it stores in value.
	
    alert(`Hi! ${user}, your password is ${pass}`); // using the form value
});

// Change Listening
// Change
// It activates when we focus in the input box, then change its value & unfocus the input area.
//It triggers and take the total change value.
textarea.addEventListener("change", function (event) {
    console.log("Change: ", this.value);
});

// Input
// It tracks every small character change in input box.
// Non character key can't triggers it.
textarea.addEventListener("input", function () {
    console.log("Input: ", this.value);
    para.innerText = this.value;
});
```

##### üì¶ 4. **Window/Document Events**

|Event|Trigger|
|---|---|
|`load`|Page or resource fully loaded|
|`DOMContentLoaded`|DOM is ready (no styles/images)|
|`resize`|Browser window resized|
|`scroll`|User scrolls page|
|`unload`|User leaves page (deprecated)|
|`beforeunload`|User about to leave page|

```javascript
window.addEventListener("resize", () => console.log("Window resized"));
```

##### üì± 5. **Touch Events** (Mobile Devices)

|Event|Trigger|
|---|---|
|`touchstart`|Finger touches screen|
|`touchmove`|Finger moves on screen|
|`touchend`|Finger leaves screen|

##### üß† 6. **Clipboard Events**

|Event|Trigger|
|---|---|
|`copy`|User copies content|
|`cut`|User cuts content|
|`paste`|User pastes content|

##### üß® 7. **Drag & Drop Events**

|Event|Trigger|
|---|---|
|`dragstart`|Drag starts|
|`drag`|Element being dragged|
|`dragend`|Drag ends|
|`dragenter`|Element enters drop area|
|`dragover`|Element is over drop area|
|`dragleave`|Element leaves drop area|
|`drop`|Element dropped|

##### üìä 8. **Media Events**

|Event|Trigger|
|---|---|
|`play`|Media starts playing|
|`pause`|Media is paused|
|`ended`|Media playback ends|
|`volumechange`|Volume changes|
|`timeupdate`|Current playback position updates|
|`loadeddata`|Media data is loaded|

##### üîÅ 9. **Miscellaneous Events**

|Event|Trigger|
|---|---|
|`error`|An error occurs|
|`animationstart`|CSS animation starts|
|`animationend`|CSS animation ends|
|`transitionend`|CSS transition ends|

---

## Event bubbling in JavaScript
**Definition**: Event bubbling is a phase in the event propagation mechanism in the DOM where an event starts from the **target element** (where the event occurred) and **bubbles up** to its parent elements **all the way to the root** (`<html>`).

### Visual Example:

HTML :

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Day 44</title>
        <link rel="stylesheet" href="style.css" />
    </head>
    <body>
        <!-- Event Bubbling -->
        <div id="outerDiv">
            <ul id="numbers">
                <li class="num">One</li>
                <li class="num">Two</li>
                <li class="num">Three</li>
            </ul>
        </div>
        <script src="app.js"></script>
    </body>
</html>
```

CSS :

```css
#outerDiv {
    height: 500px;
    width: 900px;
    background-color: pink;
}
#numbers {
    background-color: lime;
}
.num {
    background-color: blue;
    color: white;
}
#box {
    height: max-content;
    width: 500px;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 30px auto;
    background-color: mediumaquamarine;
}
.btn {
    background-color: pink;
    margin: 20px;
}
.lime {
    background-color: lime;
    margin: 20px;
}
```

JavaScript :

```js
let div = document.getElementById("outerDiv");
let ul = document.getElementById("numbers");
let lis = document.querySelectorAll(".num");

div.addEventListener("click", function () {
	console.log("Div is clicked!");
});
ul.addEventListener("click", function () {
    console.log("Ul is clicked!");
});
for (let li of lis) {
    li.addEventListener("click", function () {
        console.log("Li is clicked!");
    });
}

// So, when we click the div (pink) part, We got the msg of "Div is clicked!"

// When we click the ul (lime) part, We got the msg of "Ul is clicked!", "Div is clicked!".

// When we click the li (blue) part, We got the msg of "Li is clicked!", "Ul is clicked!", "Div is clicked!".

// To stop this we can use an event method called stopPropagating.

for (let li of lis) {
    li.addEventListener("click", function (event) {
        event.stopPropagation();
        console.log("Li is clicked!");
    });
}

// Now there is no ul & div msg inside li.... It logs "Li is clicked!" twice because the second handler overrides the first. But thanks to stopPropagation, it doesn't bubble to ul or div.
```

### Key Concepts

| Concept                            | Explanation                                                                                                          |
| ---------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| **Target phase**                   | The exact element the user interacted with.                                                                          |
| **Bubbling phase**                 | The event propagates **upward** from the target to its ancestors.                                                    |
| **Capturing phase**                | (Opposite of bubbling) ‚Äì Event goes from the top (`<html>`) **down to the target** before bubbling begins. Optional. |
| `event.stopPropagation()`          | Stops the event from bubbling further up the DOM tree.                                                               |
| `event.stopImmediatePropagation()` | Also prevents other handlers of the same event on the same element from firing.                                      |

### How to Use or Stop Bubbling:

- Allow bubbling (default behavior):
	
```javascript
element.addEventListener('click', handler);
```

- Stop bubbling:
	
```javascript
element.addEventListener('click', (event) => {
  event.stopPropagation();
});
```

### Real Use Case: Event Delegation
Event bubbling powers **event delegation** ‚Äì a powerful technique where a **parent handles events for many children**. Saves memory and performance.

#### ‚úÖ Example :

HTML :

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Day 44</title>
        <link rel="stylesheet" href="style.css" />
    </head>
    <body>
        <!-- Event Delegation -->
        <div id="box">
            <button class="btn">Click Me!</button>
            <button class="btn">Click Me!</button>
            <button class="btn">Click Me!</button>
        </div>
        <script src="app.js"></script>
    </body>
</html>
```

CSS :

```css
#box {
    height: max-content;
    width: 500px;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 30px auto;
    background-color: mediumaquamarine;
}
.btn {
    background-color: pink;
    margin: 20px;
}
.lime {
    background-color: lime;
    margin: 20px;
}
```

JavaScript :

```js
let box = document.getElementById("box");
let btns = document.querySelectorAll(".btn");

for (let btn of btns) {
    btn.addEventListener("click", function (event) {
        alert("Btn Clicked!");
    });
}

for (let i = 0; i < 4; i++) {
    let newBtn = document.createElement("button");
    newBtn.innerText = "Click Me";
    newBtn.classList.add("lime");
    newBtn.classList.add("btn");
    box.appendChild(newBtn);
}
// Here we can see that pink buttons is listening the events and responding accordingly. But, when we added 4 more buttons then added the necessary btn class... those buttons aren't listening.

// To tackle this we use the Event Delegation method which works on Event bubbling concept

box.addEventListener("click", function (event) {
    console.dir(event.target);
    // event.target tracks the exact child element is pressed..
    // this will work for new buttons also!
    alert("Delegation Happened");
});

// Finally the pink buttons both alerts and the lime ones triggers only the Delegation alert.
```

### Summary

- **Event bubbling = upward flow** from the target to ancestors.

- Useful for **delegating** events or applying behavior globally.
 
- Use `stopPropagation()` to **control flow** if needed.

- Always think about **propagation side-effects** when nesting event listeners.

---

## "JavaScript is Single-Threaded"
When we say **JavaScript is single-threaded**, we mean:

> **It can execute only one command (function/task) at a time in a single call stack.**

### In Simple Terms:

- One brain.

- One train of thought.

- One thing at a time.

If JavaScript is busy doing something (like a loop or function), **everything else has to wait** until it‚Äôs done.

### Technical Breakdown

#### ‚úÖ Single Thread = One Call Stack
JavaScript has:

- **One call stack** (tracks what‚Äôs being executed)

- **One main thread** (runs the JS code)

So, it can‚Äôt do two JS tasks at the same time ‚Äî no parallel execution of JS code.

### Real-World Example:

```javascript
function delay() {
  for (let i = 0; i < 1e9; i++) {} // Heavy computation
}

console.log("Start");
delay(); // blocks everything
console.log("End");
```

Output:

```
Start
(wait... üê¢)
End
```

Because `delay()` blocks the thread, `"End"` has to **wait** until it‚Äôs done. No multitasking here.

### But JavaScript Feels Async?
Yes ‚Äî that‚Äôs thanks to the **Event Loop**, **Web APIs**, and **Callback Queue**.

JavaScript itself is single-threaded, **but the browser is not**. The browser (or Node.js) provides:

- **Web APIs** (e.g., `setTimeout`, `fetch`, DOM events)

- These run on **separate threads**

- When they‚Äôre done, they send results **back to the main thread**

JavaScript then picks up these tasks **one at a time**, when the stack is clear.

#### ‚úÖ Example

```js
setTimeout(() => {
	console.log("Sankho");
}, 2000);

setTimeout(() => {
	console.log("ChatGPT");
}, 2000);

console.log("Hello...");

// Output
// Hello...
// (after 2 sec.)
// Sankho
// ChatGPT
```

```plaintext
So, what happened?

JS is single threaded.. So, it should wait 2sec + 2sec = 4 sec then, it should print hello.... But, The out put is quiet different!!!

Trick: JS treat them some special function definition and gives to browser the responsibility to hold them for instructed time... Because, browsers are written in C++ or Java so, they can handle multiple threads at the same time.... And after the time is over, Browser add the callback function to javaScript Call stack!.... And them JS runs it.

Drawback: Because, JS is not directly handling these function and a transaction og data is happening thats why setTimeout and setInterval aren't accurate at all

UseCases: To handle API or, DB delay these functions are really helpful.

** Conventional JS that runs line by line is called Synchronous JS or, JS's Synchronous nature.

** This kind of JS that runs after delay but, not stopping for that is called asynchronous JS or, JS's asynchronous nature.
```

### Visual Model:

```plaintext
[ Call Stack ] ‚Üê only one
[ Web APIs  ] ‚Üê separate threads (browser)
[ Task Queue ] ‚Üê waits to push to Call Stack
```

### Summary

|Aspect|Description|
|---|---|
|**Single-threaded**|JS runs one piece of code at a time|
|**No true parallelism**|Can‚Äôt run two JS functions simultaneously|
|**Async via Event Loop**|Browser APIs do heavy work in background|
|**Non-blocking**|Achieved through callbacks/promises|

---

## Callback Hell in JavaScript
**Callback Hell** (a.k.a. "Pyramid of Doom") happens when you nest multiple asynchronous functions (using callbacks) inside each other in a way that the code becomes **deeply indented**, **hard to read**, and **even harder to maintain**.

### Example of Callback Hell

```javascript
function changeColor(color, delay, nextChange) {
    setTimeout(() => {
        h1.style.color = color;
        if (nextChange) nextChange();
    }, delay);
}

changeColor("red", 1000, () => {
    changeColor("orange", 1000, () => {
        changeColor("green", 1000, () => {
            changeColor("pink", 1000, () => {
                changeColor("blue", 1000);
            });
        });
    });
});
```

This is **deeply nested**, **not readable**, and if any function fails, error handling becomes a nightmare.

### Why It‚Äôs a Problem

- Difficult to read

- Hard to maintain or debug

- Error handling becomes convoluted

- Code grows horizontally and vertically

### Solutions to Callback Hell

#### 1. Modularization
Break callbacks into **named functions**:

```javascript
function handleUser(user) {
    getOrders(user.id, handleOrders);
}

function handleOrders(orders) {
    getOrderDetails(orders[0], handleDetails);
}

function handleDetails(details) {
    processOrder(details, handleResult);
}

function handleResult(result) {
    console.log('Order processed', result);
}

getUser(handleUser);
```

#### 2. Use Promises
Promises help flatten the structure:

```javascript
getUser()
  .then(user => getOrders(user.id))
  .then(orders => getOrderDetails(orders[0]))
  .then(details => processOrder(details))
  .then(result => console.log('Order processed', result))
  .catch(err => console.error('Error:', err));
```

#### 3. Use Async/Await (Best Practice)
Async/await makes asynchronous code look synchronous:

```javascript
async function process() {
    try {
        const user = await getUser();
        const orders = await getOrders(user.id);
        const details = await getOrderDetails(orders[0]);
        const result = await processOrder(details);
        console.log('Order processed', result);
    } catch (err) {
        console.error('Error:', err);
    }
}

process();
```

### Pro Tip:

Always **prefer async/await** in modern JavaScript. It‚Äôs **cleaner, more readable**, and works well with **try/catch** for error handling.

If you want to master JavaScript as a software engineer, understanding and avoiding callback hell is **non-negotiable**.

Want to practice refactoring messy callback code? I can give you examples to clean up.

---

## Promises in JavaScript
A **Promise** in JavaScript is an object that represents the **eventual completion (or failure)** of an asynchronous operation and its resulting value.

### üß† Why Promises?
JavaScript is **single-threaded**, but async tasks (like API calls, file I/O) need to **run in the background**. Promises give us a structured way to handle these tasks **without callback hell**.

### üîß Syntax

```javascript
const promise = new Promise((resolve, reject) => {
    // async task
    if (success) {
        resolve(result);
    } else {
        reject(error);
    }
});
```

### üì¶ States of a Promise

| State         | Description                                  |
| ------------- | -------------------------------------------- |
| **Pending**   | Initial state, neither resolved nor rejected |
| **Fulfilled** | Operation completed successfully             |
| **Rejected**  | Operation failed                             |

### ‚úÖ Consuming a Promise

```javascript
promise
  .then(result => {
      // Handle success
  })
  .catch(error => {
      // Handle failure
  })
  .finally(() => {
      // Runs no matter what
  });
```

### üîÅ Chaining Promises

```javascript
doStep1()
  .then(result1 => doStep2(result1))
  .then(result2 => doStep3(result2))
  .then(finalResult => console.log(finalResult))
  .catch(err => console.error('Error:', err));
```

### üìå **Example**

- Without Promises!
	
```javascript
// Imagine a Database (I don't know about DB yet.. So, I am using a simple function)

function saveToDB(message, success, failure) {
    let internetSpeed = Math.floor(Math.random() * 10) + 1;
    if (internetSpeed > 5) {
        success(message);
    } else {
        failure(message);
    }
}

saveToDB(
    "Hi",
    (message) => {
        console.log(`Data: '${message}' is successfully saved!`),
            saveToDB(
                "Hello",
                (message) => {
                    console.log(
                        `Data: '${message}' is successfully saved!`
                    ),
                        saveToDB(
                            "I am",
                            (message) => {
                                console.log(
                                    `Data: '${message}' is successfully saved!`
                                ),
                                    saveToDB(
                                        "Sankho",
                                        (message) => {
                                            console.log(
                                                `Data: '${message}' is successfully saved!`
                                            ),
                                                saveToDB(
                                                    "How are you?",
                                                    (message) =>
                                                        console.log(
                                                            `Data: '${message}' is successfully saved!`
                                                        ),
                                                    (message) =>
                                                        console.log(
                                                            `Data: '${message}' isn't saved! Bad connection.`
                                                        )
                                                );
                                        },
                                        (message) =>
                                            console.log(
                                                `Data: '${message}' isn't saved! Bad connection.`
                                            )
                                    );
                            },
                            (message) =>
                                console.log(
                                    `Data: '${message}' isn't saved! Bad connection.`
                                )
                        );
                },
                (message) =>
                    console.log(
                        `Data: '${message}' isn't saved! Bad connection.`
                    )
            );
    },
    (message) =>
        console.log(`Data: '${message}' isn't saved! Bad connection.`)
);
```

üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±üò±

- Refactoring With promises!
	
```js
function saveToDB2(data) {
    return new Promise((resolve, reject) => {
        let internetSpeed = Math.floor(Math.random() * 10) + 1;
        if (internetSpeed > 5) {
            resolve(data);
        } else {
            reject(data);
        }
    });
}

saveToDB2("Hi")
    .then((result) => {
        console.log(`Data: '${result}' is successfully saved!`);
        return saveToDB2("Hello");
    })
    .then((result) => {
        console.log(`Data: '${result}' is successfully saved!`);
        return saveToDB2("I am");
    })
    .then((result) => {
        console.log(`Data: '${result}' is successfully saved!`);
        return saveToDB2("Sankho");
    })
    .then((result) => {
        console.log(`Data: '${result}' is successfully saved!`);
        return saveToDB2("How are you?");
    })
    .then((result) => {
        console.log(`Data: '${result}' is successfully saved!`);
    })
    .catch((err) => {
        console.log(`Data: '${err}' isn't saved! Bad connection.`);
    });
```

### ‚õî Common Mistakes

- **Not returning promises in `.then()`** chains

- **Forgetting to handle errors with `.catch()`**

- **Mixing callbacks with promises**

### üß© Promises vs Async/Await (Brief)

|Promises|Async/Await|
|---|---|
|Chain `.then()` calls|Uses `await` with cleaner syntax|
|More manual structure|Syntactic sugar on top of Promises|
|More verbose|Easier to read, debug|

---

## API Besics

### What is an API?

- Click [[API|here]] to learn more!

### What is JSON & XML?

- Click [[JSON|here]] to learn about JSON.

- Click [[XML|here]] to learn about XML.

### API testing Tools

- [Hoppscotch](https://hoppscotch.io/) <- Online, Browser base.

- [Postman](https://www.postman.com/) <- Offline software, Log in required.

### Free APIs

- [[Free APIs for Project.pdf|List]]

- [Website 1](https://free-apis.github.io/#/)

- [Website 2](https://mixedanalytics.com/blog/list-actually-free-open-no-auth-needed-apis/)

### API insights

##### ‚öôÔ∏è **What is AJAX?**

**AJAX = Asynchronous JavaScript And XML**

- Makes asynchronous requests to APIs without reloading the page.

- Nowadays used mostly with **JSON**, not XML.

- Powered by `fetch()` or `XMLHttpRequest`.

##### ‚öíÔ∏è **HTTP Methods (Verbs)**

|Method|Purpose|Used In Frontend?|
|---|---|---|
|`GET`|Retrieve data|‚úÖ Most common|
|`POST`|Send data|‚ö†Ô∏è Usually done via forms or backend|
|`DELETE`|Delete data|‚ùå Typically backend only|
|`PUT`|Update data|‚ùå Backend only (not in your original note, but common)|

##### üîÅ **Status Codes (Important Ones)**

|Code|Meaning|
|---|---|
|200|OK (Success)|
|400|Bad Request|
|404|Not Found|
|500|Internal Server Error|

üìù Learn more: [MDN HTTP Status Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status)

##### üéØ **Customizing API Requests**

1. **Query Strings**
	
- Add extra info to the URL:
	
```arduino
https://api.com/products?category=books&price=low
```
	
- Unrecognized query parameters are ignored by most APIs.

2. **API Routes**
	
- Defined by the API documentation.
	
- Example:
	
```bash
https://api.example.com/user/123/posts
```

##### üßæ **Headers**

- **Request Headers**: Sent with the request (e.g., `Authorization`, `Content-Type`)

- **Response Headers**: Received with the response (e.g., `Content-Length`, `Cache-Control`)

---

## API Handling with JavaScript
 When JSON format come to JS program it was in a big strings, that we can't directly access... We have two methods.

### JSON Methods
JavaScript provides two main methods to handle JSON data:

#### 1. `JSON.stringify()`

Converts a JavaScript object or value to a JSON string.

```javascript
const obj = { name: "Sankho", goal: "Super Software Engineer" };
const jsonStr = JSON.stringify(obj);
console.log(jsonStr); // '{"name":"Sankho","goal":"Super Software Engineer"}'
```

#### 2. `JSON.parse()`

Parses a JSON string and converts it into a JavaScript object.

```javascript
const jsonStr = '{"name":"Sankho","goal":"Super Software Engineer"}';
const obj = JSON.parse(jsonStr);
console.log(obj.name); // Sankho
```

**‚ö†Ô∏è Gotchas:**

- The string passed to `JSON.parse()` **must be valid JSON** (use double quotes for keys and string values).

- `JSON.stringify()` cannot serialize functions or `undefined`.

### `fetch()` Method

#### Purpose:
Used to make HTTP requests (GET, POST, etc.). Returns a **Promise**.

- Basic GET Example:
	
```javascript
fetch('https://api.example.com/data')
	.then(response => response.json()) // Parse JSON from the response
	.then(data => {
    	console.log(data); // Work with your data here
	})
	.catch(error => {
    	console.error('Fetch error:', error);
	});
```

- POST Example with JSON:
	
```javascript
const payload = {
	name: "Sankho",
	level: "Hardworking"
};

fetch('https://api.example.com/submit', {
	method: 'POST',
	headers: {
		'Content-Type': 'application/json'
	},
	body: JSON.stringify(payload)
})
	.then(response => response.json())
	.then(data => {
		console.log('Server response:', data);
	})
	.catch(error => {
		console.error('POST failed:', error);
	});
```

#### Quick Tips:

- `fetch()` is **asynchronous**, so use `async/await` for cleaner syntax:
    
```javascript
async function getData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        console.log(data);
    } catch (err) {
        console.error(err);
    }
}
```

- Always handle `.catch()` or use `try/catch` to avoid silent failures.

- Use `JSON.stringify()` when sending data; use `.json()` to receive data.

---

### Axios in JavaScript
**Axios** is a **promise-based HTTP client** for JavaScript, primarily used to **make HTTP requests from the browser or Node.js**. It's built on top of the native `XMLHttpRequest` in the browser and `http` module in Node.

#### üîß Core Features of Axios

1. **Make Requests**  
    Supports all HTTP methods: `GET`, `POST`, `PUT`, `DELETE`, etc.
    
```js
axios.get('https://api.example.com/data')
	.then(response => console.log(response.data))
    .catch(error => console.error(error));
```

2. **Automatic JSON Handling**  
    Automatically parses JSON responses and sets appropriate headers for sending JSON data.

3. **Request and Response Interceptors**  
    You can intercept requests/responses for things like auth tokens or logging.
    
```js
axios.interceptors.request.use(config => {
    config.headers.Authorization = 'Bearer yourToken';
    return config;
});
```

4. **Cancel Requests**  
    Built-in support to cancel requests using `CancelToken`.

5. **Timeouts and Errors**  
    Handles request timeouts and status-based error handling.
    
```js
axios.get('/data', { timeout: 5000 });
```

6. **Client-Side & Server-Side**  
    Works in both browser and Node.js environments.

#### üß† Why Use Axios Over `fetch()`?

|Feature|`fetch()`|`axios`|
|---|---|---|
|Response Parsing|Manual (`res.json()`)|Auto-parsed|
|Timeout Handling|Manual setup|Built-in|
|Request Cancellation|No native support|Built-in|
|Interceptors|No|Yes|
|Older Browser Support|Limited|Better|

#### üì¶ Installation

```bash
npm install axios
```

Or via CDN:

```html
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
```

#### ‚úÖ Quick Use Case Example

```js
async function getUserData(userId) {
  try {
    const response = await axios.get(`/api/users/${userId}`);
    return response.data;
  } catch (error) {
    console.error('Error fetching user:', error);
  }
}
```

---

## Request Header sending in JavaScript
To **send headers with Axios** in JavaScript, you pass them in the **`headers` field of the config object** as the second argument in most Axios methods like `axios.get()` or `axios.post()`.

### Syntax

```js
axios.get(url, {
  headers: {
    'Authorization': 'Bearer YOUR_TOKEN',
    'Content-Type': 'application/json',
    'Custom-Header': 'value'
  }
});
```

### Examples

#### 1. GET Request with Headers

```js
axios.get('https://api.example.com/data', {
  headers: {
    'Authorization': 'Bearer abc123',
    'Accept': 'application/json'
  }
});
```

#### 2. POST Request with Headers and Body

```js
axios.post('https://api.example.com/user', 
  {
    name: 'Sankho',
    role: 'student'
  }, 
  {
    headers: {
      'Content-Type': 'application/json',
      'X-App-Version': '1.0.0'
    }
  }
);
```

### Setting Default Headers (Globally)

If you're sending the same headers often (like `Authorization`), set defaults once:

```js
axios.defaults.headers.common['Authorization'] = 'Bearer abc123';
axios.defaults.headers.post['Content-Type'] = 'application/json';
```

### Example: Token Auth with Interceptor

```js
axios.interceptors.request.use(config => {
  config.headers.Authorization = 'Bearer yourTokenHere';
  return config;
});
```

### Notes

- Headers are key-value pairs.

- Case-insensitive (but typically capitalized for readability).

- You don‚Äôt need to manually set `Content-Type` for JSON ‚Äî Axios does it automatically unless you override it.

---

## [[JS OOPS 11 (Qs).pdf|OPPs in JavaScript ]]
**OOP (Object-Oriented Programming) in JavaScript** isn‚Äôt quite the same as in Java or C++. JavaScript started as a _prototype-based_ language, not a class-based one, but ES6 introduced `class` syntax to make it look and feel more familiar. Under the hood, it‚Äôs still prototypes doing the work.

### Core OOP Concepts in JavaScript
The big four pillars still apply:

#### 1. Encapsulation

- Grouping related data (properties) and behavior (methods) together.

- Achieved via objects, closures, or ES6 classes.
	
```js
class User {
	constructor(name, email) {
    	this.name = name;
    	this.email = email;
	}
	login() {
    	console.log(`${this.name} has logged in.`);
	}
}
```

#### 2. Abstraction

- Hiding internal complexity and exposing a clean interface.

- Can be done using private fields (`#field`) or convention (`_privateVar`).
	
```js
class BankAccount {
	#balance = 0; // Private field
	deposit(amount) {
    	if (amount > 0) this.#balance += amount;
	}
	getBalance() {
    	return this.#balance;
	}
}
```

#### 3. Inheritance
Inheritance in JavaScript is the mechanism by which one object can access properties and methods of another, allowing code reuse and a hierarchical structure for objects. Unlike class-based languages like Java or C++, JavaScript historically used **prototype-based inheritance**, though since ES6, the `class` syntax has made it look more familiar to developers from other languages.

Here‚Äôs the breakdown:

##### 1. Prototype-Based Inheritance (The Core Mechanism)
Every JavaScript object has an internal link to another object called its **prototype**.  
When you try to access a property on an object:

- JS looks for it on the object itself.

- If not found, it looks up the chain (prototype ‚Üí prototype ‚Üí ‚Ä¶) until `null` is reached.

Example:

```javascript
const parent = {
	greet() {
    	console.log("Hello from parent!");
	}
};

const child = Object.create(parent);
child.sayHi = function() {
	console.log("Hi from child!");
};

child.greet(); // Inherited from parent
child.sayHi(); // Defined on child
```

##### 2. Constructor Functions (Pre-ES6 Style)
Before `class`, inheritance was often done using **constructor functions** with `.prototype`.

Example:

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.sayName = function() {
  console.log(this.name);
};

function Student(name, grade) {
  Person.call(this, name); // Call parent constructor
  this.grade = grade;
}

// Inherit from Person
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

Student.prototype.sayGrade = function() {
  console.log(this.grade);
};

const s1 = new Student("Alice", "A");
s1.sayName();  // Alice
s1.sayGrade(); // A
```

##### 3. ES6 Class Syntax (Sugar Over Prototypes)
The `class` and `extends` keywords are **syntactic sugar** over the prototype system.  
It‚Äôs cleaner but works the same under the hood.

Example:

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
  sayName() {
    console.log(this.name);
  }
}

class Student extends Person {
  constructor(name, grade) {
    super(name); // Calls Person's constructor
    this.grade = grade;
  }
  sayGrade() {
    console.log(this.grade);
  }
}

const s1 = new Student("Bob", "B");
s1.sayName();  // Bob
s1.sayGrade(); // B
```

##### 4. Key Points to Remember

- **Prototype chain** is the real engine; classes are just syntax sugar.

- `Object.create()` is the cleanest way to set up inheritance without constructors.

- `super` in classes calls the parent‚Äôs constructor or methods.

- You can even chain multiple levels of inheritance.

- JavaScript supports **single inheritance** for prototypes but can mimic **multiple inheritance** via mixins.

---

#### 4. Polymorphism

- Same method name, different behavior depending on the object.

- Achieved by method overriding.
    
```js
class Animal {
	speak() {
    	console.log("Some sound");
	}
}
class Dog extends Animal {
	speak() {
    	console.log("Woof!");
	}
}
```

---

### ‚ÄºÔ∏è Code Example:
```js
//Main concern!!
{
    let student1 = {
        name: "Sankho",
        class: 12,
        roll: 1,
        seyInfo() {
            console.log(
                `Hi, My name is ${this.name}. I am ${this.class + 5} years old.`
            );
        },
    };
    let student2 = {
        name: "ChatGPT",
        class: 10,
        roll: 5,
        seyInfo() {
            console.log(
                `Hi, My name is ${this.name}. I am ${this.class + 5} years old.`
            );
        },
    };
    let student3 = {
        name: "Rohit",
        class: 9,
        roll: 1,
        seyInfo() {
            console.log(
                `Hi, My name is ${this.name}. I am ${this.class + 5} years old.`
            );
        },
    };
    // So, here we can see that for every student we have to define a new object 	for every student this is very inefficient.
    // If somehow we can create a blueprint like ejs, then this would be very 		easy :).
}

// Object prototype
// this is really fascinating!

// Question: How every array can use push function?
// Answer: Object prototype!

// Object prototype is a collection of methods that can be access from any same type of object.
// i.e - Every array has a reference of array prototype... that why we can use it from any array & on the other hand as the the individual prototype have only the reference of only one real instance that's why it's also efficient in terms of memory usage.

{
    console.log("----------------------Convectional------------------------");
    let arr1 = [1, 2, 3];
    let arr2 = [4, 5, 6];
	
    arr1.sayHello = () => console.log("Hello!");
    arr2.sayHello = () => console.log("Hello!");
	
    let a = Boolean(arr1.sayHello === arr2.sayHello);
    let b = Boolean(arr1.push === arr2.push);
	
    console.log(a); // False
    console.log(b); // True
	
    // What happened?
    // As our defined functions are in individual level that's why, the 			references are not equal.
    // But, for prototype function the reference is same... so, it's true.
	
    //accessing prototype
    //Individual
    console.log(arr1.__proto__);
    //We can change it! But, it will change this method definition for all 			arrays... So, not a good practice.
    arr1.__proto__.push = (n) => console.log(n);
    arr1.push(3);
	
    // Main prototype
    console.log(Array.prototype);
}

// Factory function
// A step up for more reusability
{
    console.log("----------------Factory Function-------------------------");
    let personMaker = function (name, age) {
        let person = {
            name: name,
            age: age,
            talk() {
                console.log(`Hi, my name is ${this.name}.`);
            },
        };
        return person;
    };
	
    // We can now make new individual object by writing only one line.
    let p1 = personMaker("Sankho", 19);
    let p2 = personMaker("Rohit", 17);
	
    // The talk method is working
    p1.talk();
	
    console.log(p1);
    console.log(p2);
	
    // Cons
    let a = Boolean(p1.talk === p2.talk);
    console.log(a);
    // We can clearly see that, the reference of talk methods are different... 		means the stores in different places... Inefficient in terms of memory :(
}

// Constructors
// Special functions to create blueprints
{
    console.log("-----------------------Constructor-----------------------");
    // Let's take the previous example
	
    // programmer rule: constructor function name's first letter should be 			capitalized and it should not return anything.
    // Not necessary to follow but, for being better programmer we should follow.
    const Person = function (name, age) {
        this.name = name;
        this.age = age;
        console.log(this);
    };
	
    Person.prototype.talk = function () {
        console.log(`Hi! my name is ${this.name}`);
    };
	
    // This works the same way... One line for each object.
    let p1 = new Person("Sankho", 19);
    let p2 = new Person("Rohit", 17);
    // New: A new key work that make a function into constructor in just 4 steps!
    // 1. First new creates a empty object.
    // 2. Add the prototype function's reference to the object
    // 3. change the this from default to the variable (object)
    // 4, stores the parameters as key value pair.
	
    // We make the talk method a prototype, so, every instance will have a 			reference of that.
    p1.talk();
	
    console.log(p1);
    console.log(p2);
	
    let a = Boolean(p1.talk === p2.talk);
    console.log(a);
    // Here we can see that it only stores the reference so, memory efficient.
	
    // Cons
    // The syntax is complicated & the methods took separate declaration to work.
}

// Classes
// Same logic, but cleaner implementation.
{
    console.log("--------------------------Classes------------------------");
    // As a good developer, we should follow the class creating rules which are 	same as constructor creating rules.
    class Person {
        constructor(name, age) {
            // Here we can clearly identify that it's a constructor function.
            this.name = name;
            this.age = age;
        }
        talk() {
            console.log(`Hi! my name is ${this.name}`);
        }
        // The prototype method is much easy to declare here.
        // The prototype is in the same code block as the blueprint.
    }
	
    // The syntax for creating new instances is same
    let p1 = new Person("Sankho", 19);
    let p2 = new Person("Rohit", 17);
	
    // Prototype functions are useable.
    p2.talk();
	
    console.log(p1);
    console.log(p2);
	
    let a = Boolean(p1.talk === p2.talk);
    console.log(a);
    // Here we can see that it only stores the reference so, memory efficient.
}

// Inheritance
// Inheritance is a mechanism that allows us to create new classes on the basis of already existing classes.
{
    /*     
    class Dog {
        constructor(name){
            this.name = name;
            this.type = "Dog"
            this.blood = "Warm-blooded"
        }
        eat(){
            console.log(`${this.name} is eating...`);
        }
        bark(){
            console.log("Woof...");
        }
    }
	
    class Cat {
        constructor(name){
            this.name = name;
            this.type = "Cat"
            this.blood = "Warm-blooded"
        }
        eat(){
            console.log(`${this.name} is eating...`);
        }
        meow(){
            console.log("meowww...");
        }
    } 
    */
    // In this example, we can see that both classes have some common properties!
    // So, here we can use inheritance to minimize redundancy.
	
    console.log("-----------------------Inheritance-----------------------");
    class Mammal {
        constructor(name) {
            this.name = name;
            this.blood = "Warm-blooded";
        }
        eat() {
            console.log(`${this.name} is eating...`);
        }
    }
	
    class Dog extends Mammal {
        // We inherit the properties from Mammal using extends keywords
        constructor(name) {
            super(name); // Calling the base/parent class constructor
            this.type = "Dog";
        }
        // Some class specific methods
        bark() {
            console.log("Woof...");
        }
    }
	
    class Cat extends Mammal {
        constructor(name) {
            super(name);
            this.type = "Cat";
        }
        // Some class specific methods
        meow() {
            console.log("meowww...");
        }
		
        // We can override prototype function directly
        eat() {
            console.log("Cat is eating");
        }
    }
	
    let dog1 = new Dog("Tuffie");
    let dog2 = new Dog("Maxxie");
	
    let cat1 = new Cat("Ratana");
    let cat2 = new Cat("Meowie");
	
    console.log(dog1);
    console.log(dog2);
    console.log(cat1);
    console.log(cat2);
	
    dog1.bark();
    dog2.eat();
	
    // cat2.bark(); // This will throw error, we are trying to access sibling 		class specific methods
    cat1.meow();
    cat2.eat(); // Override
	
    let a = Boolean(dog1.bark === dog2.bark);
    let b = Boolean(cat1.eat === cat2.eat);
    let c = Boolean(dog1.eat === dog2.eat);
    let d = Boolean(dog1.eat === cat2.eat);
	
    console.log(a); // Same class instance
    console.log(b); // Same class instance
    console.log(c); // Parent class's same inherited instance
    console.log(d); // Override side effect.
}
```

---

### Object Prototype
In JavaScript, **prototypes** are the foundation of how objects share behavior. They‚Äôre the mechanism that makes **inheritance** work in JS.

#### 1. Core Concept
Every JavaScript object has an internal link to another object called its **prototype** (accessible via `Object.getPrototypeOf(obj)` or `obj.__proto__` in older syntax).

That prototype can have properties and methods. If you try to access a property on an object and it‚Äôs not there, JavaScript **walks up the prototype chain** to look for it.

#### 2. Prototype Chain Example

```js
const animal = {
  eat() { console.log("Eating..."); }
};

const dog = Object.create(animal);
dog.bark = function() { console.log("Barking..."); };

dog.bark(); // "Barking..."
dog.eat();  // Found in prototype ‚Üí "Eating..."
```

Here:

- `dog`‚Äôs prototype is `animal`.

- If JS can‚Äôt find `eat` in `dog`, it looks in `animal`.

#### 3. The Prototype Chain Diagram

```
dog --> animal.prototype --> Object.prototype --> null
```

- `Object.prototype` is the top-level object.

- Its prototype is `null`, ending the chain.

#### 4. Key Points

- **Method sharing**: Prototypes prevent method duplication across instances.

- **Prototype chain**: Lookup continues up the chain until found or null.

- **Modification**: Adding methods to the prototype affects all linked instances.

- **Caution**: Overriding `Object.prototype` is dangerous‚Äîaffects everything.

---

### Factory Function
A **factory function** in JavaScript is simply a **regular function that returns an object** without using the `new` keyword or a class.

Think of it as a "blueprint maker" that **creates and returns objects**‚Äîkind of like a small factory producing product instances.

#### 1. Why Use a Factory Function?

- Avoids the complexities of `this` and `new` from constructor functions.

- Lets you create objects with **private data** using closures.

- Makes code more flexible than classes in some scenarios.

#### 2. Basic Example

```javascript
function createUser(name, age) {
    return {
        name,
        age,
        greet() {
			console.log(`Hello, my name is ${this.name} and I am ${this.age} 				years old.`);
        }
    };
}

// Usage
const user1 = createUser("Alice", 25);
const user2 = createUser("Bob", 30);

user1.greet(); // Hello, my name is Alice and I am 25 years old.
user2.greet(); // Hello, my name is Bob and I am 30 years old.
```

Here:

- `createUser` is a **factory function**.

- It returns a **new object** every time it‚Äôs called.

#### 3. Factory Function with Private Data
You can hide internal details using closures:

```javascript
function createCounter() {
    let count = 0; // private variable
	
    return {
        increment() {
            count++;
            console.log(count);
        },
        getCount() {
            return count;
        }
    };
}

const counter = createCounter();
counter.increment(); // 1
counter.increment(); // 2
console.log(counter.getCount()); // 2
console.log(counter.count); // undefined (private)
```

#### 3. When to Use Over Classes

- You want **private state** without extra syntax.

- You want more flexibility (e.g., return different object shapes depending on arguments).

- You prefer avoiding `this` and `prototype` headaches.

---

### Constructors
In JavaScript, a **constructor** is a special function used to create and initialize objects.  
It‚Äôs typically used with the `new` keyword and is often defined inside a **class** or as a standalone function.

#### 1. Constructor in a Class
When using ES6 `class` syntax, the `constructor` method is automatically called when you create a new instance.

```javascript
class Person {
	constructor(name, age) {
    	this.name = name;
    	this.age = age;
	}
	
	greet() {
		console.log(`Hi, I'm ${this.name} and I'm ${this.age} years old.`);
	}
}

const p1 = new Person("Alice", 25);
p1.greet(); // Hi, I'm Alice and I'm 25 years old.
```

**Key points:**

- Only **one** constructor is allowed per class.

- If you don‚Äôt define one, JavaScript creates a default constructor for you.

#### 2. Constructor Function (Pre-ES6)
Before ES6 classes, constructors were just normal functions starting with a capital letter.

```javascript
function Car(brand, year) {
  this.brand = brand;
  this.year = year;
}

Car.prototype.showInfo = function () {
  console.log(`${this.brand} - ${this.year}`);
};

const car1 = new Car("Toyota", 2022);
car1.showInfo(); // Toyota - 2022
```

#### 3. How the `new` Keyword Works
When you use `new Constructor(...)`:

1. A new empty object is created.

2. `this` is set to point to that new object.

3. The constructor code runs and assigns properties/methods to `this`.

4. The new object is returned (unless you return something else explicitly).

#### 4. Important Notes

- Constructors **should not** return primitive values (like strings or numbers).

- Use PascalCase naming for constructor functions (`Person`, `Car`) for clarity.

- You can combine constructors with **prototypes** for shared methods (saves memory).

- In ES2022+, you can use **class fields** inside constructors for cleaner initialization.

---

### Classes

#### 1. What a Class Really Is in JavaScript

In JavaScript, **classes are not magical new data structures** ‚Äî they‚Äôre just **syntactic sugar** over the older **prototype-based inheritance** model.

When you define a class in JS:

- It‚Äôs basically creating a constructor function.

- The methods you define are put on the class‚Äôs `.prototype` object.

- You can still use `instanceof` and `Object.getPrototypeOf()` to inspect inheritance.

#### 2. Basic Class Syntax

```javascript
class Person {
	constructor(name, age) {
		this.name = name;
    	this.age = age;
	}
	
	greet() {
    	console.log(`Hi, I'm ${this.name} and I'm ${this.age} years old.`);
	}
}

const p1 = new Person("Sankho", 21);
p1.greet(); // Hi, I'm Sankho and I'm 21 years old.
```

**Key notes:**

- `constructor` runs automatically when you use `new`.

- Methods inside a class **do not need `function` keyword**.

- All class methods are **non-enumerable** by default (unlike normal object methods).

#### 3. Class Expressions

Classes can be:

```javascript
// Named class expression
const MyClass = class MyNamedClass {
	// internal name only visible inside class
};

// Anonymous class expression
const AnotherClass = class {
	// no name
};
```

#### 4. Inheritance with `extends`

```javascript
class Student extends Person {
	constructor(name, age, grade) {
    	super(name, age); // calls parent constructor
    	this.grade = grade;
	}
	
	greet() {
    	super.greet(); // calls Person.greet()
    	console.log(`I am in grade ${this.grade}.`);
	}
}

const s1 = new Student("Sankho", 21, "A");
s1.greet();
```

**Key rules:**

- `super()` must be called **before** accessing `this` in a subclass constructor.

- You can call parent methods using `super.methodName()`.

#### 5. Getters & Setters

```javascript
class Product {
	constructor(name, price) {
    	this.name = name;
    	this._price = price;
	}
	
	get price() {
    	return this._price;
	}
	
	set price(value) {
    	if (value < 0) throw new Error("Price can't be negative");
    	this._price = value;
	}
}

const p = new Product("Laptop", 1200);
console.log(p.price); // 1200
p.price = 1500;
```

- Useful for encapsulation.

- Can be used with `Object.defineProperty` under the hood.

#### 6. Static Methods & Properties

```javascript
class MathUtil {
	static add(a, b) {
    	return a + b;
	}
}

console.log(MathUtil.add(3, 5)); // 8
```

- Static members are **accessible on the class itself**, not instances.

- Use for utility/helper functions that don‚Äôt depend on instance data.

#### 7. Private Fields (#)

```javascript
class BankAccount {
	#balance = 0; // truly private
	
	deposit(amount) {
    	this.#balance += amount;
	}
	
	getBalance() {
    	return this.#balance;
	}
}

const acc = new BankAccount();
acc.deposit(100);
console.log(acc.getBalance()); // 100
// acc.#balance // ‚ùå SyntaxError
```

- Introduced in ES2022.

- Starts with `#` ‚Äî not accessible outside the class.

#### 8. Class Fields (Public)

```javascript
class Counter {
	count = 0; // public instance field
	
	increment() {
    	this.count++;
	}
}
```

- Declared directly inside class body (without `var`, `let`, or `const`).

#### 9. Behind the Scenes

```javascript
class A {}
console.log(typeof A); // function
console.log(Object.getPrototypeOf(A)); // Function.prototype
console.log(Object.getPrototypeOf(A.prototype)); // Object.prototype
```

- Classes are **special functions** with `prototype` properties.

- Methods live on `ClassName.prototype`.

- `extends` sets the prototype chain of both instances and constructors.

#### 10. Key Pitfalls

1. **No hoisting** ‚Äî unlike function declarations, class declarations are **not** hoisted.

2. Must use `new` to call a class constructor.

3. `this` binding works differently from arrow functions ‚Äî normal methods lose `this` when extracted unless bound.

#### 11. Advanced Patterns

- **Mixins** (adding multiple behaviors):

```javascript
let Flyer = Base => class extends Base {
  fly() { console.log("Flying"); }
};

class Animal {}
class Bird extends Flyer(Animal) {}

const b = new Bird();
b.fly(); // Flying
```

- **Abstract-like classes** (no true abstract in JS, but can throw in constructor).

---

