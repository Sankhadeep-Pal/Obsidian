# [MongoDB Tutorial](https://www.apnacollege.in/path-player?courseid=sigma-8&unit=68a48c17c68931e41305b431Unit)

## What is MongoDB?

- MongoDB is an **open-source, NoSQL database** that uses a **document-oriented data model**.

- Unlike traditional relational databases (SQL), which store data in rows and columns, MongoDB stores data in **documents ([[BSON]] format)** organized into **collections**.

- Its design prioritizes **scalability, flexibility, and speed**, making it suitable for modern applications where data structures evolve frequently.

---

## Why we use MongoDB?

1. **Schema Flexibility**
    
    - No fixed schema â†’ each document can have a different structure.
    
    - Example: One document may have `{ name, age }` and another `{ name, age, email, address }`.

2. **High Performance**
    
    - Optimized for **fast reads and writes**.
    
    - Supports in-memory storage engine for speed.

3. **Scalability**
    
    - Supports **horizontal scaling** using **sharding**.
    
    - This allows MongoDB to handle **huge datasets** across multiple servers.

4. **High Availability**
    
    - Through **replica sets**:
        
        - **Primary node** â†’ handles reads & writes.
        
        - **Secondary nodes** â†’ replicate data and serve as backups.
        
        - Automatic fail-over ensures up-time if the primary crashes.

5. **Powerful Querying & Aggregation**
    
    - MongoDB Query Language (MQL) supports filtering, sorting, and updating.
    
    - Aggregation framework lets you transform data (like SQL GROUP BY).

### How MongoDB Differs from SQL

|SQL Database|MongoDB (NoSQL)|
|---|---|
|Data in rows & tables|Data in documents & collections|
|Requires fixed schema|Schema-less, flexible|
|Supports JOINs|Limited JOINs (`$lookup`)|
|Vertical scaling|Horizontal scaling|
|Uses SQL language|Uses MongoDB Query Language (MQL)|

---
 
## Real-World Use Cases

- **E-commerce** â†’ Flexible product catalogs.

- **Social Media Apps** â†’ Handling user posts, comments, and relationships.

- **IoT (Internet of Things)** â†’ Managing unstructured sensor data.

- **Analytics & Logging** â†’ Real-time log storage and querying.

- **Content Management Systems (CMS)** â†’ Dynamic, schema-less data storage.

---

## Let's start with MongoDB

### 1. Start the MongoDB Service
Make sure the MongoDB server (`mongod`) is running:

```bash
sudo systemctl start mongod
```

Enable it to auto-start at boot:

```bash
sudo systemctl enable mongod
```

Check status:

```bash
systemctl status mongod
```

> If you are using Fedora you have to config some files using the image:
![[mongodb_tuning_flowchart.png]]

### 2. Open the MongoDB Shell
Depending on what was installed, youâ€™ll use one of these:

- **New Shell** (preferred):
    
```bash
mongosh
```

- **Old Shell** (if `mongosh` not installed):
    
```bash
mongo
```

This opens an **interactive shell** where you can type commands.

### 3. Basic Database Operations
Here are the **most useful commands** for working inside MongoDB shell.

#### ğŸ”¹ Show all databases

```js
show dbs
```

#### ğŸ”¹ Switch to / create a database

```js
use myDatabase
```

(_Creates it only when data is added._)

#### ğŸ”¹ Show all collections (like tables)

```js
show collections
```

### 4. CRUD Operations (Core Commands)

#### ğŸ”¸ Insert a document

```js
db.users.insertOne({ name: "Alice", age: 23 })
```

#### ğŸ”¸ Insert multiple

```js
db.users.insertMany([
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 28 }
])
```

#### ğŸ”¸ Find (Read) documents

```js
db.users.find()                        // show all
db.users.find({ age: { $gt: 25 } })    // filter with condition
```

#### ğŸ”¸ Update a document

```js
db.users.updateOne(
  { name: "Alice" },
  { $set: { age: 24 } }
)
```

#### ğŸ”¸ Delete a document

```js
db.users.deleteOne({ name: "Bob" })
```

### 5. Extra Commands

- **Check current database**
    
```js
db
```

- **Drop (delete) a database**
    
```js
db.dropDatabase()
```

- **Drop a collection**
    
```js
db.users.drop()
```


### **6. Exit the MongoDB Shell**

```js
exit
```

---


## How MongoDB Stores Data

### ğŸ“œ Data Model

- MongoDB stores data in **documents** (not rows/columns like SQL).

- Each document is structured as **BSON** (Binary JSON).

- Documents are grouped into **collections**, and collections are grouped into **databases**.

Example Document:

```json
{
  "_id": ObjectId("64aef812b3f45cde12345678"),
  "name": "Alice",
  "age": 23,
  "skills": ["MongoDB", "Node.js"],
  "address": { "city": "New York", "zip": 10001 }
}
```

ğŸ”‘ Key point: Unlike SQL, documents in the same collection **donâ€™t need the same fields** â†’ schema flexibility.

### ğŸ“„ [[BSON]] (Binary JSON)

- MongoDB does **not** store raw [[JSON]]. It uses **BSON**, a binary format optimized for:
    
    - **Speed** â†’ easy for computers to parse.
    
    - **More data types** â†’ supports `Date`, `ObjectId`, `Decimal128`, binary data (not available in plain JSON).
    
    - **Efficient storage** â†’ smaller size, faster indexing.

So in storage:

- JSON â†’ converted into **BSON** before being written to disk.

- When you query, BSON â†’ converted back to JSON for readability.

### âœï¸ Storage Engine

MongoDB uses **storage engines** to handle how data is written to disk and memory.

- **Default: WiredTiger Engine**
    
    - Stores data in **compressed form** (reduces disk usage).
    
    - Uses **B-trees** for indexing.
    
    - Keeps frequently used data in memory for fast reads.
    
    - Uses **journaling** â†’ writes an operation log to ensure crash recovery.

- **MMAPv1 Engine** (deprecated)
    
    - Older engine, used memory-mapped files.
    
    - WiredTiger replaced it because itâ€™s faster, more scalable.

### ğŸ—‚ï¸ File Structure

- By default, data is stored in:
    
```
/var/lib/mongo
```
    
    (on Linux systems, unless changed in config).

Inside youâ€™ll find:

- `.wt` files â†’ actual data collections stored by WiredTiger.

- `journal/` â†’ write-ahead logs for crash recovery.

- `diagnostic.data/` â†’ diagnostic & statistics data.

### ğŸ‘‰ Indexes

- MongoDB automatically creates an **index on `_id`** field for every document.

- Additional indexes (single field, compound, text, geospatial) improve query performance.

- Indexes are stored alongside data in B-trees inside WiredTiger.

### ğŸ” Replication & Sharding Storage

- **Replication (Replica Set):**
    
    - Each node stores the same data copy in BSON.
    
    - Primary accepts writes, secondaries replicate.

- **Sharding (Horizontal Scaling):**
    
    - Data split across multiple servers.
    
    - A **config server** stores metadata about which shard holds which data.

### ğŸ“¨ Data Flow (Write & Read Path)

- **Write Operation (Insert/Update):**
    
    1. App sends JSON data â†’ converted to BSON.
    
    2. Stored in memory (cache) first.
    
    3. Written to **WiredTiger files (`.wt`)**.
    
    4. Write-ahead log (journal) updated for safety.

- **Read Operation (Find):**
    
    1. Query checks **indexes** first.
    
    2. Data pulled from memory cache (fast) or disk (if not cached).
    
    3. BSON â†’ converted back to JSON â†’ sent to client.

---

## Document Hierarchy in MongoDB
MongoDB organizes data in a **4-level hierarchy**:

### 1. Database (Top Level)

- The highest container for data.

- Each **database** holds multiple **collections**.

- Default databases: `admin`, `local`, `config`.

ğŸ‘‰ Example:

```
myDatabase
 â”œâ”€â”€ users
 â”œâ”€â”€ products
 â””â”€â”€ orders
```

### 2. Collection

- A **group of documents** (like a table in SQL, but without schema).

- Collections exist inside a **database**.

- Do **not enforce schema** â†’ documents inside may differ.

ğŸ‘‰ Example:

```
users (collection)
 â”œâ”€â”€ { name: "Alice", age: 23 }
 â”œâ”€â”€ { name: "Bob", skills: ["Java", "MongoDB"] }
 â””â”€â”€ { name: "Charlie", email: "charlie@mail.com" }
```

### 3. Document

- The **basic unit of data**.

- Stored as **BSON** (Binary JSON).

- Contains **key-value pairs** (fields and values).

ğŸ‘‰ Example:

```json
{
  "_id": ObjectId("64aef812b3f45cde12345678"),
  "name": "Alice",
  "age": 23,
  "skills": ["MongoDB", "Node.js"],
  "address": { "city": "New York", "zip": 10001 }
}
```

### 4. Field

- Inside each document â†’ data is stored as **field:value** pairs.

- A field can hold:
    
    - Single value â†’ `"name": "Alice"`
    
    - Array â†’ `"skills": ["MongoDB", "Node.js"]`
    
    - Embedded document â†’ `"address": { "city": "New York", "zip": 10001 }`

### Hierarchy Visualized

```
Database
 â””â”€â”€ Collection
      â””â”€â”€ Document
           â””â”€â”€ Fields (key:value)
```

**SQL Analogy** (to remember easily):

- **Database** â†’ Database

- **Collection** â†’ Table

- **Document** â†’ Row

- **Field** â†’ Column

---

## CRUD Operations
CRUD = **Create, Read, Update, Delete** â†’ the 4 fundamental operations on data.  
All are executed inside the **MongoDB shell (`mongosh`)** or from a driver (Node.js, Python, etc.).

### 1. Create

#### Insert One Document

```js
db.users.insertOne({
  name: "Alice",
  age: 23,
  email: "alice@example.com"
})
```

#### Insert Many Documents

```js
db.users.insertMany([
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 28, skills: ["MongoDB", "Node.js"] }
])
```

ğŸ‘‰ Creates new documents inside a collection.  

ğŸ‘‰ If `_id` is not specified, MongoDB generates an `ObjectId`.

### 2. Read

#### Find All Documents

```js
db.users.find()
```

#### Find with Condition

```js
db.users.find({ age: { $gt: 25 } })
```

#### Find One Document

```js
db.users.findOne({ name: "Alice" })
```

#### Projection (Show specific fields only)

```js
db.users.find({}, { name: 1, age: 1, _id: 0 })
```

(Shows only name & age, hides `_id`)

ğŸ‘‰ `find()` returns a **cursor** (set of documents).  

ğŸ‘‰ You can filter, sort, and limit results.

#### Query Operators
Operators are **special symbols** used inside queries to filter, compare, and manipulate data.  
They start with a `$` sign.

##### 1. Comparison Operators
Used to compare values.

|Operator|Meaning|Example|
|---|---|---|
|`$eq`|Equal to|`db.users.find({ age: { $eq: 25 } })`|
|`$ne`|Not equal to|`db.users.find({ age: { $ne: 25 } })`|
|`$gt`|Greater than|`db.users.find({ age: { $gt: 25 } })`|
|`$gte`|Greater than or equal|`db.users.find({ age: { $gte: 25 } })`|
|`$lt`|Less than|`db.users.find({ age: { $lt: 25 } })`|
|`$lte`|Less than or equal|`db.users.find({ age: { $lte: 25 } })`|
|`$in`|Matches any value in an array|`db.users.find({ age: { $in: [20, 25, 30] } })`|
|`$nin`|Not in array|`db.users.find({ age: { $nin: [20, 25, 30] } })`|

âœ… Example:

```js
db.users.find({ age: { $gt: 25 } })      // age > 25 â†’ Bob, Charlie
db.users.find({ age: { $lte: 23 } })     // age <= 23 â†’ Alice
db.users.find({ age: { $in: [23, 28] } })// age is 23 or 28 â†’ Alice, Charlie
db.users.find({ age: { $ne: 30 } })      // not equal 30 â†’ Alice, Charlie
```

##### 2. Logical Operators
Combine multiple conditions.

|Operator|Meaning|Example|
|---|---|---|
|`$and`|All conditions must be true|`db.users.find({ $and: [ { age: { $gt: 20 } }, { age: { $lt: 30 } } ] })`|
|`$or`|At least one condition true|`db.users.find({ $or: [ { age: 25 }, { name: "Alice" } ] })`|
|`$nor`|None of the conditions true|`db.users.find({ $nor: [ { age: 25 }, { name: "Alice" } ] })`|
|`$not`|Negates a condition|`db.users.find({ age: { $not: { $gt: 25 } } })`|

âœ… Example:

```js
db.users.find({ $and: [ { age: { $gt: 20 } }, { age: { $lt: 29 } } ] })
// Alice & Charlie (age between 21â€“28)

db.users.find({ $or: [ { name: "Alice" }, { age: 30 } ] })
// Alice OR Bob

db.users.find({ $nor: [ { name: "Alice" }, { age: 30 } ] })
// Excludes Alice and Bob â†’ Charlie

db.users.find({ age: { $not: { $gt: 28 } } })
// Not greater than 28 â†’ Alice
```

##### 3. Element Operators
Check for existence or type of a field.

|Operator|Meaning|Example|
|---|---|---|
|`$exists`|Checks if field exists|`db.users.find({ email: { $exists: true } })`|
|`$type`|Checks field data type|`db.users.find({ age: { $type: "int" } })`|

âœ… Example:

```js
db.users.find({ email: { $exists: true } })
// Alice & Charlie (Bob has no email field)

db.users.find({ email: { $type: "string" } })
// Only Alice (Charlie has null, Bob no email)
```

##### 4. Evaluation Operators
Special matching operations.

|Operator|Meaning|Example|
|---|---|---|
|`$regex`|Matches regex pattern|`db.users.find({ name: { $regex: /^A/ } })`|
|`$expr`|Use aggregation expressions in query|`db.sales.find({ $expr: { $gt: ["$amount", "$target"] } })`|
|`$mod`|Matches remainder|`db.users.find({ age: { $mod: [2, 0] } })` â†’ even ages|
|`$text`|Text search (requires text index)|`db.articles.find({ $text: { $search: "mongodb" } })`|

âœ… Example:

```js
db.users.find({ name: { $regex: /^A/ } })
// Name starts with A â†’ Alice

db.users.find({ $expr: { $gt: ["$age", 25] } })
// Age > 25 â†’ Bob, Charlie

db.users.find({ age: { $mod: [2, 0] } })
// Even ages â†’ Bob (30), Charlie (28)

db.users.find({ $text: { $search: "MongoDB" } })
// Requires text index â†’ matches Alice, Charlie
```

##### 5. Array Operators
For working with arrays inside documents.

|Operator|Meaning|Example|
|---|---|---|
|`$all`|Matches arrays that contain all specified values|`db.users.find({ skills: { $all: ["MongoDB", "Node.js"] } })`|
|`$elemMatch`|Match documents with array elements meeting condition|`db.users.find({ scores: { $elemMatch: { $gt: 80, $lt: 100 } } })`|
|`$size`|Matches arrays of given length|`db.users.find({ skills: { $size: 3 } })`|

âœ… Example:

```js
db.users.find({ skills: { $all: ["MongoDB", "Node.js"] } })
// Must have both â†’ Alice

db.users.find({ skills: { $size: 2 } })
// Array length = 2 â†’ Bob

db.users.find({ scores: { $elemMatch: { $gt: 80, $lt: 90 } } })
// Any score between 81â€“89 â†’ Bob (85), Charlie (88)
```

##### 6. Projection Operators
Control fields returned in results.

|Operator|Meaning|Example|
|---|---|---|
|`$`|Projects first matching array element|`db.users.find({ "scores": 95 }, { "scores.$": 1 })`|
|`$slice`|Returns a subset of array|`db.users.find({}, { skills: { $slice: 2 } })`|

âœ… Example:

```js
db.users.find({ name: "Alice" }, { name: 1, age: 1, _id: 0 })
// Show only name & age for Alice

db.users.find({ scores: 95 }, { "scores.$": 1 })
// Show only the matched score â†’ [95]

db.users.find({}, { skills: { $slice: 2 } })
// Show only first 2 skills for each user
```

#### Nesting

##### Example Collection

```js
db.users.insertMany([
	{
    	_id: 1,
    	name: "Alice",
    	age: 23,
    	address: { city: "New York", zip: 10001 },
    	scores: [95, 82, 90]
	},
	{
    	_id: 2,
    	name: "Bob",
    	age: 30,
    	address: { city: "Paris", zip: 75001 },
    	scores: [70, 85, 60]
	},
	{
    	_id: 3,
    	name: "Charlie",
    	age: 28,
    	address: { city: "London", zip: 10005 },
    	scores: [88, 92, 75]
	}
])
```

##### 1. Querying Fields in Nested Documents
Use **dot notation** to access nested fields.

```js
db.users.find({ "address.city": "London" })
// Matches Charlie
```

```js
db.users.find({ "address.zip": { $gt: 50000 } })
// Matches Bob (75001), Charlie (10005 is > 50000? No, only Bob)
```

##### 2. Querying Arrays with Conditions

```js
db.users.find({ scores: 95 })
// Matches Alice (scores array contains 95)
```

```js
db.users.find({ scores: { $gt: 90 } })
// Matches Alice (95), Charlie (92) because at least one score > 90
```

##### 3. Nested Array Queries with `$elemMatch`

```js
db.users.find({ scores: { $elemMatch: { $gt: 80, $lt: 90 } } })
// Matches Bob (85), Charlie (88)
```

##### 4. Multiple Conditions in Nested Documents

```js
db.users.find({
  $and: [
    { "address.city": "New York" },
    { age: { $lt: 25 } }
  ]
})
// Matches Alice (New York, age 23)
```

##### 5. Nested Queries in Projection
You can also **return only nested fields**:

```js
db.users.find(
  { name: "Alice" },
  { "address.city": 1, _id: 0 }
)
// Output â†’ { "address" : { "city": "New York" } }
```

---

### 3. Update

#### Update One Document

```js
db.users.updateOne(
  { name: "Alice" },              // filter
  { $set: { age: 24 } }           // update operation
)
```

#### Update Many Documents

```js
db.users.updateMany(
  { age: { $lt: 30 } },
  { $inc: { age: 1 } }            // increment age by 1
)
```

#### Replace Entire Document

```js
db.users.replaceOne(
  { name: "Bob" },
  { name: "Bobby", age: 31, city: "Paris" }
)
```

ğŸ‘‰ `$set`, `$inc`, `$push`, `$pull`, etc. are **update operators**.

#### Update Operators

##### 1. Field Update Operators

###### **$set â†’ Set or add a new field**

```js
db.users.updateOne(
  { name: "Alice" },
  { $set: { age: 24, city: "New York" } }
)
// Aliceâ€™s age updated, new field 'city' added
```

###### **$unset â†’ Remove a field**

```js
db.users.updateOne(
  { name: "Charlie" },
  { $unset: { email: "" } }
)
// Removes 'email' field from Charlie
```

###### **$rename â†’ Rename a field**

```js
db.users.updateOne(
  { name: "Bob" },
  { $rename: { "skills": "techSkills" } }
)
// 'skills' renamed to 'techSkills' for Bob
```

##### 2. Arithmetic Operators

###### **$inc â†’ Increment (or decrement) a value**

```js
db.users.updateOne(
  { name: "Alice" },
  { $inc: { age: 1 } }
)
// Aliceâ€™s age increases by 1
```

###### **$mul â†’ Multiply a value**

```js
db.users.updateOne(
  { name: "Bob" },
  { $mul: { age: 2 } }
)
// Bobâ€™s age becomes 60
```

###### **$min â†’ Update only if new value is smaller**

```js
db.users.updateOne(
  { name: "Charlie" },
  { $min: { age: 25 } }
)
// Charlieâ€™s age set to 25 (since 25 < 28)
```

###### **$max â†’ Update only if new value is larger**

```js
db.users.updateOne(
  { name: "Alice" },
  { $max: { age: 30 } }
)
// Aliceâ€™s age set to 30 (since 30 > 24)
```

##### 3. Array Update Operators

###### **$push â†’ Add item to an array**

```js
db.users.updateOne(
  { name: "Alice" },
  { $push: { skills: "GraphQL" } }
)
// Adds "GraphQL" to Aliceâ€™s skills array
```

###### **$addToSet â†’ Add item if not already present**

```js
db.users.updateOne(
  { name: "Charlie" },
  { $addToSet: { skills: "Python" } }
)
// "Python" wonâ€™t be duplicated in Charlieâ€™s skills
```

###### **$pop â†’ Remove first (-1) or last (1) element**

```js
db.users.updateOne(
  { name: "Bob" },
  { $pop: { scores: -1 } }
)
// Removes first element from Bobâ€™s scores
```

###### **$pull â†’ Remove specific value from array**

```js
db.users.updateOne(
  { name: "Charlie" },
  { $pull: { scores: 75 } }
)
// Removes 75 from Charlieâ€™s scores
```

###### **$pullAll â†’ Remove multiple specific values**

```js
db.users.updateOne(
  { name: "Alice" },
  { $pullAll: { scores: [82, 90] } }
)
// Removes both 82 and 90 from Aliceâ€™s scores
```

##### 4. Current Date Operators

###### **$currentDate â†’ Set field to current date**

```js
db.users.updateOne(
  { name: "Alice" },
  { $currentDate: { lastModified: true } }
)
// Adds/updates lastModified with current date
```

###### **$currentDate with timestamp**

```js
db.users.updateOne(
  { name: "Bob" },
  { $currentDate: { lastLogin: { $type: "timestamp" } } }
)
// Adds 'lastLogin' field as a timestamp
```

---

### 4. Delete

#### Delete One Document

```js
db.users.deleteOne({ name: "Charlie" })
```

#### Delete Many Documents

```js
db.users.deleteMany({ age: { $gte: 30 } })
```

#### Truncate a Collection 

```js
db.users.deleteMany({})
```

#### Drop Entire Collection

```js
db.users.drop()
```

ğŸ‘‰ Deletes can target specific documents or entire collections.

---

# [Mongoose Tutorial](https://www.apnacollege.in/path-player?courseid=sigma-8&unit=68a48c17c68931e41305b43bUnit)

## What is Mongoose?
Mongoose is an **Object Data Modeling (ODM) library for MongoDB and Node.js**. It acts as a bridge between your **applicationâ€™s code** and the **MongoDB database**, making it easier to work with MongoDB by providing schema-based data modeling and built-in data validation.

## What Mongoose Does

1. **Schema Definition**
    
    - In MongoDB, collections are schema-less by default.
    
    - Mongoose allows you to define a **schema** (structure) for documents in a collection, so you can enforce consistency.  
	    
	    Example: specifying that a "User" must have a `name` (string), `age` (number), and `email` (string).

1. **ODM (Object Data Modeling)**
    
    - It maps MongoDB documents to JavaScript objects.
    
    - Instead of writing raw queries, you interact with MongoDB through Mongoose models (classes created from schemas).

2. **Validation & Middleware**
    
    - Provides built-in validation (e.g., required fields, min/max values, regex patterns).
    
    - Supports middleware (hooks) like `pre-save` or `post-update`, useful for tasks such as hashing passwords before saving.

3. **Query Building**
    
    - Offers powerful, chainable query methods (`find()`, `findOne()`, `updateOne()`, etc.), making database interactions easier.

4. **Relationship Handling**
    
    - MongoDB is non-relational, but Mongoose provides ways to reference documents and even populate related data.

## Why Use Mongoose?

- Enforces **structure** in MongoDBâ€™s flexible collections.

- Makes **CRUD operations** more intuitive with JavaScript-friendly syntax.

- Provides **validation and error handling** out of the box.

- Supports **plugins** (for pagination, soft deletes, timestamps, etc.).

- Reduces the need to write repetitive boilerplate code.

---

## Let's Start with Mongoose
To **download and install Mongoose**, you use **npm (Node Package Manager)** because Mongoose is a Node.js library. Hereâ€™s the step-by-step process you can put directly into your notes:

### Steps to Install Mongoose

1. **Install Node.js and npm**
    
    - First, make sure Node.js is installed (it comes with npm).
    
    - Check with:
		
```bash
node -v
npm -v
```
>  If not installed, download Node.js from [https://nodejs.org](https://nodejs.org).

2. **Initialize a Node.js Project**
    
    - Navigate to your project folder in terminal/command prompt.
    
    - Run:
        
```bash
npm init -y
```
> This creates a `package.json` file to manage dependencies.

3. **Install Mongoose**
    
    - Run the following command:
        
```bash
npm install mongoose
```
> This downloads Mongoose and adds it as a dependency in your project.

4. **Verify Installation**
    
    - Check in your `package.json` under `"dependencies"` for:
        
```json
"mongoose": "^X.X.X"
```
	
	 Or, list installed packages with:
        
```bash
npm list mongoose
```

---

### How to connect MongoDB using Mongoose?

#### 1. Import Mongoose in Your JS File

```javascript
const mongoose = require("mongoose");
```

#### 2. Connect to MongoDB
Use the `mongoose.connect()` method.

##### Local MongoDB

```javascript
mongoose.connect("mongodb://127.0.0.1:27017/mydb")
  .then(() => console.log("âœ… Connected to MongoDB via Mongoose"))
  .catch(err => console.error("âŒ Connection error:", err));
```

- `127.0.0.1` â†’ localhost (your machine).

- `27017` â†’ default MongoDB port.

- `mydb` â†’ database name (will be created if it doesnâ€™t exist).

**Cloud (MongoDB Atlas)**

```javascript
mongoose.connect("mongodb+srv://username:password@cluster0.mongodb.net/mydb")
  .then(() => console.log("âœ… Connected to MongoDB Atlas"))
  .catch(err => console.error("âŒ Connection error:", err));
```

#### ğŸ”¹ Notes

- **Connection String**: `mongodb://127.0.0.1:27017/dbname` (local) or `mongodb+srv://...` (cloud).

- **Asynchronous**: Always handle with `.then/.catch` or `async/await`.

- **Auto DB Creation**: MongoDB creates the database automatically when you insert the first document.

---

### How to create Schema and Model?
#### 1. What is a Schema in Mongoose?

- A **schema** defines the **structure of documents** in a MongoDB collection.

- It tells Mongoose:
    
    - what fields exist,
    
    - their **data types**,
    
    - whether theyâ€™re required, unique, etc.

ğŸ‘‰ Think of it as a **blueprint** for your documents.

#### 2. Creating a Schema
Example:

```javascript
const mongoose = require("mongoose");

// Define Schema
const userSchema = new mongoose.Schema({
	name: {
    	type: String,
    	required: [true, "Name is required"],   // Constraint + Custom error
    	minlength: [3, "Name must be at least 3 characters long"]
	},
	age: {
    	type: Number,
    	min: [0, "Age cannot be negative"],     // Constraint + Custom error
    	max: [120, "Age is too high"]           // Constraint + Custom error
	},
	email: {
    	type: String,
    	required: [true, "Email is required"],
    	unique: true,                           // Constraint
    	match: [/.+\@.+\..+/, "Invalid email format"] // Regex validation
	},
	createdAt: {
    	type: Date,
    	default: Date.now                      // Default value
	},
	isActive: {
    	type: Boolean,
    	default: true
	}
});
```

#### 3. Constraints in Mongoose Schema
Here are the most commonly used:

|Constraint|Example|Meaning|
|---|---|---|
|**type**|`{ type: String }`|Defines field data type|
|**required**|`required: true` or `[true, "Custom message"]`|Field must exist|
|**unique**|`unique: true`|Ensures no duplicates in collection|
|**default**|`default: Date.now`|Auto-assign default value|
|**min / max**|`min: 0, max: 120`|Works on Numbers|
|**minlength / maxlength**|`minlength: 3`|Works on Strings|
|**match**|`match: /regex/`|Validates with regex|
|**enum**|`enum: ["admin", "user", "guest"]`|Restricts values to a set|

#### 4. Custom Error Messages
Instead of generic errors, you can add **custom messages** like this:

```javascript
name: {
  type: String,
  required: [true, "Please enter your name"], // custom message
  minlength: [3, "Name too short! Must be 3+ chars"]
}
```

âš¡ If validation fails â†’ Mongoose throws a `ValidationError` with your custom message.

#### 5. Creating a Model
A **Model** is a wrapper around the schema â†’ represents a MongoDB collection.

```javascript
// Create Model
const User = mongoose.model("User", userSchema);
```

- `"User"` â†’ singular form; Mongoose automatically makes it plural (`users`) in MongoDB.

- `userSchema` â†’ blueprint for documents inside `users` collection.

#### 6. Using the Model
Example: inserting a document:

```javascript
const newUser = new User({
  name: "Jo",
  age: -5, // âŒ Will trigger custom error: "Age cannot be negative"
  email: "invalidEmail" // âŒ Will trigger custom error: "Invalid email format"
});

newUser.save()
  .then(() => console.log("User saved"))
  .catch(err => console.log("Error:", err.message));
```

---

### CRUD Operations

#### 1. Create

##### ğŸŸ¢ `new Model().save()`

- **What it does**: Creates a Mongoose **document instance** and saves it.

- **Runs validation?** âœ… Yes

- **Runs middleware?** âœ… Yes (e.g. `pre('save')`, `post('save')`)

- **Best for**: When you need per-document logic (e.g., hashing a password before saving).

- **Example**:
    
```javascript
const user = new User({ name: "Alice", age: 25, email: "alice@example.com" });
await user.save();
```

##### ğŸŸ¢ `Model.create()`

- **What it does**: A shortcut â†’ creates a doc and immediately saves it. Can take single or multiple docs.

- **Runs validation?** âœ… Yes

- **Runs middleware?** âœ… Yes

- **Best for**: Quick inserts when you donâ€™t need to modify the document before saving.

- **Example**:
	
```javascript
await User.create({ name: "Bob", age: 30, email: "bob@example.com" });
```

##### ğŸŸ¢ `Model.insertOne()`

- **What it does**: Direct wrapper around MongoDB driverâ€™s `insertOne()`.

- **Runs validation?** âš¡ Optional (`runValidators: true`)

- **Runs middleware?** âŒ No (`pre('save')`, `post('save')` wonâ€™t run)

- **Returns**: A raw MongoDB result (not a full Mongoose document).

- **Best for**: Fast inserts when you donâ€™t need Mongoose features.

- **Example**:
    
```javascript
await User.insertOne(
  { name: "Charlie", age: 28, email: "charlie@example.com" },
  { runValidators: true }
);
```

##### ğŸŸ¢ `Model.insertMany()`

- **What it does**: Inserts multiple documents at once (bulk insert).

- **Runs validation?** âœ… Yes (by default)

- **Runs middleware?** âŒ No (unless `{ rawResult: false }` and `save` hooks are not used)

- **Best for**: High-performance batch inserts.

- **Example**:
    
```javascript
await User.insertMany([
  { name: "David", age: 32, email: "david@example.com" },
  { name: "Eve", age: 27, email: "eve@example.com" }
]);
```

##### ğŸ“Š Comparison Table

|Method|Single/Multi|Validation|Middleware|Returns|Use Case|
|---|---|---|---|---|---|
|`new Model().save()`|Single|âœ… Yes|âœ… Yes|Full Mongoose doc|Full control, per-doc logic|
|`Model.create()`|Single/Multi|âœ… Yes|âœ… Yes|Full Mongoose doc(s)|Quick inserts, easy syntax|
|`Model.insertOne()`|Single|âš¡ Optional|âŒ No|Raw MongoDB result|Speed-critical single insert|
|`Model.insertMany()`|Multi|âœ… Yes|âŒ No|Array of docs|Fast bulk inserts|

---

#### 2. Read

##### 1. Find All Documents â†’ `Model.find()`

- Returns **all matching documents** (array).
    
```javascript
const users = await User.find();  
console.log(users);
```

ğŸ‘‰ Equivalent to `SELECT * FROM users`.

##### 2. Find with Conditions â†’ `Model.find(query)`

- Pass a filter object to match specific fields.
    
```javascript
const users = await User.find({ age: { $gte: 18 } });
console.log(users);
```

ğŸ‘‰ Example: Get all users where `age >= 18`.

##### 3. Find One Document â†’ `Model.findOne()`

- Returns the **first matching document**.
    
```javascript
const user = await User.findOne({ email: "alice@example.com" });
console.log(user);
```

ğŸ‘‰ Equivalent to `LIMIT 1`.

##### 4. Find by ID â†’ `Model.findById()`

- Shortcut for querying by `_id`.
    
```javascript
const user = await User.findById("64efc86db8f6a52d9d1a1234");
console.log(user);
```

##### 5. Projection (Select Specific Fields)

- Use `.select()` to limit fields.
    
```javascript
const users = await User.find().select("name email -_id");
console.log(users);
```

ğŸ‘‰ Returns only `name` and `email`, excludes `_id`.

##### 6. Sorting Results

```javascript
const users = await User.find().sort({ age: -1 }); // descending
console.log(users);
```

##### 7. Limiting & Skipping

```javascript
const users = await User.find().limit(5).skip(10);
console.log(users);
```

ğŸ‘‰ Useful for **pagination**.

##### 8. Query Operators

You can use MongoDB operators inside Mongoose queries:

```javascript
// Age between 18 and 30
const users = await User.find({ age: { $gte: 18, $lte: 30 } });

// Name starts with 'A'
const users2 = await User.find({ name: /^A/ });
```

##### 9. Counting Documents

```javascript
const count = await User.countDocuments({ isActive: true });
console.log("Active users:", count);
```

##### 10. Lean Queries (Performance Tip)

- By default, Mongoose returns **full documents** with extra methods.

- For faster reads (when you only need plain JSON objects), use `.lean()`.
    
```javascript
const users = await User.find().lean();
console.log(users); // Plain JS objects, faster
```

---

#### 3. Update

##### ğŸŸ  `updateOne()`

- Updates **first matching document**.

- Returns result object (not the updated doc).
    
```javascript
await User.updateOne(
  { email: "alice@example.com" },     // filter
  { $set: { age: 26 } }               // update
);
```

ğŸ‘‰ Example: set Aliceâ€™s age to 26.

##### ğŸŸ  `updateMany()`

- Updates **all documents** matching filter.
    
```javascript
await User.updateMany(
  { isActive: true },
  { $set: { isActive: false } }
);
```

ğŸ‘‰ Example: deactivate all active users.

##### ğŸŸ  `findByIdAndUpdate()`

- Finds by `_id` and updates.

- Returns the **old doc** by default (unless you pass `{ new: true }`).
    
```javascript
const user = await User.findByIdAndUpdate(
  "64efc86db8f6a52d9d1a1234",       // id
  { age: 29 },                      // update
  { new: true, runValidators: true } // options
);
console.log(user);
```

ğŸ‘‰ Example: update age and return updated doc.

##### ğŸŸ  `findOneAndUpdate()`

- Updates **first doc matching filter**.

- Similar to `updateOne()`, but returns the doc (old/new).
    
```javascript
const user = await User.findOneAndUpdate(
  { email: "bob@example.com" },
  { $set: { name: "Bobby" } },
  { new: true, runValidators: true }
);
console.log(user);
```

##### ğŸ” Updating Using the Document Instance

If you already have a doc (queried with `findOne`/`findById`), you can update and save:

```javascript
const user = await User.findOne({ email: "eve@example.com" });
user.age = 35;
await user.save();   // runs full validation + middleware
```

##### ğŸ‘‰ Options You Should Know
When updating, always consider:

- **`new: true`** â†’ return the updated doc (instead of old).

- **`runValidators: true`** â†’ enforce schema validation.

- **`upsert: true`** â†’ insert if doc doesnâ€™t exist.

Example:

```javascript
await User.findOneAndUpdate(
  { email: "nonexistent@example.com" },
  { $set: { name: "New User", age: 20 } },
  { upsert: true, new: true, runValidators: true }
);
```

##### ğŸ“Š Summary Table

|Method|Updates|Returns by default|Runs Validation?|Middleware?|
|---|---|---|---|---|
|`updateOne()`|First match|Result object|âŒ No (unless set)|âŒ|
|`updateMany()`|All matches|Result object|âŒ No (unless set)|âŒ|
|`findByIdAndUpdate()`|By `_id`|Old doc|âš¡ Yes (with `runValidators`)|âš¡ Limited|
|`findOneAndUpdate()`|First match|Old doc|âš¡ Yes (with `runValidators`)|âš¡ Limited|
|`doc.save()`|That document|Updated doc|âœ… Always|âœ… Full|

---

#### Delete

##### ğŸŸ¡ `deleteOne()`

- Deletes **the first document** that matches the filter.

- Returns a result object (with `deletedCount`).
    
```javascript
await User.deleteOne({ email: "alice@example.com" });
```

ğŸ‘‰ Example: deletes the user with Aliceâ€™s email.

##### ğŸŸ¡ `deleteMany()`

- Deletes **all documents** that match the filter.
    
```javascript
await User.deleteMany({ isActive: false });
```

ğŸ‘‰ Example: delete all inactive users.

##### ğŸŸ¡ `findByIdAndDelete()`

- Finds a document by `_id` and deletes it.

- Returns the **deleted document** (not just result).
    
```javascript
const user = await User.findByIdAndDelete("64efc86db8f6a52d9d1a1234");
console.log("Deleted:", user);
```

##### ğŸŸ¡ `findOneAndDelete()`

- Finds the **first matching document**, deletes it, and returns the deleted doc.
    
```javascript
const user = await User.findOneAndDelete({ email: "bob@example.com" });
console.log("Deleted:", user);
```

##### âŒ Removing with Document Instance

If you already have a document fetched, you can call `.deleteOne()` or `.remove()` on it.

```javascript
const user = await User.findOne({ email: "eve@example.com" });
await user.deleteOne();   // deletes that specific doc
```

##### â€¼ï¸Important Notes

- `deleteOne()` / `deleteMany()` â†’ return `{ acknowledged: true, deletedCount: X }`

- `findByIdAndDelete()` / `findOneAndDelete()` â†’ return the deleted **document**.

- **Validation & middleware**:
    
    - `deleteOne()` / `deleteMany()` do **not** run middleware.
    
    - `findOneAndDelete()` / `findByIdAndDelete()` can trigger query middleware (`pre('findOneAndDelete')`, etc.).
    
    - Document `.remove()`/`.deleteOne()` can trigger **document middleware**.

---

