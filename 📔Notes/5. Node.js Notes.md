# [Node. js Tutorial](https://www.apnacollege.in/path-player?courseid=sigma-8&unit=688f6e5157ce496f9609b458Unit)

## What is Node.js?
**Node.js** is an **open-source, cross-platform runtime environment** that allows you to run  **[[4. JavaScript Notes|JavaScript]] on the server side**, outside of a browser.

### üîß In Simple Terms:

Traditionally, JavaScript was only used for client-side (browser) scripting. Node.js broke that limitation by letting developers use JavaScript to build backend/server-side applications too.

### üß† Key Technical Details:

- **Built on V8 engine** ‚Äì the same JavaScript engine used by Google Chrome.

- **Event-driven & non-blocking I/O** ‚Äì handles many requests at once efficiently (ideal for real-time applications).

- **Single-threaded** but uses the **event loop** and **callbacks/promises/async-await** to manage concurrency.

- Uses **npm (Node Package Manager)** ‚Äì the largest ecosystem of open-source libraries in the world.

### ‚öôÔ∏è Common Use Cases:

- REST APIs & web servers (e.g., Express.js)

- Real-time apps (e.g., chat apps using Socket.io)

- Command-line tools

- Microservices

- Server less architecture

- Backend for IoT apps

---

## What is Node [[REPL]]?

### üöÄ How to Start Node REPL:
Just run this command in your terminal:

```bash
node
```

You'll see a prompt like this:

```bash
>
```

Now you can enter any JavaScript code, like:

```js
> 5 * 5
25

> const x = 10
undefined

> x + 20
30
```

### üîß Useful REPL Commands:

|Command|Description|
|---|---|
|`.help`|List all REPL commands|
|`.exit`|Exit the REPL|
|`.clear`|Clear the current REPL context|
|`.save filename.js`|Save current session to file|
|`.load filename.js`|Load a JS file into REPL|

### üìå When to Use REPL:

- Quick experiments with JS/Node

- Testing snippets before putting them in your app

- Learning or debugging JavaScript interactively

---

## How to create & run Node.js File?
Here's how you **create and run a Node.js file** step by step:

### 1. Set Up Node.js (if not done yet)
First, make sure Node.js is installed. Run:

```bash
node -v
```

If it shows a version (e.g., `v18.17.1`), you're good.  
If not, download and install from: [https://nodejs.org](https://nodejs.org/)

### 2. Create a Node.js File
Use any text editor (VS Code recommended).

**Example file**: `app.js`

```js
// app.js
console.log("Hello from Node.js!");
```

### 3. Run the File in Terminal
Navigate to the folder containing `app.js`:

```bash
cd path/to/your/project
```

Then run the file using Node:

```bash
node app.js
```

**Output:**

```
Hello from Node.js!
```

### üõ†Ô∏è Tips:

- File extension must be `.js`

- You can import other `.js` files using `require` or `import` (with ES Modules)

- Node.js files can use **modules**, **HTTP**, **File System**, etc.

---

## Node.js **Process**
In Node.js, `process` is a **global object** that gives you control over the **current Node.js process**‚Äîmeaning the program that is running right now.

You can use it to:

- Read environment variables

- Access command-line arguments

- Handle exit or error events

- Communicate with the terminal (stdin/stdout)

You don‚Äôt need to `require` it ‚Äî it's **always available**.

### Example:

```js
console.log(process); // Massive object with lots of info
```

### Most Common `process` Features

#### 1. **`process.argv`** ‚Äì Command-line arguments

```js
// test.js
console.log(process.argv);
```

Run:

```bash
node test.js hello world
```

Output:

```js
[
  '/path/to/node',
  '/path/to/test.js',
  'hello',
  'world'
]
```

> Use this for CLI tools.

#### 2. **`process.env`** ‚Äì Environment variables

```js
console.log(process.env.USER); // or process.env.YOUR_CUSTOM_VAR
```

Set a variable (Linux/macOS):

```bash
USER_NAME=Sankho node app.js
```

#### 3. **`process.exit([code])`** ‚Äì Exit the process

```js
if (somethingWentWrong) {
  console.error("Error occurred!");
  process.exit(1); // Exit with error code
}
```

#### 4. **`process.cwd()`** ‚Äì Current working directory

```js
console.log("Current folder:", process.cwd());
```

#### 5. **`process.stdin` / `stdout` / `stderr`** ‚Äì Input/output streams

```js
process.stdout.write("Hello\n");
```

You can even build interactive CLI apps using `process.stdin`.

#### 6. **`process.on('exit', callback)`** ‚Äì Handle exit events

```js
process.on('exit', (code) => {
  console.log(`Process exiting with code: ${code}`);
});
```

#### üß† Summary

| Property/Method      | Purpose                       |
| -------------------- | ----------------------------- |
| `process.argv`       | Read CLI arguments            |
| `process.env`        | Access environment variables  |
| `process.exit(code)` | Exit process manually         |
| `process.cwd()`      | Get current working directory |
| `process.stdin`      | Read from terminal input      |
| `process.stdout`     | Write to terminal             |

### Real-World Use Cases:

- Build CLI tools (like `npm`, `nodemon`)

- Create environment-based configs (`process.env.NODE_ENV`)

- Log system info for debugging

- Gracefully shut down servers

---

## `module.exports` & `require()` in Node.js
In **Node.js**, every file is treated as a **module**. You use:

- `module.exports` ‚Üí to **export** variables, functions, or objects from a module.

- `require()` ‚Üí to **import** them into another file.

### 1. `module.exports` ‚Äì Export from a Module
Use `module.exports` to make something available outside the file.

#### üîß Example ‚Äì `math.js`

```js
// math.js
// Hello... First write some mathematical functions & variables.
const sum = (a, b) => a + b;
const sub = (a, b) => a - b;
const mul = (a, b) => a * b;
const div = (a, b) => a / b;
const PI = 3.14;
const g = 9.8;

// Problem: I want to use these function in my main js file (script.js).
// Introducing module.exports
/*
By default, it returns an empty object. (To other files)
But, we can easily change that datatype by just assigning that kind of value.
i.e. module.exports = "Hello";
But, we use objects to pass the information in a structural way.
*/

//How can we pass all these info?
// Method 1
{
    // Version 1
    let method = {
        sum: sum,
        sub: sub,
        mul: mul,
        div: div,
        PI: PI,
        g: g,
    };
    // module.exports = method;
	
    // Version 2 (compact)
    //     module.exports = {
    //     sum: sum,
    //     sub: sub,
    //     mul: mul,
    //     div: div,
    //     PI: PI,
    //     g: g,
    // };
    // We can individually select what we want to send... but, not scalable.
}
// Method 2
{
    /*     module.exports.sum = (a, b) => a + b;
    module.exports.sub = (a, b) => a - b;
    module.exports.mul = (a, b) => a * b;
    module.exports.div = (a, b) => a / b;
    module.exports.PI = 3.14;
    module.exports.g = 9.8; */
	
    // We can directly make them as a method. But the down side is we can't access them directly in this file... We have to access them as a method.

    // ShortHand
    exports.sum = (a, b) => a + b;
    exports.sub = (a, b) => a - b;
    exports.mul = (a, b) => a * b;
    exports.div = (a, b) => a / b;
    exports.PI = 3.14;
    exports.g = 9.8;
    // We can use this shorthand only in this method... If we try to write method 1 with only exports instead of module.exports then, it will cause error... Because then JS treat exports as an normal objects... To work this method we have to treat exports as an already existing method an push some new info using dot notation.
}
```

### 2. `require()` ‚Äì Import a Module
Now import and use that file:

#### üîß Example ‚Äì `app.js`

```js
// app.js
let math = require("./math");
//                    ^
//                    +- Here we pass the path as string.
//                    +- '.' means current working directory.
console.log(math.sum(13, 16));
console.log(math.PI);
```

### How It Works Internally

Every Node.js module is wrapped in a function like:

```js
(function(exports, require, module, __filename, __dirname) {
  // your code here
});
```

This is why `module.exports` and `require()` work like they do.

---

### `exports` vs `module.exports`

- `exports` is a shortcut to `module.exports`

- But if you assign a new object to `exports`, you break the link

‚úî Correct:

```js
exports.sayHi = () => console.log("Hi");
```

‚ùå Wrong:

```js
exports = { sayHi: () => console.log("Hi") }; // won't work
```

‚úî Instead:

```js
module.exports = { sayHi: () => console.log("Hi") };
```

### Summary Table

|What You Want to Export|How to Export|How to Import|
|---|---|---|
|Single function|`module.exports = myFunc`|`const myFunc = require('./file')`|
|Object with many functions|`module.exports = { a, b }`|`const utils = require('./file')`|
|Class|`module.exports = MyClass`|`const MyClass = require('./file')`|

---

## Export from a **Directory** in Node.js
When you want to organize code in **multiple files** inside a **folder** (module directory), you can export from the directory **as a single module**.

This lets you:

- Split logic across multiple files

- Clean up your project structure

- Import everything with one `require('./folder')`

### Step-by-Step Guide

#### üìÅ Folder structure:

```
/mathUtils
‚îÇ
‚îú‚îÄ‚îÄ add.js
‚îú‚îÄ‚îÄ subtract.js
‚îú‚îÄ‚îÄ index.js   <-- This is the key
```

#### 1Ô∏è‚É£ `add.js`

```js
// add.js
function add(a, b) {
  return a + b;
}

module.exports = add;
```

#### 2Ô∏è‚É£ `subtract.js`

```js
// subtract.js
function subtract(a, b) {
  return a - b;
}

module.exports = subtract;
```

#### 3Ô∏è‚É£ `index.js` (Entry point for the folder)

```js
// index.js
const add = require('./add');
const subtract = require('./subtract');

module.exports = {
  add,
  subtract
};
```

> ‚úÖ Node will **automatically look for `index.js`** when you import the folder.

### Now use it anywhere:

#### üì¶ `app.js`

```js
const math = require('./mathUtils');

console.log(math.add(5, 3));      // 8
console.log(math.subtract(10, 4)); // 6

/* 
So, what happened?
=> You see, index.js is a special name (we can't give it any other name :( )... If we just write directory name then it wants to acquire the data of index.js by default.
=> In this way we can fetch all data at once.
*/
```

### How It Works:

- When you do `require('./mathUtils')`, Node looks for:
    
    1. `mathUtils.js` file
    
    2. If not found, `mathUtils/index.js` file

### Summary

|Goal|What to Do|
|---|---|
|Export multiple files from a folder|Create `index.js` in that folder|
|Import from that folder|`require('./folderName')`|

---

## npm in Node.js
**npm** stands for **Node Package Manager**.  

It is:

- A **command-line tool**  

- A **package registry** (the world's largest JS library collection)  

- A **core part of Node.js development**

### What Can You Do with `npm`?

|Feature|Description|
|---|---|
|Install packages|Download libraries like `express`, `axios`, etc|
|Manage dependencies|Tracks what's used in your project|
|Run scripts|Automate commands (e.g., `npm start`)|
|Publish packages|Share your own modules|
|Handle versioning|Lock down or update packages|

### Installing & Using `npm`
`npm` comes **bundled** with Node.js.  
Check version:

```bash
npm -v
```

#### 1. Initialize a New Project

```bash
npm init
```

or fast setup:

```bash
npm init -y
```

Creates a `package.json` file to manage your project.

#### 2. Install Packages

##### **Local (project-specific):**

```bash
npm install express
```

Adds to `node_modules/` + `package.json`

##### **Global (system-wide / not recommended):**

```bash
npm install -g nodemon
```

Then, we have to link it with our project:

```shell
npm link nodemon
```

#### 3. Update / Remove Packages

```bash
npm update
npm uninstall axios
```

#### 4. Run Scripts
Inside `package.json`:

```json
"scripts": {
  "start": "node index.js",
  "dev": "nodemon app.js"
}
```

Run with:

```bash
npm run start
npm run dev
```

### üìÇ Key Files

| File                | Purpose                                                                                                                                                                                                                                                                                                                                                                                                |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `package.json`      | It's the most important file of all three. If we want to give our code, then, sending the whole node_modules directory is not optimal. Rather we send the `package.json` which contains descriptive & functional metadata of our project, in other word "A blueprint of the project dependencies & metadata". The receiver then can install the dependencies on there own. **Command**: `npm install`. |
| `package-lock.json` | It's a JSON file that stores the crucial information about the packages and the details of sub-dependencies.                                                                                                                                                                                                                                                                                           |
| `node_modules/`     | It's the main folder that includes all dependencies of the package and the package itself.                                                                                                                                                                                                                                                                                                             |

### Popular `npm` Packages

- `express` ‚Äì Web framework

- `axios` ‚Äì HTTP requests

- `dotenv` ‚Äì Manage env vars

- `lodash` ‚Äì Utility functions

- `mongoose` ‚Äì MongoDB ORM

- `chalk` ‚Äì Colorful console output

-  `figlet` ‚Äì Print using ASCII letters

---

## Import & Export in Node.js
In Node.js, **import** and **export** are mechanisms for modularizing code ‚Äî allowing you to split your application into reusable pieces. Node.js supports **two module systems**:

### 1. CommonJS (CJS) ‚Äî **Default in Node.js**

Used in older Node.js versions and still widely used.

#### ‚ñ∂ Import:

```js
const fs = require('fs');
const myFunc = require('./myModule');
```

#### ‚ñ∂ Export:

```js
// myModule.js
function myFunc() {
  console.log("Hello from CommonJS");
}

module.exports = myFunc;

// OR for multiple exports
module.exports = {
  myFunc,
  anotherFunc
};
```

### 2. ECMAScript Modules (ESM) ‚Äî **Modern (ES6) Modules**
Supported natively in recent Node.js versions (>=12.20, full support in 14+). You must use **`.mjs` extension** or set `"type": "module"` in `package.json`.

#### ‚ñ∂ Import:

```js
import fs from 'fs';
import myFunc from './myModule.js';
```

#### ‚ñ∂ Export:

```js
// myModule.mjs or with "type": "module"
export default function myFunc() {
  console.log("Hello from ESM");
}

// Named export
export function helper() {}

// Import named:
import { helper } from './myModule.js';
```

### Key Differences

| Feature         | CommonJS (CJS)                                                               | ES Modules (ESM)                                                         |
| --------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| Syntax          | `require`, `module.exports`                                                  | `import`, `export`                                                       |
| Load type       | Synchronous                                                                  | Asynchronous (uses Promises)                                             |
| File extension  | `.js`                                                                        | `.mjs` or `"type": "module"` in `package.json`                           |
| Top-level await | ‚ùå Not supported                                                              | ‚úÖ Supported                                                              |
| Memory          | Have to import all the File's content, even Though we don't use all Of them. | We can selectively import Some useful parts only. It's memory efficient. |

### When to Use What?

- Use **CommonJS** if you're working with older codebases or writing CLI tools.

- Use **ESM** for modern applications, especially if you're using top-level `await`, tree-shaking, or working in frontend-heavy environments.

- If you're mixing both: **Don‚Äôt.** It's messy. Stick to one system per project.

### How to Enable ESM in Node.js?

#### Option 1: Use `.mjs`

```bash
node myApp.mjs
```

#### Option 2: Use `"type": "module"` in `package.json`

```json
{
  "type": "module"
}
```

Then `.js` files will be treated as ES modules.

---
